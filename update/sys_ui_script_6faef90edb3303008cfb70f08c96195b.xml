<?xml version="1.0" encoding="UTF-8"?>
<record_update table="sys_ui_script">
    <sys_ui_script action="INSERT_OR_UPDATE">
        <active>true</active>
        <description/>
        <global>false</global>
        <name>x_pisn_imagemap.Fabricjs</name>
        <script>/* build: `node build.js modules=ALL exclude=gestures,accessors minifier=uglifyjs` */&#13;
 /*! Fabric.js Copyright 2008-2015, Printio (Juriy Zaytsev, Maxim Chernyak) */&#13;
&#13;
var fabric = fabric || { version: '2.0.0-rc.4' };&#13;
if (typeof exports !== 'undefined') {&#13;
  exports.fabric = fabric;&#13;
}&#13;
&#13;
if (typeof document !== 'undefined' &amp;&amp; typeof window !== 'undefined') {&#13;
  fabric.document = document;&#13;
  fabric.window = window;&#13;
}&#13;
else {&#13;
  // assume we're running under node.js when document/window are not present&#13;
  fabric.document = require('jsdom')&#13;
    .jsdom(&#13;
      decodeURIComponent('%3C!DOCTYPE%20html%3E%3Chtml%3E%3Chead%3E%3C%2Fhead%3E%3Cbody%3E%3C%2Fbody%3E%3C%2Fhtml%3E'),&#13;
      { features: {&#13;
        FetchExternalResources: ['img']&#13;
      }&#13;
      });&#13;
  fabric.jsdomImplForWrapper = require('jsdom/lib/jsdom/living/generated/utils').implForWrapper;&#13;
  fabric.nodeCanvas = require('jsdom/lib/jsdom/utils').Canvas;&#13;
  fabric.window = fabric.document.defaultView;&#13;
  DOMParser = require('xmldom').DOMParser;&#13;
}&#13;
&#13;
/**&#13;
 * True when in environment that supports touch events&#13;
 * @type boolean&#13;
 */&#13;
fabric.isTouchSupported = 'ontouchstart' in fabric.window;&#13;
&#13;
/**&#13;
 * True when in environment that's probably Node.js&#13;
 * @type boolean&#13;
 */&#13;
fabric.isLikelyNode = typeof Buffer !== 'undefined' &amp;&amp;&#13;
                      typeof window === 'undefined';&#13;
&#13;
/* _FROM_SVG_START_ */&#13;
/**&#13;
 * Attributes parsed from all SVG elements&#13;
 * @type array&#13;
 */&#13;
fabric.SHARED_ATTRIBUTES = [&#13;
  "display",&#13;
  "transform",&#13;
  "fill", "fill-opacity", "fill-rule",&#13;
  "opacity",&#13;
  "stroke", "stroke-dasharray", "stroke-linecap",&#13;
  "stroke-linejoin", "stroke-miterlimit",&#13;
  "stroke-opacity", "stroke-width",&#13;
  "id", "paint-order",&#13;
  "instantiated_by_use"&#13;
];&#13;
/* _FROM_SVG_END_ */&#13;
&#13;
/**&#13;
 * Pixel per Inch as a default value set to 96. Can be changed for more realistic conversion.&#13;
 */&#13;
fabric.DPI = 96;&#13;
fabric.reNum = '(?:[-+]?(?:\\d+|\\d*\\.\\d+)(?:e[-+]?\\d+)?)';&#13;
fabric.fontPaths = { };&#13;
fabric.iMatrix = [1, 0, 0, 1, 0, 0];&#13;
fabric.canvasModule = 'canvas';&#13;
&#13;
/**&#13;
 * Pixel limit for cache canvases. 1Mpx , 4Mpx should be fine.&#13;
 * @since 1.7.14&#13;
 * @type Number&#13;
 * @default&#13;
 */&#13;
fabric.perfLimitSizeTotal = 2097152;&#13;
&#13;
/**&#13;
 * Pixel limit for cache canvases width or height. IE fixes the maximum at 5000&#13;
 * @since 1.7.14&#13;
 * @type Number&#13;
 * @default&#13;
 */&#13;
fabric.maxCacheSideLimit = 4096;&#13;
&#13;
/**&#13;
 * Lowest pixel limit for cache canvases, set at 256PX&#13;
 * @since 1.7.14&#13;
 * @type Number&#13;
 * @default&#13;
 */&#13;
fabric.minCacheSideLimit = 256;&#13;
&#13;
/**&#13;
 * Cache Object for widths of chars in text rendering.&#13;
 */&#13;
fabric.charWidthsCache = { };&#13;
&#13;
/**&#13;
 * if webgl is enabled and available, textureSize will determine the size&#13;
 * of the canvas backend&#13;
 * @since 2.0.0&#13;
 * @type Number&#13;
 * @default&#13;
 */&#13;
fabric.textureSize = 2048;&#13;
&#13;
/**&#13;
 * Enable webgl for filtering picture is available&#13;
 * A filtering backend will be initialized, this will both take memory and&#13;
 * time since a default 2048x2048 canvas will be created for the gl context&#13;
 * @since 2.0.0&#13;
 * @type Boolean&#13;
 * @default&#13;
 */&#13;
fabric.enableGLFiltering = true;&#13;
&#13;
/**&#13;
 * Device Pixel Ratio&#13;
 * @see https://developer.apple.com/library/safari/documentation/AudioVideo/Conceptual/HTML-canvas-guide/SettingUptheCanvas/SettingUptheCanvas.html&#13;
 */&#13;
fabric.devicePixelRatio = fabric.window.devicePixelRatio ||&#13;
                          fabric.window.webkitDevicePixelRatio ||&#13;
                          fabric.window.mozDevicePixelRatio ||&#13;
                          1;&#13;
/**&#13;
 * Browser-specific constant to adjust CanvasRenderingContext2D.shadowBlur value,&#13;
 * which is unitless and not rendered equally across browsers.&#13;
 *&#13;
 * Values that work quite well (as of October 2017) are:&#13;
 * - Chrome: 1.5&#13;
 * - Edge: 1.75&#13;
 * - Firefox: 0.9&#13;
 * - Safari: 0.95&#13;
 *&#13;
 * @since 2.0.0&#13;
 * @type Number&#13;
 * @default 1&#13;
 */&#13;
fabric.browserShadowBlurConstant = 1;&#13;
&#13;
fabric.initFilterBackend = function() {&#13;
  if (fabric.enableGLFiltering &amp;&amp; fabric.isWebglSupported &amp;&amp; fabric.isWebglSupported(fabric.textureSize)) {&#13;
    console.log('max texture size: ' + fabric.maxTextureSize);&#13;
    return (new fabric.WebglFilterBackend({ tileSize: fabric.textureSize }));&#13;
  }&#13;
  else if (fabric.Canvas2dFilterBackend) {&#13;
    return (new fabric.Canvas2dFilterBackend());&#13;
  }&#13;
};&#13;
&#13;
&#13;
if (typeof document !== 'undefined' &amp;&amp; typeof window !== 'undefined') {&#13;
  // ensure globality even if entire library were function wrapped (as in Meteor.js packaging system)&#13;
  window.fabric = fabric;&#13;
}&#13;
&#13;
&#13;
(function() {&#13;
&#13;
  /**&#13;
   * @private&#13;
   * @param {String} eventName&#13;
   * @param {Function} handler&#13;
   */&#13;
  function _removeEventListener(eventName, handler) {&#13;
    if (!this.__eventListeners[eventName]) {&#13;
      return;&#13;
    }&#13;
    var eventListener = this.__eventListeners[eventName];&#13;
    if (handler) {&#13;
      eventListener[eventListener.indexOf(handler)] = false;&#13;
    }&#13;
    else {&#13;
      fabric.util.array.fill(eventListener, false);&#13;
    }&#13;
  }&#13;
&#13;
  /**&#13;
   * Observes specified event&#13;
   * @deprecated `observe` deprecated since 0.8.34 (use `on` instead)&#13;
   * @memberOf fabric.Observable&#13;
   * @alias on&#13;
   * @param {String|Object} eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})&#13;
   * @param {Function} handler Function that receives a notification when an event of the specified type occurs&#13;
   * @return {Self} thisArg&#13;
   * @chainable&#13;
   */&#13;
  function observe(eventName, handler) {&#13;
    if (!this.__eventListeners) {&#13;
      this.__eventListeners = { };&#13;
    }&#13;
    // one object with key/value pairs was passed&#13;
    if (arguments.length === 1) {&#13;
      for (var prop in eventName) {&#13;
        this.on(prop, eventName[prop]);&#13;
      }&#13;
    }&#13;
    else {&#13;
      if (!this.__eventListeners[eventName]) {&#13;
        this.__eventListeners[eventName] = [];&#13;
      }&#13;
      this.__eventListeners[eventName].push(handler);&#13;
    }&#13;
    return this;&#13;
  }&#13;
&#13;
  /**&#13;
   * Stops event observing for a particular event handler. Calling this method&#13;
   * without arguments removes all handlers for all events&#13;
   * @deprecated `stopObserving` deprecated since 0.8.34 (use `off` instead)&#13;
   * @memberOf fabric.Observable&#13;
   * @alias off&#13;
   * @param {String|Object} eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})&#13;
   * @param {Function} handler Function to be deleted from EventListeners&#13;
   * @return {Self} thisArg&#13;
   * @chainable&#13;
   */&#13;
  function stopObserving(eventName, handler) {&#13;
    if (!this.__eventListeners) {&#13;
      return;&#13;
    }&#13;
&#13;
    // remove all key/value pairs (event name -&gt; event handler)&#13;
    if (arguments.length === 0) {&#13;
      for (eventName in this.__eventListeners) {&#13;
        _removeEventListener.call(this, eventName);&#13;
      }&#13;
    }&#13;
    // one object with key/value pairs was passed&#13;
    else if (arguments.length === 1 &amp;&amp; typeof arguments[0] === 'object') {&#13;
      for (var prop in eventName) {&#13;
        _removeEventListener.call(this, prop, eventName[prop]);&#13;
      }&#13;
    }&#13;
    else {&#13;
      _removeEventListener.call(this, eventName, handler);&#13;
    }&#13;
    return this;&#13;
  }&#13;
&#13;
  /**&#13;
   * Fires event with an optional options object&#13;
   * @deprecated `fire` deprecated since 1.0.7 (use `trigger` instead)&#13;
   * @memberOf fabric.Observable&#13;
   * @alias trigger&#13;
   * @param {String} eventName Event name to fire&#13;
   * @param {Object} [options] Options object&#13;
   * @return {Self} thisArg&#13;
   * @chainable&#13;
   */&#13;
  function fire(eventName, options) {&#13;
    if (!this.__eventListeners) {&#13;
      return;&#13;
    }&#13;
&#13;
    var listenersForEvent = this.__eventListeners[eventName];&#13;
    if (!listenersForEvent) {&#13;
      return;&#13;
    }&#13;
&#13;
    for (var i = 0, len = listenersForEvent.length; i &lt; len; i++) {&#13;
      listenersForEvent[i] &amp;&amp; listenersForEvent[i].call(this, options || { });&#13;
    }&#13;
    this.__eventListeners[eventName] = listenersForEvent.filter(function(value) {&#13;
      return value !== false;&#13;
    });&#13;
    return this;&#13;
  }&#13;
&#13;
  /**&#13;
   * @namespace fabric.Observable&#13;
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#events}&#13;
   * @see {@link http://fabricjs.com/events|Events demo}&#13;
   */&#13;
  fabric.Observable = {&#13;
    observe: observe,&#13;
    stopObserving: stopObserving,&#13;
    fire: fire,&#13;
&#13;
    on: observe,&#13;
    off: stopObserving,&#13;
    trigger: fire&#13;
  };&#13;
})();&#13;
&#13;
&#13;
/**&#13;
 * @namespace fabric.Collection&#13;
 */&#13;
fabric.Collection = {&#13;
&#13;
  _objects: [],&#13;
&#13;
  /**&#13;
   * Adds objects to collection, Canvas or Group, then renders canvas&#13;
   * (if `renderOnAddRemove` is not `false`).&#13;
   * in case of Group no changes to bounding box are made.&#13;
   * Objects should be instances of (or inherit from) fabric.Object&#13;
   * Use of this function is highly discouraged for groups.&#13;
   * you can add a bunch of objects with the add method but then you NEED&#13;
   * to run a addWithUpdate call for the Group class or position/bbox will be wrong.&#13;
   * @param {...fabric.Object} object Zero or more fabric instances&#13;
   * @return {Self} thisArg&#13;
   * @chainable&#13;
   */&#13;
  add: function () {&#13;
    this._objects.push.apply(this._objects, arguments);&#13;
    if (this._onObjectAdded) {&#13;
      for (var i = 0, length = arguments.length; i &lt; length; i++) {&#13;
        this._onObjectAdded(arguments[i]);&#13;
      }&#13;
    }&#13;
    this.renderOnAddRemove &amp;&amp; this.requestRenderAll();&#13;
    return this;&#13;
  },&#13;
&#13;
  /**&#13;
   * Inserts an object into collection at specified index, then renders canvas (if `renderOnAddRemove` is not `false`)&#13;
   * An object should be an instance of (or inherit from) fabric.Object&#13;
   * Use of this function is highly discouraged for groups.&#13;
   * you can add a bunch of objects with the insertAt method but then you NEED&#13;
   * to run a addWithUpdate call for the Group class or position/bbox will be wrong.&#13;
   * @param {Object} object Object to insert&#13;
   * @param {Number} index Index to insert object at&#13;
   * @param {Boolean} nonSplicing When `true`, no splicing (shifting) of objects occurs&#13;
   * @return {Self} thisArg&#13;
   * @chainable&#13;
   */&#13;
  insertAt: function (object, index, nonSplicing) {&#13;
    var objects = this.getObjects();&#13;
    if (nonSplicing) {&#13;
      objects[index] = object;&#13;
    }&#13;
    else {&#13;
      objects.splice(index, 0, object);&#13;
    }&#13;
    this._onObjectAdded &amp;&amp; this._onObjectAdded(object);&#13;
    this.renderOnAddRemove &amp;&amp; this.requestRenderAll();&#13;
    return this;&#13;
  },&#13;
&#13;
  /**&#13;
   * Removes objects from a collection, then renders canvas (if `renderOnAddRemove` is not `false`)&#13;
   * @param {...fabric.Object} object Zero or more fabric instances&#13;
   * @return {Self} thisArg&#13;
   * @chainable&#13;
   */&#13;
  remove: function() {&#13;
    var objects = this.getObjects(),&#13;
        index, somethingRemoved = false;&#13;
&#13;
    for (var i = 0, length = arguments.length; i &lt; length; i++) {&#13;
      index = objects.indexOf(arguments[i]);&#13;
&#13;
      // only call onObjectRemoved if an object was actually removed&#13;
      if (index !== -1) {&#13;
        somethingRemoved = true;&#13;
        objects.splice(index, 1);&#13;
        this._onObjectRemoved &amp;&amp; this._onObjectRemoved(arguments[i]);&#13;
      }&#13;
    }&#13;
&#13;
    this.renderOnAddRemove &amp;&amp; somethingRemoved &amp;&amp; this.requestRenderAll();&#13;
    return this;&#13;
  },&#13;
&#13;
  /**&#13;
   * Executes given function for each object in this group&#13;
   * @param {Function} callback&#13;
   *                   Callback invoked with current object as first argument,&#13;
   *                   index - as second and an array of all objects - as third.&#13;
   *                   Callback is invoked in a context of Global Object (e.g. `window`)&#13;
   *                   when no `context` argument is given&#13;
   *&#13;
   * @param {Object} context Context (aka thisObject)&#13;
   * @return {Self} thisArg&#13;
   * @chainable&#13;
   */&#13;
  forEachObject: function(callback, context) {&#13;
    var objects = this.getObjects();&#13;
    for (var i = 0, len = objects.length; i &lt; len; i++) {&#13;
      callback.call(context, objects[i], i, objects);&#13;
    }&#13;
    return this;&#13;
  },&#13;
&#13;
  /**&#13;
   * Returns an array of children objects of this instance&#13;
   * Type parameter introduced in 1.3.10&#13;
   * @param {String} [type] When specified, only objects of this type are returned&#13;
   * @return {Array}&#13;
   */&#13;
  getObjects: function(type) {&#13;
    if (typeof type === 'undefined') {&#13;
      return this._objects;&#13;
    }&#13;
    return this._objects.filter(function(o) {&#13;
      return o.type === type;&#13;
    });&#13;
  },&#13;
&#13;
  /**&#13;
   * Returns object at specified index&#13;
   * @param {Number} index&#13;
   * @return {Self} thisArg&#13;
   */&#13;
  item: function (index) {&#13;
    return this.getObjects()[index];&#13;
  },&#13;
&#13;
  /**&#13;
   * Returns true if collection contains no objects&#13;
   * @return {Boolean} true if collection is empty&#13;
   */&#13;
  isEmpty: function () {&#13;
    return this.getObjects().length === 0;&#13;
  },&#13;
&#13;
  /**&#13;
   * Returns a size of a collection (i.e: length of an array containing its objects)&#13;
   * @return {Number} Collection size&#13;
   */&#13;
  size: function() {&#13;
    return this.getObjects().length;&#13;
  },&#13;
&#13;
  /**&#13;
   * Returns true if collection contains an object&#13;
   * @param {Object} object Object to check against&#13;
   * @return {Boolean} `true` if collection contains an object&#13;
   */&#13;
  contains: function(object) {&#13;
    return this.getObjects().indexOf(object) &gt; -1;&#13;
  },&#13;
&#13;
  /**&#13;
   * Returns number representation of a collection complexity&#13;
   * @return {Number} complexity&#13;
   */&#13;
  complexity: function () {&#13;
    return this.getObjects().reduce(function (memo, current) {&#13;
      memo += current.complexity ? current.complexity() : 0;&#13;
      return memo;&#13;
    }, 0);&#13;
  }&#13;
};&#13;
&#13;
&#13;
/**&#13;
 * @namespace fabric.CommonMethods&#13;
 */&#13;
fabric.CommonMethods = {&#13;
&#13;
  /**&#13;
   * Sets object's properties from options&#13;
   * @param {Object} [options] Options object&#13;
   */&#13;
  _setOptions: function(options) {&#13;
    for (var prop in options) {&#13;
      this.set(prop, options[prop]);&#13;
    }&#13;
  },&#13;
&#13;
  /**&#13;
   * @private&#13;
   * @param {Object} [filler] Options object&#13;
   * @param {String} [property] property to set the Gradient to&#13;
   */&#13;
  _initGradient: function(filler, property) {&#13;
    if (filler &amp;&amp; filler.colorStops &amp;&amp; !(filler instanceof fabric.Gradient)) {&#13;
      this.set(property, new fabric.Gradient(filler));&#13;
    }&#13;
  },&#13;
&#13;
  /**&#13;
   * @private&#13;
   * @param {Object} [filler] Options object&#13;
   * @param {String} [property] property to set the Pattern to&#13;
   * @param {Function} [callback] callback to invoke after pattern load&#13;
   */&#13;
  _initPattern: function(filler, property, callback) {&#13;
    if (filler &amp;&amp; filler.source &amp;&amp; !(filler instanceof fabric.Pattern)) {&#13;
      this.set(property, new fabric.Pattern(filler, callback));&#13;
    }&#13;
    else {&#13;
      callback &amp;&amp; callback();&#13;
    }&#13;
  },&#13;
&#13;
  /**&#13;
   * @private&#13;
   * @param {Object} [options] Options object&#13;
   */&#13;
  _initClipping: function(options) {&#13;
    if (!options.clipTo || typeof options.clipTo !== 'string') {&#13;
      return;&#13;
    }&#13;
&#13;
    var functionBody = fabric.util.getFunctionBody(options.clipTo);&#13;
    if (typeof functionBody !== 'undefined') {&#13;
      this.clipTo = new Function('ctx', functionBody);&#13;
    }&#13;
  },&#13;
&#13;
  /**&#13;
   * @private&#13;
   */&#13;
  _setObject: function(obj) {&#13;
    for (var prop in obj) {&#13;
      this._set(prop, obj[prop]);&#13;
    }&#13;
  },&#13;
&#13;
  /**&#13;
   * Sets property to a given value. When changing position/dimension -related properties (left, top, scale, angle, etc.) `set` does not update position of object's borders/controls. If you need to update those, call `setCoords()`.&#13;
   * @param {String|Object} key Property name or object (if object, iterate over the object properties)&#13;
   * @param {Object|Function} value Property value (if function, the value is passed into it and its return value is used as a new one)&#13;
   * @return {fabric.Object} thisArg&#13;
   * @chainable&#13;
   */&#13;
  set: function(key, value) {&#13;
    if (typeof key === 'object') {&#13;
      this._setObject(key);&#13;
    }&#13;
    else {&#13;
      if (typeof value === 'function' &amp;&amp; key !== 'clipTo') {&#13;
        this._set(key, value(this.get(key)));&#13;
      }&#13;
      else {&#13;
        this._set(key, value);&#13;
      }&#13;
    }&#13;
    return this;&#13;
  },&#13;
&#13;
  _set: function(key, value) {&#13;
    this[key] = value;&#13;
  },&#13;
&#13;
  /**&#13;
   * Toggles specified property from `true` to `false` or from `false` to `true`&#13;
   * @param {String} property Property to toggle&#13;
   * @return {fabric.Object} thisArg&#13;
   * @chainable&#13;
   */&#13;
  toggle: function(property) {&#13;
    var value = this.get(property);&#13;
    if (typeof value === 'boolean') {&#13;
      this.set(property, !value);&#13;
    }&#13;
    return this;&#13;
  },&#13;
&#13;
  /**&#13;
   * Basic getter&#13;
   * @param {String} property Property name&#13;
   * @return {*} value of a property&#13;
   */&#13;
  get: function(property) {&#13;
    return this[property];&#13;
  }&#13;
};&#13;
&#13;
&#13;
(function(global) {&#13;
&#13;
  var sqrt = Math.sqrt,&#13;
      atan2 = Math.atan2,&#13;
      pow = Math.pow,&#13;
      abs = Math.abs,&#13;
      PiBy180 = Math.PI / 180;&#13;
&#13;
  /**&#13;
   * @namespace fabric.util&#13;
   */&#13;
  fabric.util = {&#13;
&#13;
    /**&#13;
     * Removes value from an array.&#13;
     * Presence of value (and its position in an array) is determined via `Array.prototype.indexOf`&#13;
     * @static&#13;
     * @memberOf fabric.util&#13;
     * @param {Array} array&#13;
     * @param {*} value&#13;
     * @return {Array} original array&#13;
     */&#13;
    removeFromArray: function(array, value) {&#13;
      var idx = array.indexOf(value);&#13;
      if (idx !== -1) {&#13;
        array.splice(idx, 1);&#13;
      }&#13;
      return array;&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns random number between 2 specified ones.&#13;
     * @static&#13;
     * @memberOf fabric.util&#13;
     * @param {Number} min lower limit&#13;
     * @param {Number} max upper limit&#13;
     * @return {Number} random value (between min and max)&#13;
     */&#13;
    getRandomInt: function(min, max) {&#13;
      return Math.floor(Math.random() * (max - min + 1)) + min;&#13;
    },&#13;
&#13;
    /**&#13;
     * Transforms degrees to radians.&#13;
     * @static&#13;
     * @memberOf fabric.util&#13;
     * @param {Number} degrees value in degrees&#13;
     * @return {Number} value in radians&#13;
     */&#13;
    degreesToRadians: function(degrees) {&#13;
      return degrees * PiBy180;&#13;
    },&#13;
&#13;
    /**&#13;
     * Transforms radians to degrees.&#13;
     * @static&#13;
     * @memberOf fabric.util&#13;
     * @param {Number} radians value in radians&#13;
     * @return {Number} value in degrees&#13;
     */&#13;
    radiansToDegrees: function(radians) {&#13;
      return radians / PiBy180;&#13;
    },&#13;
&#13;
    /**&#13;
     * Rotates `point` around `origin` with `radians`&#13;
     * @static&#13;
     * @memberOf fabric.util&#13;
     * @param {fabric.Point} point The point to rotate&#13;
     * @param {fabric.Point} origin The origin of the rotation&#13;
     * @param {Number} radians The radians of the angle for the rotation&#13;
     * @return {fabric.Point} The new rotated point&#13;
     */&#13;
    rotatePoint: function(point, origin, radians) {&#13;
      point.subtractEquals(origin);&#13;
      var v = fabric.util.rotateVector(point, radians);&#13;
      return new fabric.Point(v.x, v.y).addEquals(origin);&#13;
    },&#13;
&#13;
    /**&#13;
     * Rotates `vector` with `radians`&#13;
     * @static&#13;
     * @memberOf fabric.util&#13;
     * @param {Object} vector The vector to rotate (x and y)&#13;
     * @param {Number} radians The radians of the angle for the rotation&#13;
     * @return {Object} The new rotated point&#13;
     */&#13;
    rotateVector: function(vector, radians) {&#13;
      var sin = Math.sin(radians),&#13;
          cos = Math.cos(radians),&#13;
          rx = vector.x * cos - vector.y * sin,&#13;
          ry = vector.x * sin + vector.y * cos;&#13;
      return {&#13;
        x: rx,&#13;
        y: ry&#13;
      };&#13;
    },&#13;
&#13;
    /**&#13;
     * Apply transform t to point p&#13;
     * @static&#13;
     * @memberOf fabric.util&#13;
     * @param  {fabric.Point} p The point to transform&#13;
     * @param  {Array} t The transform&#13;
     * @param  {Boolean} [ignoreOffset] Indicates that the offset should not be applied&#13;
     * @return {fabric.Point} The transformed point&#13;
     */&#13;
    transformPoint: function(p, t, ignoreOffset) {&#13;
      if (ignoreOffset) {&#13;
        return new fabric.Point(&#13;
          t[0] * p.x + t[2] * p.y,&#13;
          t[1] * p.x + t[3] * p.y&#13;
        );&#13;
      }&#13;
      return new fabric.Point(&#13;
        t[0] * p.x + t[2] * p.y + t[4],&#13;
        t[1] * p.x + t[3] * p.y + t[5]&#13;
      );&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns coordinates of points's bounding rectangle (left, top, width, height)&#13;
     * @param {Array} points 4 points array&#13;
     * @return {Object} Object with left, top, width, height properties&#13;
     */&#13;
    makeBoundingBoxFromPoints: function(points) {&#13;
      var xPoints = [points[0].x, points[1].x, points[2].x, points[3].x],&#13;
          minX = fabric.util.array.min(xPoints),&#13;
          maxX = fabric.util.array.max(xPoints),&#13;
          width = maxX - minX,&#13;
          yPoints = [points[0].y, points[1].y, points[2].y, points[3].y],&#13;
          minY = fabric.util.array.min(yPoints),&#13;
          maxY = fabric.util.array.max(yPoints),&#13;
          height = maxY - minY;&#13;
&#13;
      return {&#13;
        left: minX,&#13;
        top: minY,&#13;
        width: width,&#13;
        height: height&#13;
      };&#13;
    },&#13;
&#13;
    /**&#13;
     * Invert transformation t&#13;
     * @static&#13;
     * @memberOf fabric.util&#13;
     * @param {Array} t The transform&#13;
     * @return {Array} The inverted transform&#13;
     */&#13;
    invertTransform: function(t) {&#13;
      var a = 1 / (t[0] * t[3] - t[1] * t[2]),&#13;
          r = [a * t[3], -a * t[1], -a * t[2], a * t[0]],&#13;
          o = fabric.util.transformPoint({ x: t[4], y: t[5] }, r, true);&#13;
      r[4] = -o.x;&#13;
      r[5] = -o.y;&#13;
      return r;&#13;
    },&#13;
&#13;
    /**&#13;
     * A wrapper around Number#toFixed, which contrary to native method returns number, not string.&#13;
     * @static&#13;
     * @memberOf fabric.util&#13;
     * @param {Number|String} number number to operate on&#13;
     * @param {Number} fractionDigits number of fraction digits to "leave"&#13;
     * @return {Number}&#13;
     */&#13;
    toFixed: function(number, fractionDigits) {&#13;
      return parseFloat(Number(number).toFixed(fractionDigits));&#13;
    },&#13;
&#13;
    /**&#13;
     * Converts from attribute value to pixel value if applicable.&#13;
     * Returns converted pixels or original value not converted.&#13;
     * @param {Number|String} value number to operate on&#13;
     * @param {Number} fontSize&#13;
     * @return {Number|String}&#13;
     */&#13;
    parseUnit: function(value, fontSize) {&#13;
      var unit = /\D{0,2}$/.exec(value),&#13;
          number = parseFloat(value);&#13;
      if (!fontSize) {&#13;
        fontSize = fabric.Text.DEFAULT_SVG_FONT_SIZE;&#13;
      }&#13;
      switch (unit[0]) {&#13;
        case 'mm':&#13;
          return number * fabric.DPI / 25.4;&#13;
&#13;
        case 'cm':&#13;
          return number * fabric.DPI / 2.54;&#13;
&#13;
        case 'in':&#13;
          return number * fabric.DPI;&#13;
&#13;
        case 'pt':&#13;
          return number * fabric.DPI / 72; // or * 4 / 3&#13;
&#13;
        case 'pc':&#13;
          return number * fabric.DPI / 72 * 12; // or * 16&#13;
&#13;
        case 'em':&#13;
          return number * fontSize;&#13;
&#13;
        default:&#13;
          return number;&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Function which always returns `false`.&#13;
     * @static&#13;
     * @memberOf fabric.util&#13;
     * @return {Boolean}&#13;
     */&#13;
    falseFunction: function() {&#13;
      return false;&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns klass "Class" object of given namespace&#13;
     * @memberOf fabric.util&#13;
     * @param {String} type Type of object (eg. 'circle')&#13;
     * @param {String} namespace Namespace to get klass "Class" object from&#13;
     * @return {Object} klass "Class"&#13;
     */&#13;
    getKlass: function(type, namespace) {&#13;
      // capitalize first letter only&#13;
      type = fabric.util.string.camelize(type.charAt(0).toUpperCase() + type.slice(1));&#13;
      return fabric.util.resolveNamespace(namespace)[type];&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns array of attributes for given svg that fabric parses&#13;
     * @memberOf fabric.util&#13;
     * @param {String} type Type of svg element (eg. 'circle')&#13;
     * @return {Array} string names of supported attributes&#13;
     */&#13;
    getSvgAttributes: function(type) {&#13;
      var attributes = [&#13;
        'instantiated_by_use',&#13;
        'style',&#13;
        'id',&#13;
        'class'&#13;
      ];&#13;
      switch (type) {&#13;
        case 'linearGradient':&#13;
          attributes = attributes.concat(['x1', 'y1', 'x2', 'y2', 'gradientUnits', 'gradientTransform']);&#13;
          break;&#13;
        case 'radialGradient':&#13;
          attributes = attributes.concat(['gradientUnits', 'gradientTransform', 'cx', 'cy', 'r', 'fx', 'fy', 'fr']);&#13;
          break;&#13;
        case 'stop':&#13;
          attributes = attributes.concat(['offset', 'stop-color', 'stop-opacity']);&#13;
          break;&#13;
      }&#13;
      return attributes;&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns object of given namespace&#13;
     * @memberOf fabric.util&#13;
     * @param {String} namespace Namespace string e.g. 'fabric.Image.filter' or 'fabric'&#13;
     * @return {Object} Object for given namespace (default fabric)&#13;
     */&#13;
    resolveNamespace: function(namespace) {&#13;
      if (!namespace) {&#13;
        return fabric;&#13;
      }&#13;
&#13;
      var parts = namespace.split('.'),&#13;
          len = parts.length, i,&#13;
          obj = global || fabric.window;&#13;
&#13;
      for (i = 0; i &lt; len; ++i) {&#13;
        obj = obj[parts[i]];&#13;
      }&#13;
&#13;
      return obj;&#13;
    },&#13;
&#13;
    /**&#13;
     * Loads image element from given url and passes it to a callback&#13;
     * @memberOf fabric.util&#13;
     * @param {String} url URL representing an image&#13;
     * @param {Function} callback Callback; invoked with loaded image&#13;
     * @param {*} [context] Context to invoke callback in&#13;
     * @param {Object} [crossOrigin] crossOrigin value to set image element to&#13;
     */&#13;
    loadImage: function(url, callback, context, crossOrigin) {&#13;
      if (!url) {&#13;
        callback &amp;&amp; callback.call(context, url);&#13;
        return;&#13;
      }&#13;
&#13;
      var img = fabric.util.createImage();&#13;
&#13;
      /** @ignore */&#13;
      var onLoadCallback = function () {&#13;
        callback &amp;&amp; callback.call(context, img);&#13;
        img = img.onload = img.onerror = null;&#13;
      };&#13;
&#13;
      img.onload = onLoadCallback;&#13;
      /** @ignore */&#13;
      img.onerror = function() {&#13;
        fabric.log('Error loading ' + img.src);&#13;
        callback &amp;&amp; callback.call(context, null, true);&#13;
        img = img.onload = img.onerror = null;&#13;
      };&#13;
&#13;
      // data-urls appear to be buggy with crossOrigin&#13;
      // https://github.com/kangax/fabric.js/commit/d0abb90f1cd5c5ef9d2a94d3fb21a22330da3e0a#commitcomment-4513767&#13;
      // see https://code.google.com/p/chromium/issues/detail?id=315152&#13;
      //     https://bugzilla.mozilla.org/show_bug.cgi?id=935069&#13;
      if (url.indexOf('data') !== 0 &amp;&amp; crossOrigin) {&#13;
        img.crossOrigin = crossOrigin;&#13;
      }&#13;
&#13;
      // IE10 / IE11-Fix: SVG contents from data: URI&#13;
      // will only be available if the IMG is present&#13;
      // in the DOM (and visible)&#13;
      if (url.substring(0,14) === 'data:image/svg') {&#13;
        img.onload = null;&#13;
        fabric.util.loadImageInDom(img, onLoadCallback);&#13;
      }&#13;
&#13;
      img.src = url;&#13;
    },&#13;
&#13;
    /**&#13;
     * Attaches SVG image with data: URL to the dom&#13;
     * @memberOf fabric.util&#13;
     * @param {Object} img Image object with data:image/svg src&#13;
     * @param {Function} callback Callback; invoked with loaded image&#13;
     * @return {Object} DOM element (div containing the SVG image)&#13;
     */&#13;
    loadImageInDom: function(img, onLoadCallback) {&#13;
      var div = fabric.document.createElement('div');&#13;
      div.style.width = div.style.height = '1px';&#13;
      div.style.left = div.style.top = '-100%';&#13;
      div.style.position = 'absolute';&#13;
      div.appendChild(img);&#13;
      fabric.document.querySelector('body').appendChild(div);&#13;
      /**&#13;
       * Wrap in function to:&#13;
       *   1. Call existing callback&#13;
       *   2. Cleanup DOM&#13;
       */&#13;
      img.onload = function () {&#13;
        onLoadCallback();&#13;
        div.parentNode.removeChild(div);&#13;
        div = null;&#13;
      };&#13;
    },&#13;
&#13;
    /**&#13;
     * Creates corresponding fabric instances from their object representations&#13;
     * @static&#13;
     * @memberOf fabric.util&#13;
     * @param {Array} objects Objects to enliven&#13;
     * @param {Function} callback Callback to invoke when all objects are created&#13;
     * @param {String} namespace Namespace to get klass "Class" object from&#13;
     * @param {Function} reviver Method for further parsing of object elements,&#13;
     * called after each fabric object created.&#13;
     */&#13;
    enlivenObjects: function(objects, callback, namespace, reviver) {&#13;
      objects = objects || [];&#13;
&#13;
      function onLoaded() {&#13;
        if (++numLoadedObjects === numTotalObjects) {&#13;
          callback &amp;&amp; callback(enlivenedObjects);&#13;
        }&#13;
      }&#13;
&#13;
      var enlivenedObjects = [],&#13;
          numLoadedObjects = 0,&#13;
          numTotalObjects = objects.length;&#13;
&#13;
      if (!numTotalObjects) {&#13;
        callback &amp;&amp; callback(enlivenedObjects);&#13;
        return;&#13;
      }&#13;
&#13;
      objects.forEach(function (o, index) {&#13;
        // if sparse array&#13;
        if (!o || !o.type) {&#13;
          onLoaded();&#13;
          return;&#13;
        }&#13;
        var klass = fabric.util.getKlass(o.type, namespace);&#13;
        klass.fromObject(o, function (obj, error) {&#13;
          error || (enlivenedObjects[index] = obj);&#13;
          reviver &amp;&amp; reviver(o, obj, error);&#13;
          onLoaded();&#13;
        });&#13;
      });&#13;
    },&#13;
&#13;
    /**&#13;
     * Create and wait for loading of patterns&#13;
     * @static&#13;
     * @memberOf fabric.util&#13;
     * @param {Array} patterns Objects to enliven&#13;
     * @param {Function} callback Callback to invoke when all objects are created&#13;
     * called after each fabric object created.&#13;
     */&#13;
    enlivenPatterns: function(patterns, callback) {&#13;
      patterns = patterns || [];&#13;
&#13;
      function onLoaded() {&#13;
        if (++numLoadedPatterns === numPatterns) {&#13;
          callback &amp;&amp; callback(enlivenedPatterns);&#13;
        }&#13;
      }&#13;
&#13;
      var enlivenedPatterns = [],&#13;
          numLoadedPatterns = 0,&#13;
          numPatterns = patterns.length;&#13;
&#13;
      if (!numPatterns) {&#13;
        callback &amp;&amp; callback(enlivenedPatterns);&#13;
        return;&#13;
      }&#13;
&#13;
      patterns.forEach(function (p, index) {&#13;
        if (p &amp;&amp; p.source) {&#13;
          new fabric.Pattern(p, function(pattern) {&#13;
            enlivenedPatterns[index] = pattern;&#13;
            onLoaded();&#13;
          });&#13;
        }&#13;
        else {&#13;
          enlivenedPatterns[index] = p;&#13;
          onLoaded();&#13;
        }&#13;
      });&#13;
    },&#13;
&#13;
    /**&#13;
     * Groups SVG elements (usually those retrieved from SVG document)&#13;
     * @static&#13;
     * @memberOf fabric.util&#13;
     * @param {Array} elements SVG elements to group&#13;
     * @param {Object} [options] Options object&#13;
     * @param {String} path Value to set sourcePath to&#13;
     * @return {fabric.Object|fabric.Group}&#13;
     */&#13;
    groupSVGElements: function(elements, options, path) {&#13;
      var object;&#13;
      if (elements.length === 1) {&#13;
        return elements[0];&#13;
      }&#13;
      if (options) {&#13;
        if (options.width &amp;&amp; options.height) {&#13;
          options.centerPoint = {&#13;
            x: options.width / 2,&#13;
            y: options.height / 2&#13;
          };&#13;
        }&#13;
        else {&#13;
          delete options.width;&#13;
          delete options.height;&#13;
        }&#13;
      }&#13;
      object = new fabric.Group(elements, options);&#13;
      if (typeof path !== 'undefined') {&#13;
        object.sourcePath = path;&#13;
      }&#13;
      return object;&#13;
    },&#13;
&#13;
    /**&#13;
     * Populates an object with properties of another object&#13;
     * @static&#13;
     * @memberOf fabric.util&#13;
     * @param {Object} source Source object&#13;
     * @param {Object} destination Destination object&#13;
     * @return {Array} properties Properties names to include&#13;
     */&#13;
    populateWithProperties: function(source, destination, properties) {&#13;
      if (properties &amp;&amp; Object.prototype.toString.call(properties) === '[object Array]') {&#13;
        for (var i = 0, len = properties.length; i &lt; len; i++) {&#13;
          if (properties[i] in source) {&#13;
            destination[properties[i]] = source[properties[i]];&#13;
          }&#13;
        }&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Draws a dashed line between two points&#13;
     *&#13;
     * This method is used to draw dashed line around selection area.&#13;
     * See &lt;a href="http://stackoverflow.com/questions/4576724/dotted-stroke-in-canvas"&gt;dotted stroke in canvas&lt;/a&gt;&#13;
     *&#13;
     * @param {CanvasRenderingContext2D} ctx context&#13;
     * @param {Number} x  start x coordinate&#13;
     * @param {Number} y start y coordinate&#13;
     * @param {Number} x2 end x coordinate&#13;
     * @param {Number} y2 end y coordinate&#13;
     * @param {Array} da dash array pattern&#13;
     */&#13;
    drawDashedLine: function(ctx, x, y, x2, y2, da) {&#13;
      var dx = x2 - x,&#13;
          dy = y2 - y,&#13;
          len = sqrt(dx * dx + dy * dy),&#13;
          rot = atan2(dy, dx),&#13;
          dc = da.length,&#13;
          di = 0,&#13;
          draw = true;&#13;
&#13;
      ctx.save();&#13;
      ctx.translate(x, y);&#13;
      ctx.moveTo(0, 0);&#13;
      ctx.rotate(rot);&#13;
&#13;
      x = 0;&#13;
      while (len &gt; x) {&#13;
        x += da[di++ % dc];&#13;
        if (x &gt; len) {&#13;
          x = len;&#13;
        }&#13;
        ctx[draw ? 'lineTo' : 'moveTo'](x, 0);&#13;
        draw = !draw;&#13;
      }&#13;
&#13;
      ctx.restore();&#13;
    },&#13;
&#13;
    /**&#13;
     * Creates canvas element&#13;
     * @static&#13;
     * @memberOf fabric.util&#13;
     * @return {CanvasElement} initialized canvas element&#13;
     */&#13;
    createCanvasElement: function() {&#13;
      return fabric.document.createElement('canvas');&#13;
    },&#13;
&#13;
    /**&#13;
     * Creates image element (works on client and node)&#13;
     * @static&#13;
     * @memberOf fabric.util&#13;
     * @return {HTMLImageElement} HTML image element&#13;
     */&#13;
    createImage: function() {&#13;
      return fabric.document.createElement('img');&#13;
    },&#13;
&#13;
    /**&#13;
     * @static&#13;
     * @memberOf fabric.util&#13;
     * @deprecated since 2.0.0&#13;
     * @param {fabric.Object} receiver Object implementing `clipTo` method&#13;
     * @param {CanvasRenderingContext2D} ctx Context to clip&#13;
     */&#13;
    clipContext: function(receiver, ctx) {&#13;
      ctx.save();&#13;
      ctx.beginPath();&#13;
      receiver.clipTo(ctx);&#13;
      ctx.clip();&#13;
    },&#13;
&#13;
    /**&#13;
     * Multiply matrix A by matrix B to nest transformations&#13;
     * @static&#13;
     * @memberOf fabric.util&#13;
     * @param  {Array} a First transformMatrix&#13;
     * @param  {Array} b Second transformMatrix&#13;
     * @param  {Boolean} is2x2 flag to multiply matrices as 2x2 matrices&#13;
     * @return {Array} The product of the two transform matrices&#13;
     */&#13;
    multiplyTransformMatrices: function(a, b, is2x2) {&#13;
      // Matrix multiply a * b&#13;
      return [&#13;
        a[0] * b[0] + a[2] * b[1],&#13;
        a[1] * b[0] + a[3] * b[1],&#13;
        a[0] * b[2] + a[2] * b[3],&#13;
        a[1] * b[2] + a[3] * b[3],&#13;
        is2x2 ? 0 : a[0] * b[4] + a[2] * b[5] + a[4],&#13;
        is2x2 ? 0 : a[1] * b[4] + a[3] * b[5] + a[5]&#13;
      ];&#13;
    },&#13;
&#13;
    /**&#13;
     * Decomposes standard 2x2 matrix into transform componentes&#13;
     * @static&#13;
     * @memberOf fabric.util&#13;
     * @param  {Array} a transformMatrix&#13;
     * @return {Object} Components of transform&#13;
     */&#13;
    qrDecompose: function(a) {&#13;
      var angle = atan2(a[1], a[0]),&#13;
          denom = pow(a[0], 2) + pow(a[1], 2),&#13;
          scaleX = sqrt(denom),&#13;
          scaleY = (a[0] * a[3] - a[2] * a [1]) / scaleX,&#13;
          skewX = atan2(a[0] * a[2] + a[1] * a [3], denom);&#13;
      return {&#13;
        angle: angle  / PiBy180,&#13;
        scaleX: scaleX,&#13;
        scaleY: scaleY,&#13;
        skewX: skewX / PiBy180,&#13;
        skewY: 0,&#13;
        translateX: a[4],&#13;
        translateY: a[5]&#13;
      };&#13;
    },&#13;
&#13;
    customTransformMatrix: function(scaleX, scaleY, skewX) {&#13;
      var skewMatrixX = [1, 0, abs(Math.tan(skewX * PiBy180)), 1],&#13;
          scaleMatrix = [abs(scaleX), 0, 0, abs(scaleY)];&#13;
      return fabric.util.multiplyTransformMatrices(scaleMatrix, skewMatrixX, true);&#13;
    },&#13;
&#13;
    resetObjectTransform: function (target) {&#13;
      target.scaleX = 1;&#13;
      target.scaleY = 1;&#13;
      target.skewX = 0;&#13;
      target.skewY = 0;&#13;
      target.flipX = false;&#13;
      target.flipY = false;&#13;
      target.rotate(0);&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns string representation of function body&#13;
     * @param {Function} fn Function to get body of&#13;
     * @return {String} Function body&#13;
     */&#13;
    getFunctionBody: function(fn) {&#13;
      return (String(fn).match(/function[^{]*\{([\s\S]*)\}/) || {})[1];&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns true if context has transparent pixel&#13;
     * at specified location (taking tolerance into account)&#13;
     * @param {CanvasRenderingContext2D} ctx context&#13;
     * @param {Number} x x coordinate&#13;
     * @param {Number} y y coordinate&#13;
     * @param {Number} tolerance Tolerance&#13;
     */&#13;
    isTransparent: function(ctx, x, y, tolerance) {&#13;
&#13;
      // If tolerance is &gt; 0 adjust start coords to take into account.&#13;
      // If moves off Canvas fix to 0&#13;
      if (tolerance &gt; 0) {&#13;
        if (x &gt; tolerance) {&#13;
          x -= tolerance;&#13;
        }&#13;
        else {&#13;
          x = 0;&#13;
        }&#13;
        if (y &gt; tolerance) {&#13;
          y -= tolerance;&#13;
        }&#13;
        else {&#13;
          y = 0;&#13;
        }&#13;
      }&#13;
&#13;
      var _isTransparent = true, i, temp,&#13;
          imageData = ctx.getImageData(x, y, (tolerance * 2) || 1, (tolerance * 2) || 1),&#13;
          l = imageData.data.length;&#13;
&#13;
      // Split image data - for tolerance &gt; 1, pixelDataSize = 4;&#13;
      for (i = 3; i &lt; l; i += 4) {&#13;
        temp = imageData.data[i];&#13;
        _isTransparent = temp &lt;= 0;&#13;
        if (_isTransparent === false) {&#13;
          break; // Stop if colour found&#13;
        }&#13;
      }&#13;
&#13;
      imageData = null;&#13;
&#13;
      return _isTransparent;&#13;
    },&#13;
&#13;
    /**&#13;
     * Parse preserveAspectRatio attribute from element&#13;
     * @param {string} attribute to be parsed&#13;
     * @return {Object} an object containing align and meetOrSlice attribute&#13;
     */&#13;
    parsePreserveAspectRatioAttribute: function(attribute) {&#13;
      var meetOrSlice = 'meet', alignX = 'Mid', alignY = 'Mid',&#13;
          aspectRatioAttrs = attribute.split(' '), align;&#13;
&#13;
      if (aspectRatioAttrs &amp;&amp; aspectRatioAttrs.length) {&#13;
        meetOrSlice = aspectRatioAttrs.pop();&#13;
        if (meetOrSlice !== 'meet' &amp;&amp; meetOrSlice !== 'slice') {&#13;
          align = meetOrSlice;&#13;
          meetOrSlice = 'meet';&#13;
        }&#13;
        else if (aspectRatioAttrs.length) {&#13;
          align = aspectRatioAttrs.pop();&#13;
        }&#13;
      }&#13;
      //divide align in alignX and alignY&#13;
      alignX = align !== 'none' ? align.slice(1, 4) : 'none';&#13;
      alignY = align !== 'none' ? align.slice(5, 8) : 'none';&#13;
      return {&#13;
        meetOrSlice: meetOrSlice,&#13;
        alignX: alignX,&#13;
        alignY: alignY&#13;
      };&#13;
    },&#13;
&#13;
    /**&#13;
     * Clear char widths cache for a font family.&#13;
     * @memberOf fabric.util&#13;
     * @param {String} [fontFamily] font family to clear&#13;
     */&#13;
    clearFabricFontCache: function(fontFamily) {&#13;
      if (!fontFamily) {&#13;
        fabric.charWidthsCache = { };&#13;
      }&#13;
      else if (fabric.charWidthsCache[fontFamily]) {&#13;
        delete fabric.charWidthsCache[fontFamily];&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Clear char widths cache for a font family.&#13;
     * @memberOf fabric.util&#13;
     * @param {Number} ar aspect ratio&#13;
     * @param {Number} maximumArea Maximum area you want to achieve&#13;
     * @return {Object.x} Limited dimensions by X&#13;
     * @return {Object.y} Limited dimensions by Y&#13;
     */&#13;
    limitDimsByArea: function(ar, maximumArea) {&#13;
      var roughWidth = Math.sqrt(maximumArea * ar),&#13;
          perfLimitSizeY = Math.floor(maximumArea / roughWidth);&#13;
      return { x: Math.floor(roughWidth), y: perfLimitSizeY };&#13;
    },&#13;
&#13;
    capValue: function(min, value, max) {&#13;
      return Math.max(min, Math.min(value, max));&#13;
    },&#13;
&#13;
    findScaleToFit: function(source, destination) {&#13;
      return Math.min(destination.width / source.width, destination.height / source.height);&#13;
    },&#13;
&#13;
    findScaleToCover: function(source, destination) {&#13;
      return Math.max(destination.width / source.width, destination.height / source.height);&#13;
    }&#13;
  };&#13;
})(typeof exports !== 'undefined' ? exports : this);&#13;
&#13;
&#13;
(function() {&#13;
&#13;
  var arcToSegmentsCache = { },&#13;
      segmentToBezierCache = { },&#13;
      boundsOfCurveCache = { },&#13;
      _join = Array.prototype.join;&#13;
&#13;
  /* Adapted from http://dxr.mozilla.org/mozilla-central/source/content/svg/content/src/nsSVGPathDataParser.cpp&#13;
   * by Andrea Bogazzi code is under MPL. if you don't have a copy of the license you can take it here&#13;
   * http://mozilla.org/MPL/2.0/&#13;
   */&#13;
  function arcToSegments(toX, toY, rx, ry, large, sweep, rotateX) {&#13;
    var argsString = _join.call(arguments);&#13;
    if (arcToSegmentsCache[argsString]) {&#13;
      return arcToSegmentsCache[argsString];&#13;
    }&#13;
&#13;
    var PI = Math.PI, th = rotateX * PI / 180,&#13;
        sinTh = Math.sin(th),&#13;
        cosTh = Math.cos(th),&#13;
        fromX = 0, fromY = 0;&#13;
&#13;
    rx = Math.abs(rx);&#13;
    ry = Math.abs(ry);&#13;
&#13;
    var px = -cosTh * toX * 0.5 - sinTh * toY * 0.5,&#13;
        py = -cosTh * toY * 0.5 + sinTh * toX * 0.5,&#13;
        rx2 = rx * rx, ry2 = ry * ry, py2 = py * py, px2 = px * px,&#13;
        pl = rx2 * ry2 - rx2 * py2 - ry2 * px2,&#13;
        root = 0;&#13;
&#13;
    if (pl &lt; 0) {&#13;
      var s = Math.sqrt(1 - pl / (rx2 * ry2));&#13;
      rx *= s;&#13;
      ry *= s;&#13;
    }&#13;
    else {&#13;
      root = (large === sweep ? -1.0 : 1.0) *&#13;
              Math.sqrt( pl / (rx2 * py2 + ry2 * px2));&#13;
    }&#13;
&#13;
    var cx = root * rx * py / ry,&#13;
        cy = -root * ry * px / rx,&#13;
        cx1 = cosTh * cx - sinTh * cy + toX * 0.5,&#13;
        cy1 = sinTh * cx + cosTh * cy + toY * 0.5,&#13;
        mTheta = calcVectorAngle(1, 0, (px - cx) / rx, (py - cy) / ry),&#13;
        dtheta = calcVectorAngle((px - cx) / rx, (py - cy) / ry, (-px - cx) / rx, (-py - cy) / ry);&#13;
&#13;
    if (sweep === 0 &amp;&amp; dtheta &gt; 0) {&#13;
      dtheta -= 2 * PI;&#13;
    }&#13;
    else if (sweep === 1 &amp;&amp; dtheta &lt; 0) {&#13;
      dtheta += 2 * PI;&#13;
    }&#13;
&#13;
    // Convert into cubic bezier segments &lt;= 90deg&#13;
    var segments = Math.ceil(Math.abs(dtheta / PI * 2)),&#13;
        result = [], mDelta = dtheta / segments,&#13;
        mT = 8 / 3 * Math.sin(mDelta / 4) * Math.sin(mDelta / 4) / Math.sin(mDelta / 2),&#13;
        th3 = mTheta + mDelta;&#13;
&#13;
    for (var i = 0; i &lt; segments; i++) {&#13;
      result[i] = segmentToBezier(mTheta, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY);&#13;
      fromX = result[i][4];&#13;
      fromY = result[i][5];&#13;
      mTheta = th3;&#13;
      th3 += mDelta;&#13;
    }&#13;
    arcToSegmentsCache[argsString] = result;&#13;
    return result;&#13;
  }&#13;
&#13;
  function segmentToBezier(th2, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY) {&#13;
    var argsString2 = _join.call(arguments);&#13;
    if (segmentToBezierCache[argsString2]) {&#13;
      return segmentToBezierCache[argsString2];&#13;
    }&#13;
&#13;
    var costh2 = Math.cos(th2),&#13;
        sinth2 = Math.sin(th2),&#13;
        costh3 = Math.cos(th3),&#13;
        sinth3 = Math.sin(th3),&#13;
        toX = cosTh * rx * costh3 - sinTh * ry * sinth3 + cx1,&#13;
        toY = sinTh * rx * costh3 + cosTh * ry * sinth3 + cy1,&#13;
        cp1X = fromX + mT * ( -cosTh * rx * sinth2 - sinTh * ry * costh2),&#13;
        cp1Y = fromY + mT * ( -sinTh * rx * sinth2 + cosTh * ry * costh2),&#13;
        cp2X = toX + mT * ( cosTh * rx * sinth3 + sinTh * ry * costh3),&#13;
        cp2Y = toY + mT * ( sinTh * rx * sinth3 - cosTh * ry * costh3);&#13;
&#13;
    segmentToBezierCache[argsString2] = [&#13;
      cp1X, cp1Y,&#13;
      cp2X, cp2Y,&#13;
      toX, toY&#13;
    ];&#13;
    return segmentToBezierCache[argsString2];&#13;
  }&#13;
&#13;
  /*&#13;
   * Private&#13;
   */&#13;
  function calcVectorAngle(ux, uy, vx, vy) {&#13;
    var ta = Math.atan2(uy, ux),&#13;
        tb = Math.atan2(vy, vx);&#13;
    if (tb &gt;= ta) {&#13;
      return tb - ta;&#13;
    }&#13;
    else {&#13;
      return 2 * Math.PI - (ta - tb);&#13;
    }&#13;
  }&#13;
&#13;
  /**&#13;
   * Draws arc&#13;
   * @param {CanvasRenderingContext2D} ctx&#13;
   * @param {Number} fx&#13;
   * @param {Number} fy&#13;
   * @param {Array} coords&#13;
   */&#13;
  fabric.util.drawArc = function(ctx, fx, fy, coords) {&#13;
    var rx = coords[0],&#13;
        ry = coords[1],&#13;
        rot = coords[2],&#13;
        large = coords[3],&#13;
        sweep = coords[4],&#13;
        tx = coords[5],&#13;
        ty = coords[6],&#13;
        segs = [[], [], [], []],&#13;
        segsNorm = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);&#13;
&#13;
    for (var i = 0, len = segsNorm.length; i &lt; len; i++) {&#13;
      segs[i][0] = segsNorm[i][0] + fx;&#13;
      segs[i][1] = segsNorm[i][1] + fy;&#13;
      segs[i][2] = segsNorm[i][2] + fx;&#13;
      segs[i][3] = segsNorm[i][3] + fy;&#13;
      segs[i][4] = segsNorm[i][4] + fx;&#13;
      segs[i][5] = segsNorm[i][5] + fy;&#13;
      ctx.bezierCurveTo.apply(ctx, segs[i]);&#13;
    }&#13;
  };&#13;
&#13;
  /**&#13;
   * Calculate bounding box of a elliptic-arc&#13;
   * @param {Number} fx start point of arc&#13;
   * @param {Number} fy&#13;
   * @param {Number} rx horizontal radius&#13;
   * @param {Number} ry vertical radius&#13;
   * @param {Number} rot angle of horizontal axe&#13;
   * @param {Number} large 1 or 0, whatever the arc is the big or the small on the 2 points&#13;
   * @param {Number} sweep 1 or 0, 1 clockwise or counterclockwise direction&#13;
   * @param {Number} tx end point of arc&#13;
   * @param {Number} ty&#13;
   */&#13;
  fabric.util.getBoundsOfArc = function(fx, fy, rx, ry, rot, large, sweep, tx, ty) {&#13;
&#13;
    var fromX = 0, fromY = 0, bound, bounds = [],&#13;
        segs = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);&#13;
&#13;
    for (var i = 0, len = segs.length; i &lt; len; i++) {&#13;
      bound = getBoundsOfCurve(fromX, fromY, segs[i][0], segs[i][1], segs[i][2], segs[i][3], segs[i][4], segs[i][5]);&#13;
      bounds.push({ x: bound[0].x + fx, y: bound[0].y + fy });&#13;
      bounds.push({ x: bound[1].x + fx, y: bound[1].y + fy });&#13;
      fromX = segs[i][4];&#13;
      fromY = segs[i][5];&#13;
    }&#13;
    return bounds;&#13;
  };&#13;
&#13;
  /**&#13;
   * Calculate bounding box of a beziercurve&#13;
   * @param {Number} x0 starting point&#13;
   * @param {Number} y0&#13;
   * @param {Number} x1 first control point&#13;
   * @param {Number} y1&#13;
   * @param {Number} x2 secondo control point&#13;
   * @param {Number} y2&#13;
   * @param {Number} x3 end of beizer&#13;
   * @param {Number} y3&#13;
   */&#13;
  // taken from http://jsbin.com/ivomiq/56/edit  no credits available for that.&#13;
  function getBoundsOfCurve(x0, y0, x1, y1, x2, y2, x3, y3) {&#13;
    var argsString = _join.call(arguments);&#13;
    if (boundsOfCurveCache[argsString]) {&#13;
      return boundsOfCurveCache[argsString];&#13;
    }&#13;
&#13;
    var sqrt = Math.sqrt,&#13;
        min = Math.min, max = Math.max,&#13;
        abs = Math.abs, tvalues = [],&#13;
        bounds = [[], []],&#13;
        a, b, c, t, t1, t2, b2ac, sqrtb2ac;&#13;
&#13;
    b = 6 * x0 - 12 * x1 + 6 * x2;&#13;
    a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;&#13;
    c = 3 * x1 - 3 * x0;&#13;
&#13;
    for (var i = 0; i &lt; 2; ++i) {&#13;
      if (i &gt; 0) {&#13;
        b = 6 * y0 - 12 * y1 + 6 * y2;&#13;
        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;&#13;
        c = 3 * y1 - 3 * y0;&#13;
      }&#13;
&#13;
      if (abs(a) &lt; 1e-12) {&#13;
        if (abs(b) &lt; 1e-12) {&#13;
          continue;&#13;
        }&#13;
        t = -c / b;&#13;
        if (0 &lt; t &amp;&amp; t &lt; 1) {&#13;
          tvalues.push(t);&#13;
        }&#13;
        continue;&#13;
      }&#13;
      b2ac = b * b - 4 * c * a;&#13;
      if (b2ac &lt; 0) {&#13;
        continue;&#13;
      }&#13;
      sqrtb2ac = sqrt(b2ac);&#13;
      t1 = (-b + sqrtb2ac) / (2 * a);&#13;
      if (0 &lt; t1 &amp;&amp; t1 &lt; 1) {&#13;
        tvalues.push(t1);&#13;
      }&#13;
      t2 = (-b - sqrtb2ac) / (2 * a);&#13;
      if (0 &lt; t2 &amp;&amp; t2 &lt; 1) {&#13;
        tvalues.push(t2);&#13;
      }&#13;
    }&#13;
&#13;
    var x, y, j = tvalues.length, jlen = j, mt;&#13;
    while (j--) {&#13;
      t = tvalues[j];&#13;
      mt = 1 - t;&#13;
      x = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);&#13;
      bounds[0][j] = x;&#13;
&#13;
      y = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);&#13;
      bounds[1][j] = y;&#13;
    }&#13;
&#13;
    bounds[0][jlen] = x0;&#13;
    bounds[1][jlen] = y0;&#13;
    bounds[0][jlen + 1] = x3;&#13;
    bounds[1][jlen + 1] = y3;&#13;
    var result = [&#13;
      {&#13;
        x: min.apply(null, bounds[0]),&#13;
        y: min.apply(null, bounds[1])&#13;
      },&#13;
      {&#13;
        x: max.apply(null, bounds[0]),&#13;
        y: max.apply(null, bounds[1])&#13;
      }&#13;
    ];&#13;
    boundsOfCurveCache[argsString] = result;&#13;
    return result;&#13;
  }&#13;
&#13;
  fabric.util.getBoundsOfCurve = getBoundsOfCurve;&#13;
&#13;
})();&#13;
&#13;
&#13;
(function() {&#13;
&#13;
  var slice = Array.prototype.slice;&#13;
&#13;
  /**&#13;
   * Invokes method on all items in a given array&#13;
   * @memberOf fabric.util.array&#13;
   * @param {Array} array Array to iterate over&#13;
   * @param {String} method Name of a method to invoke&#13;
   * @return {Array}&#13;
   */&#13;
  function invoke(array, method) {&#13;
    var args = slice.call(arguments, 2), result = [];&#13;
    for (var i = 0, len = array.length; i &lt; len; i++) {&#13;
      result[i] = args.length ? array[i][method].apply(array[i], args) : array[i][method].call(array[i]);&#13;
    }&#13;
    return result;&#13;
  }&#13;
&#13;
  /**&#13;
   * Finds maximum value in array (not necessarily "first" one)&#13;
   * @memberOf fabric.util.array&#13;
   * @param {Array} array Array to iterate over&#13;
   * @param {String} byProperty&#13;
   * @return {*}&#13;
   */&#13;
  function max(array, byProperty) {&#13;
    return find(array, byProperty, function(value1, value2) {&#13;
      return value1 &gt;= value2;&#13;
    });&#13;
  }&#13;
&#13;
  /**&#13;
   * Finds minimum value in array (not necessarily "first" one)&#13;
   * @memberOf fabric.util.array&#13;
   * @param {Array} array Array to iterate over&#13;
   * @param {String} byProperty&#13;
   * @return {*}&#13;
   */&#13;
  function min(array, byProperty) {&#13;
    return find(array, byProperty, function(value1, value2) {&#13;
      return value1 &lt; value2;&#13;
    });&#13;
  }&#13;
&#13;
  /**&#13;
   * @private&#13;
   */&#13;
  function fill(array, value) {&#13;
    var k = array.length;&#13;
    while (k--) {&#13;
      array[k] = value;&#13;
    }&#13;
    return array;&#13;
  }&#13;
&#13;
  /**&#13;
   * @private&#13;
   */&#13;
  function find(array, byProperty, condition) {&#13;
    if (!array || array.length === 0) {&#13;
      return;&#13;
    }&#13;
&#13;
    var i = array.length - 1,&#13;
        result = byProperty ? array[i][byProperty] : array[i];&#13;
    if (byProperty) {&#13;
      while (i--) {&#13;
        if (condition(array[i][byProperty], result)) {&#13;
          result = array[i][byProperty];&#13;
        }&#13;
      }&#13;
    }&#13;
    else {&#13;
      while (i--) {&#13;
        if (condition(array[i], result)) {&#13;
          result = array[i];&#13;
        }&#13;
      }&#13;
    }&#13;
    return result;&#13;
  }&#13;
&#13;
  /**&#13;
   * @namespace fabric.util.array&#13;
   */&#13;
  fabric.util.array = {&#13;
    fill: fill,&#13;
    invoke: invoke,&#13;
    min: min,&#13;
    max: max&#13;
  };&#13;
&#13;
})();&#13;
&#13;
&#13;
(function() {&#13;
  /**&#13;
   * Copies all enumerable properties of one js object to another&#13;
   * Does not clone or extend fabric.Object subclasses.&#13;
   * @memberOf fabric.util.object&#13;
   * @param {Object} destination Where to copy to&#13;
   * @param {Object} source Where to copy from&#13;
   * @return {Object}&#13;
   */&#13;
&#13;
  function extend(destination, source, deep) {&#13;
    // JScript DontEnum bug is not taken care of&#13;
    // the deep clone is for internal use, is not meant to avoid&#13;
    // javascript traps or cloning html element or self referenced objects.&#13;
    if (deep) {&#13;
      if (!fabric.isLikelyNode &amp;&amp; source instanceof Element) {&#13;
        // avoid cloning deep images, canvases,&#13;
        destination = source;&#13;
      }&#13;
      else if (source instanceof Array) {&#13;
        destination = [];&#13;
        for (var i = 0, len = source.length; i &lt; len; i++) {&#13;
          destination[i] = extend({ }, source[i], deep);&#13;
        }&#13;
      }&#13;
      else if (source &amp;&amp; typeof source === 'object') {&#13;
        for (var property in source) {&#13;
          if (source.hasOwnProperty(property)) {&#13;
            destination[property] = extend({ }, source[property], deep);&#13;
          }&#13;
        }&#13;
      }&#13;
      else {&#13;
        // this sounds odd for an extend but is ok for recursive use&#13;
        destination = source;&#13;
      }&#13;
    }&#13;
    else {&#13;
      for (var property in source) {&#13;
        destination[property] = source[property];&#13;
      }&#13;
    }&#13;
    return destination;&#13;
  }&#13;
&#13;
  /**&#13;
   * Creates an empty object and copies all enumerable properties of another object to it&#13;
   * @memberOf fabric.util.object&#13;
   * TODO: this function return an empty object if you try to clone null&#13;
   * @param {Object} object Object to clone&#13;
   * @return {Object}&#13;
   */&#13;
  function clone(object, deep) {&#13;
    return extend({ }, object, deep);&#13;
  }&#13;
&#13;
  /** @namespace fabric.util.object */&#13;
  fabric.util.object = {&#13;
    extend: extend,&#13;
    clone: clone&#13;
  };&#13;
  fabric.util.object.extend(fabric.util, fabric.Observable);&#13;
})();&#13;
&#13;
&#13;
(function() {&#13;
&#13;
  /**&#13;
   * Camelizes a string&#13;
   * @memberOf fabric.util.string&#13;
   * @param {String} string String to camelize&#13;
   * @return {String} Camelized version of a string&#13;
   */&#13;
  function camelize(string) {&#13;
    return string.replace(/-+(.)?/g, function(match, character) {&#13;
      return character ? character.toUpperCase() : '';&#13;
    });&#13;
  }&#13;
&#13;
  /**&#13;
   * Capitalizes a string&#13;
   * @memberOf fabric.util.string&#13;
   * @param {String} string String to capitalize&#13;
   * @param {Boolean} [firstLetterOnly] If true only first letter is capitalized&#13;
   * and other letters stay untouched, if false first letter is capitalized&#13;
   * and other letters are converted to lowercase.&#13;
   * @return {String} Capitalized version of a string&#13;
   */&#13;
  function capitalize(string, firstLetterOnly) {&#13;
    return string.charAt(0).toUpperCase() +&#13;
      (firstLetterOnly ? string.slice(1) : string.slice(1).toLowerCase());&#13;
  }&#13;
&#13;
  /**&#13;
   * Escapes XML in a string&#13;
   * @memberOf fabric.util.string&#13;
   * @param {String} string String to escape&#13;
   * @return {String} Escaped version of a string&#13;
   */&#13;
  function escapeXml(string) {&#13;
    return string.replace(/&amp;/g, '&amp;amp;')&#13;
      .replace(/"/g, '&amp;quot;')&#13;
      .replace(/'/g, '&amp;apos;')&#13;
      .replace(/&lt;/g, '&amp;lt;')&#13;
      .replace(/&gt;/g, '&amp;gt;');&#13;
  }&#13;
&#13;
  /**&#13;
   * Divide a string in the user perceived single units&#13;
   * @memberOf fabric.util.string&#13;
   * @param {String} textstring String to escape&#13;
   * @return {Array} array containing the graphemes&#13;
   */&#13;
  function graphemeSplit(textstring) {&#13;
    var i = 0, chr, graphemes = [];&#13;
    for (i = 0, chr; i &lt; textstring.length; i++) {&#13;
      if ((chr = getWholeChar(textstring, i)) === false) {&#13;
        continue;&#13;
      }&#13;
      graphemes.push(chr);&#13;
    }&#13;
    return graphemes;&#13;
  }&#13;
&#13;
  // taken from mdn in the charAt doc page.&#13;
  function getWholeChar(str, i) {&#13;
    var code = str.charCodeAt(i);&#13;
&#13;
    if (isNaN(code)) {&#13;
      return ''; // Position not found&#13;
    }&#13;
    if (code &lt; 0xD800 || code &gt; 0xDFFF) {&#13;
      return str.charAt(i);&#13;
    }&#13;
&#13;
    // High surrogate (could change last hex to 0xDB7F to treat high private&#13;
    // surrogates as single characters)&#13;
    if (0xD800 &lt;= code &amp;&amp; code &lt;= 0xDBFF) {&#13;
      if (str.length &lt;= (i + 1)) {&#13;
        throw 'High surrogate without following low surrogate';&#13;
      }&#13;
      var next = str.charCodeAt(i + 1);&#13;
      if (0xDC00 &gt; next || next &gt; 0xDFFF) {&#13;
        throw 'High surrogate without following low surrogate';&#13;
      }&#13;
      return str.charAt(i) + str.charAt(i + 1);&#13;
    }&#13;
    // Low surrogate (0xDC00 &lt;= code &amp;&amp; code &lt;= 0xDFFF)&#13;
    if (i === 0) {&#13;
      throw 'Low surrogate without preceding high surrogate';&#13;
    }&#13;
    var prev = str.charCodeAt(i - 1);&#13;
&#13;
    // (could change last hex to 0xDB7F to treat high private&#13;
    // surrogates as single characters)&#13;
    if (0xD800 &gt; prev || prev &gt; 0xDBFF) {&#13;
      throw 'Low surrogate without preceding high surrogate';&#13;
    }&#13;
    // We can pass over low surrogates now as the second component&#13;
    // in a pair which we have already processed&#13;
    return false;&#13;
  }&#13;
&#13;
&#13;
  /**&#13;
   * String utilities&#13;
   * @namespace fabric.util.string&#13;
   */&#13;
  fabric.util.string = {&#13;
    camelize: camelize,&#13;
    capitalize: capitalize,&#13;
    escapeXml: escapeXml,&#13;
    graphemeSplit: graphemeSplit&#13;
  };&#13;
})();&#13;
&#13;
&#13;
(function() {&#13;
&#13;
  var slice = Array.prototype.slice, emptyFunction = function() { },&#13;
&#13;
      IS_DONTENUM_BUGGY = (function() {&#13;
        for (var p in { toString: 1 }) {&#13;
          if (p === 'toString') {&#13;
            return false;&#13;
          }&#13;
        }&#13;
        return true;&#13;
      })(),&#13;
&#13;
      /** @ignore */&#13;
      addMethods = function(klass, source, parent) {&#13;
        for (var property in source) {&#13;
&#13;
          if (property in klass.prototype &amp;&amp;&#13;
              typeof klass.prototype[property] === 'function' &amp;&amp;&#13;
              (source[property] + '').indexOf('callSuper') &gt; -1) {&#13;
&#13;
            klass.prototype[property] = (function(property) {&#13;
              return function() {&#13;
&#13;
                var superclass = this.constructor.superclass;&#13;
                this.constructor.superclass = parent;&#13;
                var returnValue = source[property].apply(this, arguments);&#13;
                this.constructor.superclass = superclass;&#13;
&#13;
                if (property !== 'initialize') {&#13;
                  return returnValue;&#13;
                }&#13;
              };&#13;
            })(property);&#13;
          }&#13;
          else {&#13;
            klass.prototype[property] = source[property];&#13;
          }&#13;
&#13;
          if (IS_DONTENUM_BUGGY) {&#13;
            if (source.toString !== Object.prototype.toString) {&#13;
              klass.prototype.toString = source.toString;&#13;
            }&#13;
            if (source.valueOf !== Object.prototype.valueOf) {&#13;
              klass.prototype.valueOf = source.valueOf;&#13;
            }&#13;
          }&#13;
        }&#13;
      };&#13;
&#13;
  function Subclass() { }&#13;
&#13;
  function callSuper(methodName) {&#13;
    var parentMethod = null,&#13;
        _this = this;&#13;
&#13;
    // climb prototype chain to find method not equal to callee's method&#13;
    while (_this.constructor.superclass) {&#13;
      var superClassMethod = _this.constructor.superclass.prototype[methodName];&#13;
      if (_this[methodName] !== superClassMethod) {&#13;
        parentMethod = superClassMethod;&#13;
        break;&#13;
      }&#13;
      // eslint-disable-next-line&#13;
      _this = _this.constructor.superclass.prototype;&#13;
    }&#13;
&#13;
    if (!parentMethod) {&#13;
      return console.log('tried to callSuper ' + methodName + ', method not found in prototype chain', this);&#13;
    }&#13;
&#13;
    return (arguments.length &gt; 1)&#13;
      ? parentMethod.apply(this, slice.call(arguments, 1))&#13;
      : parentMethod.call(this);&#13;
  }&#13;
&#13;
  /**&#13;
   * Helper for creation of "classes".&#13;
   * @memberOf fabric.util&#13;
   * @param {Function} [parent] optional "Class" to inherit from&#13;
   * @param {Object} [properties] Properties shared by all instances of this class&#13;
   *                  (be careful modifying objects defined here as this would affect all instances)&#13;
   */&#13;
  function createClass() {&#13;
    var parent = null,&#13;
        properties = slice.call(arguments, 0);&#13;
&#13;
    if (typeof properties[0] === 'function') {&#13;
      parent = properties.shift();&#13;
    }&#13;
    function klass() {&#13;
      this.initialize.apply(this, arguments);&#13;
    }&#13;
&#13;
    klass.superclass = parent;&#13;
    klass.subclasses = [];&#13;
&#13;
    if (parent) {&#13;
      Subclass.prototype = parent.prototype;&#13;
      klass.prototype = new Subclass();&#13;
      parent.subclasses.push(klass);&#13;
    }&#13;
    for (var i = 0, length = properties.length; i &lt; length; i++) {&#13;
      addMethods(klass, properties[i], parent);&#13;
    }&#13;
    if (!klass.prototype.initialize) {&#13;
      klass.prototype.initialize = emptyFunction;&#13;
    }&#13;
    klass.prototype.constructor = klass;&#13;
    klass.prototype.callSuper = callSuper;&#13;
    return klass;&#13;
  }&#13;
&#13;
  fabric.util.createClass = createClass;&#13;
})();&#13;
&#13;
&#13;
(function () {&#13;
&#13;
  var unknown = 'unknown';&#13;
&#13;
  /* EVENT HANDLING */&#13;
&#13;
  function areHostMethods(object) {&#13;
    var methodNames = Array.prototype.slice.call(arguments, 1),&#13;
        t, i, len = methodNames.length;&#13;
    for (i = 0; i &lt; len; i++) {&#13;
      t = typeof object[methodNames[i]];&#13;
      if (!(/^(?:function|object|unknown)$/).test(t)) {&#13;
        return false;&#13;
      }&#13;
    }&#13;
    return true;&#13;
  }&#13;
&#13;
  /** @ignore */&#13;
  var getElement,&#13;
      setElement,&#13;
      getUniqueId = (function () {&#13;
        var uid = 0;&#13;
        return function (element) {&#13;
          return element.__uniqueID || (element.__uniqueID = 'uniqueID__' + uid++);&#13;
        };&#13;
      })();&#13;
&#13;
  (function () {&#13;
    var elements = { };&#13;
    /** @ignore */&#13;
    getElement = function (uid) {&#13;
      return elements[uid];&#13;
    };&#13;
    /** @ignore */&#13;
    setElement = function (uid, element) {&#13;
      elements[uid] = element;&#13;
    };&#13;
  })();&#13;
&#13;
  function createListener(uid, handler) {&#13;
    return {&#13;
      handler: handler,&#13;
      wrappedHandler: createWrappedHandler(uid, handler)&#13;
    };&#13;
  }&#13;
&#13;
  function createWrappedHandler(uid, handler) {&#13;
    return function (e) {&#13;
      handler.call(getElement(uid), e || fabric.window.event);&#13;
    };&#13;
  }&#13;
&#13;
  function createDispatcher(uid, eventName) {&#13;
    return function (e) {&#13;
      if (handlers[uid] &amp;&amp; handlers[uid][eventName]) {&#13;
        var handlersForEvent = handlers[uid][eventName];&#13;
        for (var i = 0, len = handlersForEvent.length; i &lt; len; i++) {&#13;
          handlersForEvent[i].call(this, e || fabric.window.event);&#13;
        }&#13;
      }&#13;
    };&#13;
  }&#13;
&#13;
  var shouldUseAddListenerRemoveListener = (&#13;
        areHostMethods(fabric.document.documentElement, 'addEventListener', 'removeEventListener') &amp;&amp;&#13;
        areHostMethods(fabric.window, 'addEventListener', 'removeEventListener')),&#13;
&#13;
      shouldUseAttachEventDetachEvent = (&#13;
        areHostMethods(fabric.document.documentElement, 'attachEvent', 'detachEvent') &amp;&amp;&#13;
        areHostMethods(fabric.window, 'attachEvent', 'detachEvent')),&#13;
&#13;
      // IE branch&#13;
      listeners = { },&#13;
&#13;
      // DOM L0 branch&#13;
      handlers = { },&#13;
&#13;
      addListener, removeListener;&#13;
&#13;
  if (shouldUseAddListenerRemoveListener) {&#13;
    /** @ignore */&#13;
    addListener = function (element, eventName, handler, options) {&#13;
      // since ie10 or ie9 can use addEventListener but they do not support options, i need to check&#13;
      element &amp;&amp; element.addEventListener(eventName, handler, shouldUseAttachEventDetachEvent ? false : options);&#13;
    };&#13;
    /** @ignore */&#13;
    removeListener = function (element, eventName, handler, options) {&#13;
      element &amp;&amp; element.removeEventListener(eventName, handler, shouldUseAttachEventDetachEvent ? false : options);&#13;
    };&#13;
  }&#13;
&#13;
  else if (shouldUseAttachEventDetachEvent) {&#13;
    /** @ignore */&#13;
    addListener = function (element, eventName, handler) {&#13;
      if (!element) {&#13;
        return;&#13;
      }&#13;
      var uid = getUniqueId(element);&#13;
      setElement(uid, element);&#13;
      if (!listeners[uid]) {&#13;
        listeners[uid] = { };&#13;
      }&#13;
      if (!listeners[uid][eventName]) {&#13;
        listeners[uid][eventName] = [];&#13;
&#13;
      }&#13;
      var listener = createListener(uid, handler);&#13;
      listeners[uid][eventName].push(listener);&#13;
      element.attachEvent('on' + eventName, listener.wrappedHandler);&#13;
    };&#13;
    /** @ignore */&#13;
    removeListener = function (element, eventName, handler) {&#13;
      if (!element) {&#13;
        return;&#13;
      }&#13;
      var uid = getUniqueId(element), listener;&#13;
      if (listeners[uid] &amp;&amp; listeners[uid][eventName]) {&#13;
        for (var i = 0, len = listeners[uid][eventName].length; i &lt; len; i++) {&#13;
          listener = listeners[uid][eventName][i];&#13;
          if (listener &amp;&amp; listener.handler === handler) {&#13;
            element.detachEvent('on' + eventName, listener.wrappedHandler);&#13;
            listeners[uid][eventName][i] = null;&#13;
          }&#13;
        }&#13;
      }&#13;
    };&#13;
  }&#13;
  else {&#13;
    /** @ignore */&#13;
    addListener = function (element, eventName, handler) {&#13;
      if (!element) {&#13;
        return;&#13;
      }&#13;
      var uid = getUniqueId(element);&#13;
      if (!handlers[uid]) {&#13;
        handlers[uid] = { };&#13;
      }&#13;
      if (!handlers[uid][eventName]) {&#13;
        handlers[uid][eventName] = [];&#13;
        var existingHandler = element['on' + eventName];&#13;
        if (existingHandler) {&#13;
          handlers[uid][eventName].push(existingHandler);&#13;
        }&#13;
        element['on' + eventName] = createDispatcher(uid, eventName);&#13;
      }&#13;
      handlers[uid][eventName].push(handler);&#13;
    };&#13;
    /** @ignore */&#13;
    removeListener = function (element, eventName, handler) {&#13;
      if (!element) {&#13;
        return;&#13;
      }&#13;
      var uid = getUniqueId(element);&#13;
      if (handlers[uid] &amp;&amp; handlers[uid][eventName]) {&#13;
        var handlersForEvent = handlers[uid][eventName];&#13;
        for (var i = 0, len = handlersForEvent.length; i &lt; len; i++) {&#13;
          if (handlersForEvent[i] === handler) {&#13;
            handlersForEvent.splice(i, 1);&#13;
          }&#13;
        }&#13;
      }&#13;
    };&#13;
  }&#13;
&#13;
  /**&#13;
   * Adds an event listener to an element&#13;
   * @function&#13;
   * @memberOf fabric.util&#13;
   * @param {HTMLElement} element&#13;
   * @param {String} eventName&#13;
   * @param {Function} handler&#13;
   */&#13;
  fabric.util.addListener = addListener;&#13;
&#13;
  /**&#13;
   * Removes an event listener from an element&#13;
   * @function&#13;
   * @memberOf fabric.util&#13;
   * @param {HTMLElement} element&#13;
   * @param {String} eventName&#13;
   * @param {Function} handler&#13;
   */&#13;
  fabric.util.removeListener = removeListener;&#13;
&#13;
  /**&#13;
   * Cross-browser wrapper for getting event's coordinates&#13;
   * @memberOf fabric.util&#13;
   * @param {Event} event Event object&#13;
   */&#13;
  function getPointer(event) {&#13;
    event || (event = fabric.window.event);&#13;
&#13;
    var element = event.target ||&#13;
                  (typeof event.srcElement !== unknown ? event.srcElement : null),&#13;
&#13;
        scroll = fabric.util.getScrollLeftTop(element);&#13;
&#13;
    return {&#13;
      x: pointerX(event) + scroll.left,&#13;
      y: pointerY(event) + scroll.top&#13;
    };&#13;
  }&#13;
&#13;
  var pointerX = function(event) {&#13;
        return event.clientX;&#13;
      },&#13;
&#13;
      pointerY = function(event) {&#13;
        return event.clientY;&#13;
      };&#13;
&#13;
  function _getPointer(event, pageProp, clientProp) {&#13;
    var touchProp = event.type === 'touchend' ? 'changedTouches' : 'touches';&#13;
&#13;
    return (event[touchProp] &amp;&amp; event[touchProp][0]&#13;
      ? (event[touchProp][0][pageProp] - (event[touchProp][0][pageProp] - event[touchProp][0][clientProp]))&#13;
        || event[clientProp]&#13;
      : event[clientProp]);&#13;
  }&#13;
&#13;
  if (fabric.isTouchSupported) {&#13;
    pointerX = function(event) {&#13;
      return _getPointer(event, 'pageX', 'clientX');&#13;
    };&#13;
    pointerY = function(event) {&#13;
      return _getPointer(event, 'pageY', 'clientY');&#13;
    };&#13;
  }&#13;
&#13;
  fabric.util.getPointer = getPointer;&#13;
&#13;
})();&#13;
&#13;
&#13;
(function () {&#13;
&#13;
  /**&#13;
   * Cross-browser wrapper for setting element's style&#13;
   * @memberOf fabric.util&#13;
   * @param {HTMLElement} element&#13;
   * @param {Object} styles&#13;
   * @return {HTMLElement} Element that was passed as a first argument&#13;
   */&#13;
  function setStyle(element, styles) {&#13;
    var elementStyle = element.style;&#13;
    if (!elementStyle) {&#13;
      return element;&#13;
    }&#13;
    if (typeof styles === 'string') {&#13;
      element.style.cssText += ';' + styles;&#13;
      return styles.indexOf('opacity') &gt; -1&#13;
        ? setOpacity(element, styles.match(/opacity:\s*(\d?\.?\d*)/)[1])&#13;
        : element;&#13;
    }&#13;
    for (var property in styles) {&#13;
      if (property === 'opacity') {&#13;
        setOpacity(element, styles[property]);&#13;
      }&#13;
      else {&#13;
        var normalizedProperty = (property === 'float' || property === 'cssFloat')&#13;
          ? (typeof elementStyle.styleFloat === 'undefined' ? 'cssFloat' : 'styleFloat')&#13;
          : property;&#13;
        elementStyle[normalizedProperty] = styles[property];&#13;
      }&#13;
    }&#13;
    return element;&#13;
  }&#13;
&#13;
  var parseEl = fabric.document.createElement('div'),&#13;
      supportsOpacity = typeof parseEl.style.opacity === 'string',&#13;
      supportsFilters = typeof parseEl.style.filter === 'string',&#13;
      reOpacity = /alpha\s*\(\s*opacity\s*=\s*([^\)]+)\)/,&#13;
&#13;
      /** @ignore */&#13;
      setOpacity = function (element) { return element; };&#13;
&#13;
  if (supportsOpacity) {&#13;
    /** @ignore */&#13;
    setOpacity = function(element, value) {&#13;
      element.style.opacity = value;&#13;
      return element;&#13;
    };&#13;
  }&#13;
  else if (supportsFilters) {&#13;
    /** @ignore */&#13;
    setOpacity = function(element, value) {&#13;
      var es = element.style;&#13;
      if (element.currentStyle &amp;&amp; !element.currentStyle.hasLayout) {&#13;
        es.zoom = 1;&#13;
      }&#13;
      if (reOpacity.test(es.filter)) {&#13;
        value = value &gt;= 0.9999 ? '' : ('alpha(opacity=' + (value * 100) + ')');&#13;
        es.filter = es.filter.replace(reOpacity, value);&#13;
      }&#13;
      else {&#13;
        es.filter += ' alpha(opacity=' + (value * 100) + ')';&#13;
      }&#13;
      return element;&#13;
    };&#13;
  }&#13;
&#13;
  fabric.util.setStyle = setStyle;&#13;
&#13;
})();&#13;
&#13;
&#13;
(function() {&#13;
&#13;
  var _slice = Array.prototype.slice;&#13;
&#13;
  /**&#13;
   * Takes id and returns an element with that id (if one exists in a document)&#13;
   * @memberOf fabric.util&#13;
   * @param {String|HTMLElement} id&#13;
   * @return {HTMLElement|null}&#13;
   */&#13;
  function getById(id) {&#13;
    return typeof id === 'string' ? fabric.document.getElementById(id) : id;&#13;
  }&#13;
&#13;
  var sliceCanConvertNodelists,&#13;
      /**&#13;
       * Converts an array-like object (e.g. arguments or NodeList) to an array&#13;
       * @memberOf fabric.util&#13;
       * @param {Object} arrayLike&#13;
       * @return {Array}&#13;
       */&#13;
      toArray = function(arrayLike) {&#13;
        return _slice.call(arrayLike, 0);&#13;
      };&#13;
&#13;
  try {&#13;
    sliceCanConvertNodelists = toArray(fabric.document.childNodes) instanceof Array;&#13;
  }&#13;
  catch (err) { }&#13;
&#13;
  if (!sliceCanConvertNodelists) {&#13;
    toArray = function(arrayLike) {&#13;
      var arr = new Array(arrayLike.length), i = arrayLike.length;&#13;
      while (i--) {&#13;
        arr[i] = arrayLike[i];&#13;
      }&#13;
      return arr;&#13;
    };&#13;
  }&#13;
&#13;
  /**&#13;
   * Creates specified element with specified attributes&#13;
   * @memberOf fabric.util&#13;
   * @param {String} tagName Type of an element to create&#13;
   * @param {Object} [attributes] Attributes to set on an element&#13;
   * @return {HTMLElement} Newly created element&#13;
   */&#13;
  function makeElement(tagName, attributes) {&#13;
    var el = fabric.document.createElement(tagName);&#13;
    for (var prop in attributes) {&#13;
      if (prop === 'class') {&#13;
        el.className = attributes[prop];&#13;
      }&#13;
      else if (prop === 'for') {&#13;
        el.htmlFor = attributes[prop];&#13;
      }&#13;
      else {&#13;
        el.setAttribute(prop, attributes[prop]);&#13;
      }&#13;
    }&#13;
    return el;&#13;
  }&#13;
&#13;
  /**&#13;
   * Adds class to an element&#13;
   * @memberOf fabric.util&#13;
   * @param {HTMLElement} element Element to add class to&#13;
   * @param {String} className Class to add to an element&#13;
   */&#13;
  function addClass(element, className) {&#13;
    if (element &amp;&amp; (' ' + element.className + ' ').indexOf(' ' + className + ' ') === -1) {&#13;
      element.className += (element.className ? ' ' : '') + className;&#13;
    }&#13;
  }&#13;
&#13;
  /**&#13;
   * Wraps element with another element&#13;
   * @memberOf fabric.util&#13;
   * @param {HTMLElement} element Element to wrap&#13;
   * @param {HTMLElement|String} wrapper Element to wrap with&#13;
   * @param {Object} [attributes] Attributes to set on a wrapper&#13;
   * @return {HTMLElement} wrapper&#13;
   */&#13;
  function wrapElement(element, wrapper, attributes) {&#13;
    if (typeof wrapper === 'string') {&#13;
      wrapper = makeElement(wrapper, attributes);&#13;
    }&#13;
    if (element.parentNode) {&#13;
      element.parentNode.replaceChild(wrapper, element);&#13;
    }&#13;
    wrapper.appendChild(element);&#13;
    return wrapper;&#13;
  }&#13;
&#13;
  /**&#13;
   * Returns element scroll offsets&#13;
   * @memberOf fabric.util&#13;
   * @param {HTMLElement} element Element to operate on&#13;
   * @return {Object} Object with left/top values&#13;
   */&#13;
  function getScrollLeftTop(element) {&#13;
&#13;
    var left = 0,&#13;
        top = 0,&#13;
        docElement = fabric.document.documentElement,&#13;
        body = fabric.document.body || {&#13;
          scrollLeft: 0, scrollTop: 0&#13;
        };&#13;
&#13;
    // While loop checks (and then sets element to) .parentNode OR .host&#13;
    //  to account for ShadowDOM. We still want to traverse up out of ShadowDOM,&#13;
    //  but the .parentNode of a root ShadowDOM node will always be null, instead&#13;
    //  it should be accessed through .host. See http://stackoverflow.com/a/24765528/4383938&#13;
    while (element &amp;&amp; (element.parentNode || element.host)) {&#13;
&#13;
      // Set element to element parent, or 'host' in case of ShadowDOM&#13;
      element = element.parentNode || element.host;&#13;
&#13;
      if (element === fabric.document) {&#13;
        left = body.scrollLeft || docElement.scrollLeft || 0;&#13;
        top = body.scrollTop ||  docElement.scrollTop || 0;&#13;
      }&#13;
      else {&#13;
        left += element.scrollLeft || 0;&#13;
        top += element.scrollTop || 0;&#13;
      }&#13;
&#13;
      if (element.nodeType === 1 &amp;&amp; element.style.position === 'fixed') {&#13;
        break;&#13;
      }&#13;
    }&#13;
&#13;
    return { left: left, top: top };&#13;
  }&#13;
&#13;
  /**&#13;
   * Returns offset for a given element&#13;
   * @function&#13;
   * @memberOf fabric.util&#13;
   * @param {HTMLElement} element Element to get offset for&#13;
   * @return {Object} Object with "left" and "top" properties&#13;
   */&#13;
  function getElementOffset(element) {&#13;
    var docElem,&#13;
        doc = element &amp;&amp; element.ownerDocument,&#13;
        box = { left: 0, top: 0 },&#13;
        offset = { left: 0, top: 0 },&#13;
        scrollLeftTop,&#13;
        offsetAttributes = {&#13;
          borderLeftWidth: 'left',&#13;
          borderTopWidth:  'top',&#13;
          paddingLeft:     'left',&#13;
          paddingTop:      'top'&#13;
        };&#13;
&#13;
    if (!doc) {&#13;
      return offset;&#13;
    }&#13;
&#13;
    for (var attr in offsetAttributes) {&#13;
      offset[offsetAttributes[attr]] += parseInt(getElementStyle(element, attr), 10) || 0;&#13;
    }&#13;
&#13;
    docElem = doc.documentElement;&#13;
    if ( typeof element.getBoundingClientRect !== 'undefined' ) {&#13;
      box = element.getBoundingClientRect();&#13;
    }&#13;
&#13;
    scrollLeftTop = getScrollLeftTop(element);&#13;
&#13;
    return {&#13;
      left: box.left + scrollLeftTop.left - (docElem.clientLeft || 0) + offset.left,&#13;
      top: box.top + scrollLeftTop.top - (docElem.clientTop || 0)  + offset.top&#13;
    };&#13;
  }&#13;
&#13;
  /**&#13;
   * Returns style attribute value of a given element&#13;
   * @memberOf fabric.util&#13;
   * @param {HTMLElement} element Element to get style attribute for&#13;
   * @param {String} attr Style attribute to get for element&#13;
   * @return {String} Style attribute value of the given element.&#13;
   */&#13;
  var getElementStyle;&#13;
  if (fabric.document.defaultView &amp;&amp; fabric.document.defaultView.getComputedStyle) {&#13;
    getElementStyle = function(element, attr) {&#13;
      var style = fabric.document.defaultView.getComputedStyle(element, null);&#13;
      return style ? style[attr] : undefined;&#13;
    };&#13;
  }&#13;
  else {&#13;
    getElementStyle = function(element, attr) {&#13;
      var value = element.style[attr];&#13;
      if (!value &amp;&amp; element.currentStyle) {&#13;
        value = element.currentStyle[attr];&#13;
      }&#13;
      return value;&#13;
    };&#13;
  }&#13;
&#13;
  (function () {&#13;
    var style = fabric.document.documentElement.style,&#13;
        selectProp = 'userSelect' in style&#13;
          ? 'userSelect'&#13;
          : 'MozUserSelect' in style&#13;
            ? 'MozUserSelect'&#13;
            : 'WebkitUserSelect' in style&#13;
              ? 'WebkitUserSelect'&#13;
              : 'KhtmlUserSelect' in style&#13;
                ? 'KhtmlUserSelect'&#13;
                : '';&#13;
&#13;
    /**&#13;
     * Makes element unselectable&#13;
     * @memberOf fabric.util&#13;
     * @param {HTMLElement} element Element to make unselectable&#13;
     * @return {HTMLElement} Element that was passed in&#13;
     */&#13;
    function makeElementUnselectable(element) {&#13;
      if (typeof element.onselectstart !== 'undefined') {&#13;
        element.onselectstart = fabric.util.falseFunction;&#13;
      }&#13;
      if (selectProp) {&#13;
        element.style[selectProp] = 'none';&#13;
      }&#13;
      else if (typeof element.unselectable === 'string') {&#13;
        element.unselectable = 'on';&#13;
      }&#13;
      return element;&#13;
    }&#13;
&#13;
    /**&#13;
     * Makes element selectable&#13;
     * @memberOf fabric.util&#13;
     * @param {HTMLElement} element Element to make selectable&#13;
     * @return {HTMLElement} Element that was passed in&#13;
     */&#13;
    function makeElementSelectable(element) {&#13;
      if (typeof element.onselectstart !== 'undefined') {&#13;
        element.onselectstart = null;&#13;
      }&#13;
      if (selectProp) {&#13;
        element.style[selectProp] = '';&#13;
      }&#13;
      else if (typeof element.unselectable === 'string') {&#13;
        element.unselectable = '';&#13;
      }&#13;
      return element;&#13;
    }&#13;
&#13;
    fabric.util.makeElementUnselectable = makeElementUnselectable;&#13;
    fabric.util.makeElementSelectable = makeElementSelectable;&#13;
  })();&#13;
&#13;
  (function() {&#13;
&#13;
    /**&#13;
     * Inserts a script element with a given url into a document; invokes callback, when that script is finished loading&#13;
     * @memberOf fabric.util&#13;
     * @param {String} url URL of a script to load&#13;
     * @param {Function} callback Callback to execute when script is finished loading&#13;
     */&#13;
    function getScript(url, callback) {&#13;
      var headEl = fabric.document.getElementsByTagName('head')[0],&#13;
          scriptEl = fabric.document.createElement('script'),&#13;
          loading = true;&#13;
&#13;
      /** @ignore */&#13;
      scriptEl.onload = /** @ignore */ scriptEl.onreadystatechange = function(e) {&#13;
        if (loading) {&#13;
          if (typeof this.readyState === 'string' &amp;&amp;&#13;
              this.readyState !== 'loaded' &amp;&amp;&#13;
              this.readyState !== 'complete') {&#13;
            return;&#13;
          }&#13;
          loading = false;&#13;
          callback(e || fabric.window.event);&#13;
          scriptEl = scriptEl.onload = scriptEl.onreadystatechange = null;&#13;
        }&#13;
      };&#13;
      scriptEl.src = url;&#13;
      headEl.appendChild(scriptEl);&#13;
      // causes issue in Opera&#13;
      // headEl.removeChild(scriptEl);&#13;
    }&#13;
&#13;
    fabric.util.getScript = getScript;&#13;
  })();&#13;
&#13;
  function getNodeCanvas(element) {&#13;
    var impl = fabric.jsdomImplForWrapper(element);&#13;
    return impl._canvas || impl._image;&#13;
  };&#13;
&#13;
  fabric.util.getById = getById;&#13;
  fabric.util.toArray = toArray;&#13;
  fabric.util.makeElement = makeElement;&#13;
  fabric.util.addClass = addClass;&#13;
  fabric.util.wrapElement = wrapElement;&#13;
  fabric.util.getScrollLeftTop = getScrollLeftTop;&#13;
  fabric.util.getElementOffset = getElementOffset;&#13;
  fabric.util.getElementStyle = getElementStyle;&#13;
  fabric.util.getNodeCanvas = getNodeCanvas;&#13;
&#13;
})();&#13;
&#13;
&#13;
(function() {&#13;
&#13;
  function addParamToUrl(url, param) {&#13;
    return url + (/\?/.test(url) ? '&amp;' : '?') + param;&#13;
  }&#13;
&#13;
  var makeXHR = (function() {&#13;
    var factories = [&#13;
      function() { return new ActiveXObject('Microsoft.XMLHTTP'); },&#13;
      function() { return new ActiveXObject('Msxml2.XMLHTTP'); },&#13;
      function() { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); },&#13;
      function() { return new XMLHttpRequest(); }&#13;
    ];&#13;
    for (var i = factories.length; i--; ) {&#13;
      try {&#13;
        var req = factories[i]();&#13;
        if (req) {&#13;
          return factories[i];&#13;
        }&#13;
      }&#13;
      catch (err) { }&#13;
    }&#13;
  })();&#13;
&#13;
  function emptyFn() { }&#13;
&#13;
  /**&#13;
   * Cross-browser abstraction for sending XMLHttpRequest&#13;
   * @memberOf fabric.util&#13;
   * @param {String} url URL to send XMLHttpRequest to&#13;
   * @param {Object} [options] Options object&#13;
   * @param {String} [options.method="GET"]&#13;
   * @param {String} [options.parameters] parameters to append to url in GET or in body&#13;
   * @param {String} [options.body] body to send with POST or PUT request&#13;
   * @param {Function} options.onComplete Callback to invoke when request is completed&#13;
   * @return {XMLHttpRequest} request&#13;
   */&#13;
  function request(url, options) {&#13;
&#13;
    options || (options = { });&#13;
&#13;
    var method = options.method ? options.method.toUpperCase() : 'GET',&#13;
        onComplete = options.onComplete || function() { },&#13;
        xhr = makeXHR(),&#13;
        body = options.body || options.parameters;&#13;
&#13;
    /** @ignore */&#13;
    xhr.onreadystatechange = function() {&#13;
      if (xhr.readyState === 4) {&#13;
        onComplete(xhr);&#13;
        xhr.onreadystatechange = emptyFn;&#13;
      }&#13;
    };&#13;
&#13;
    if (method === 'GET') {&#13;
      body = null;&#13;
      if (typeof options.parameters === 'string') {&#13;
        url = addParamToUrl(url, options.parameters);&#13;
      }&#13;
    }&#13;
&#13;
    xhr.open(method, url, true);&#13;
&#13;
    if (method === 'POST' || method === 'PUT') {&#13;
      xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');&#13;
    }&#13;
&#13;
    xhr.send(body);&#13;
    return xhr;&#13;
  }&#13;
&#13;
  fabric.util.request = request;&#13;
})();&#13;
&#13;
&#13;
/**&#13;
 * Wrapper around `console.log` (when available)&#13;
 * @param {*} [values] Values to log&#13;
 */&#13;
fabric.log = function() { };&#13;
&#13;
/**&#13;
 * Wrapper around `console.warn` (when available)&#13;
 * @param {*} [values] Values to log as a warning&#13;
 */&#13;
fabric.warn = function() { };&#13;
&#13;
/* eslint-disable */&#13;
if (typeof console !== 'undefined') {&#13;
&#13;
  ['log', 'warn'].forEach(function(methodName) {&#13;
&#13;
    if (typeof console[methodName] !== 'undefined' &amp;&amp;&#13;
        typeof console[methodName].apply === 'function') {&#13;
&#13;
      fabric[methodName] = function() {&#13;
        return console[methodName].apply(console, arguments);&#13;
      };&#13;
    }&#13;
  });&#13;
}&#13;
/* eslint-enable */&#13;
&#13;
&#13;
(function() {&#13;
&#13;
  function noop() {&#13;
    return false;&#13;
  }&#13;
&#13;
  /**&#13;
   * Changes value from one to another within certain period of time, invoking callbacks as value is being changed.&#13;
   * @memberOf fabric.util&#13;
   * @param {Object} [options] Animation options&#13;
   * @param {Function} [options.onChange] Callback; invoked on every value change&#13;
   * @param {Function} [options.onComplete] Callback; invoked when value change is completed&#13;
   * @param {Number} [options.startValue=0] Starting value&#13;
   * @param {Number} [options.endValue=100] Ending value&#13;
   * @param {Number} [options.byValue=100] Value to modify the property by&#13;
   * @param {Function} [options.easing] Easing function&#13;
   * @param {Number} [options.duration=500] Duration of change (in ms)&#13;
   */&#13;
  function animate(options) {&#13;
&#13;
    requestAnimFrame(function(timestamp) {&#13;
      options || (options = { });&#13;
&#13;
      var start = timestamp || +new Date(),&#13;
          duration = options.duration || 500,&#13;
          finish = start + duration, time,&#13;
          onChange = options.onChange || noop,&#13;
          abort = options.abort || noop,&#13;
          onComplete = options.onComplete || noop,&#13;
          easing = options.easing || function(t, b, c, d) {return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;},&#13;
          startValue = 'startValue' in options ? options.startValue : 0,&#13;
          endValue = 'endValue' in options ? options.endValue : 100,&#13;
          byValue = options.byValue || endValue - startValue;&#13;
&#13;
      options.onStart &amp;&amp; options.onStart();&#13;
&#13;
      (function tick(ticktime) {&#13;
        if (abort()) {&#13;
          onComplete(endValue, 1, 1);&#13;
          return;&#13;
        }&#13;
        time = ticktime || +new Date();&#13;
        var currentTime = time &gt; finish ? duration : (time - start),&#13;
            timePerc = currentTime / duration,&#13;
            current = easing(currentTime, startValue, byValue, duration),&#13;
            valuePerc = Math.abs((current - startValue) / byValue);&#13;
        onChange(current, valuePerc, timePerc);&#13;
        if (time &gt; finish) {&#13;
          options.onComplete &amp;&amp; options.onComplete();&#13;
          return;&#13;
        }&#13;
        requestAnimFrame(tick);&#13;
      })(start);&#13;
    });&#13;
&#13;
  }&#13;
&#13;
  var _requestAnimFrame = fabric.window.requestAnimationFrame       ||&#13;
                          fabric.window.webkitRequestAnimationFrame ||&#13;
                          fabric.window.mozRequestAnimationFrame    ||&#13;
                          fabric.window.oRequestAnimationFrame      ||&#13;
                          fabric.window.msRequestAnimationFrame     ||&#13;
                          function(callback) {&#13;
                            return fabric.window.setTimeout(callback, 1000 / 60);&#13;
                          };&#13;
&#13;
  var _cancelAnimFrame = fabric.window.cancelAnimationFrame || fabric.window.clearTimeout;&#13;
&#13;
  /**&#13;
   * requestAnimationFrame polyfill based on http://paulirish.com/2011/requestanimationframe-for-smart-animating/&#13;
   * In order to get a precise start time, `requestAnimFrame` should be called as an entry into the method&#13;
   * @memberOf fabric.util&#13;
   * @param {Function} callback Callback to invoke&#13;
   * @param {DOMElement} element optional Element to associate with animation&#13;
   */&#13;
  function requestAnimFrame() {&#13;
    return _requestAnimFrame.apply(fabric.window, arguments);&#13;
  }&#13;
&#13;
  function cancelAnimFrame() {&#13;
    return _cancelAnimFrame.apply(fabric.window, arguments);&#13;
  }&#13;
&#13;
  fabric.util.animate = animate;&#13;
  fabric.util.requestAnimFrame = requestAnimFrame;&#13;
  fabric.util.cancelAnimFrame = cancelAnimFrame;&#13;
})();&#13;
&#13;
&#13;
(function() {&#13;
  // Calculate an in-between color. Returns a "rgba()" string.&#13;
  // Credit: Edwin Martin &lt;edwin@bitstorm.org&gt;&#13;
  //         http://www.bitstorm.org/jquery/color-animation/jquery.animate-colors.js&#13;
  function calculateColor(begin, end, pos) {&#13;
    var color = 'rgba('&#13;
        + parseInt((begin[0] + pos * (end[0] - begin[0])), 10) + ','&#13;
        + parseInt((begin[1] + pos * (end[1] - begin[1])), 10) + ','&#13;
        + parseInt((begin[2] + pos * (end[2] - begin[2])), 10);&#13;
&#13;
    color += ',' + (begin &amp;&amp; end ? parseFloat(begin[3] + pos * (end[3] - begin[3])) : 1);&#13;
    color += ')';&#13;
    return color;&#13;
  }&#13;
&#13;
  /**&#13;
   * Changes the color from one to another within certain period of time, invoking callbacks as value is being changed.&#13;
   * @memberOf fabric.util&#13;
   * @param {String} fromColor The starting color in hex or rgb(a) format.&#13;
   * @param {String} toColor The starting color in hex or rgb(a) format.&#13;
   * @param {Number} [duration] Duration of change (in ms).&#13;
   * @param {Object} [options] Animation options&#13;
   * @param {Function} [options.onChange] Callback; invoked on every value change&#13;
   * @param {Function} [options.onComplete] Callback; invoked when value change is completed&#13;
   * @param {Function} [options.colorEasing] Easing function. Note that this function only take two arguments (currentTime, duration). Thus the regular animation easing functions cannot be used.&#13;
   */&#13;
  function animateColor(fromColor, toColor, duration, options) {&#13;
    var startColor = new fabric.Color(fromColor).getSource(),&#13;
        endColor = new fabric.Color(toColor).getSource();&#13;
&#13;
    options = options || {};&#13;
&#13;
    fabric.util.animate(fabric.util.object.extend(options, {&#13;
      duration: duration || 500,&#13;
      startValue: startColor,&#13;
      endValue: endColor,&#13;
      byValue: endColor,&#13;
      easing: function (currentTime, startValue, byValue, duration) {&#13;
        var posValue = options.colorEasing&#13;
          ? options.colorEasing(currentTime, duration)&#13;
          : 1 - Math.cos(currentTime / duration * (Math.PI / 2));&#13;
        return calculateColor(startValue, byValue, posValue);&#13;
      }&#13;
    }));&#13;
  }&#13;
&#13;
  fabric.util.animateColor = animateColor;&#13;
&#13;
})();&#13;
&#13;
&#13;
(function() {&#13;
&#13;
  function normalize(a, c, p, s) {&#13;
    if (a &lt; Math.abs(c)) {&#13;
      a = c;&#13;
      s = p / 4;&#13;
    }&#13;
    else {&#13;
      //handle the 0/0 case:&#13;
      if (c === 0 &amp;&amp; a === 0) {&#13;
        s = p / (2 * Math.PI) * Math.asin(1);&#13;
      }&#13;
      else {&#13;
        s = p / (2 * Math.PI) * Math.asin(c / a);&#13;
      }&#13;
    }&#13;
    return { a: a, c: c, p: p, s: s };&#13;
  }&#13;
&#13;
  function elastic(opts, t, d) {&#13;
    return opts.a *&#13;
      Math.pow(2, 10 * (t -= 1)) *&#13;
      Math.sin( (t * d - opts.s) * (2 * Math.PI) / opts.p );&#13;
  }&#13;
&#13;
  /**&#13;
   * Cubic easing out&#13;
   * @memberOf fabric.util.ease&#13;
   */&#13;
  function easeOutCubic(t, b, c, d) {&#13;
    return c * ((t = t / d - 1) * t * t + 1) + b;&#13;
  }&#13;
&#13;
  /**&#13;
   * Cubic easing in and out&#13;
   * @memberOf fabric.util.ease&#13;
   */&#13;
  function easeInOutCubic(t, b, c, d) {&#13;
    t /= d / 2;&#13;
    if (t &lt; 1) {&#13;
      return c / 2 * t * t * t + b;&#13;
    }&#13;
    return c / 2 * ((t -= 2) * t * t + 2) + b;&#13;
  }&#13;
&#13;
  /**&#13;
   * Quartic easing in&#13;
   * @memberOf fabric.util.ease&#13;
   */&#13;
  function easeInQuart(t, b, c, d) {&#13;
    return c * (t /= d) * t * t * t + b;&#13;
  }&#13;
&#13;
  /**&#13;
   * Quartic easing out&#13;
   * @memberOf fabric.util.ease&#13;
   */&#13;
  function easeOutQuart(t, b, c, d) {&#13;
    return -c * ((t = t / d - 1) * t * t * t - 1) + b;&#13;
  }&#13;
&#13;
  /**&#13;
   * Quartic easing in and out&#13;
   * @memberOf fabric.util.ease&#13;
   */&#13;
  function easeInOutQuart(t, b, c, d) {&#13;
    t /= d / 2;&#13;
    if (t &lt; 1) {&#13;
      return c / 2 * t * t * t * t + b;&#13;
    }&#13;
    return -c / 2 * ((t -= 2) * t * t * t - 2) + b;&#13;
  }&#13;
&#13;
  /**&#13;
   * Quintic easing in&#13;
   * @memberOf fabric.util.ease&#13;
   */&#13;
  function easeInQuint(t, b, c, d) {&#13;
    return c * (t /= d) * t * t * t * t + b;&#13;
  }&#13;
&#13;
  /**&#13;
   * Quintic easing out&#13;
   * @memberOf fabric.util.ease&#13;
   */&#13;
  function easeOutQuint(t, b, c, d) {&#13;
    return c * ((t = t / d - 1) * t * t * t * t + 1) + b;&#13;
  }&#13;
&#13;
  /**&#13;
   * Quintic easing in and out&#13;
   * @memberOf fabric.util.ease&#13;
   */&#13;
  function easeInOutQuint(t, b, c, d) {&#13;
    t /= d / 2;&#13;
    if (t &lt; 1) {&#13;
      return c / 2 * t * t * t * t * t + b;&#13;
    }&#13;
    return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;&#13;
  }&#13;
&#13;
  /**&#13;
   * Sinusoidal easing in&#13;
   * @memberOf fabric.util.ease&#13;
   */&#13;
  function easeInSine(t, b, c, d) {&#13;
    return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;&#13;
  }&#13;
&#13;
  /**&#13;
   * Sinusoidal easing out&#13;
   * @memberOf fabric.util.ease&#13;
   */&#13;
  function easeOutSine(t, b, c, d) {&#13;
    return c * Math.sin(t / d * (Math.PI / 2)) + b;&#13;
  }&#13;
&#13;
  /**&#13;
   * Sinusoidal easing in and out&#13;
   * @memberOf fabric.util.ease&#13;
   */&#13;
  function easeInOutSine(t, b, c, d) {&#13;
    return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;&#13;
  }&#13;
&#13;
  /**&#13;
   * Exponential easing in&#13;
   * @memberOf fabric.util.ease&#13;
   */&#13;
  function easeInExpo(t, b, c, d) {&#13;
    return (t === 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;&#13;
  }&#13;
&#13;
  /**&#13;
   * Exponential easing out&#13;
   * @memberOf fabric.util.ease&#13;
   */&#13;
  function easeOutExpo(t, b, c, d) {&#13;
    return (t === d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;&#13;
  }&#13;
&#13;
  /**&#13;
   * Exponential easing in and out&#13;
   * @memberOf fabric.util.ease&#13;
   */&#13;
  function easeInOutExpo(t, b, c, d) {&#13;
    if (t === 0) {&#13;
      return b;&#13;
    }&#13;
    if (t === d) {&#13;
      return b + c;&#13;
    }&#13;
    t /= d / 2;&#13;
    if (t &lt; 1) {&#13;
      return c / 2 * Math.pow(2, 10 * (t - 1)) + b;&#13;
    }&#13;
    return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;&#13;
  }&#13;
&#13;
  /**&#13;
   * Circular easing in&#13;
   * @memberOf fabric.util.ease&#13;
   */&#13;
  function easeInCirc(t, b, c, d) {&#13;
    return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;&#13;
  }&#13;
&#13;
  /**&#13;
   * Circular easing out&#13;
   * @memberOf fabric.util.ease&#13;
   */&#13;
  function easeOutCirc(t, b, c, d) {&#13;
    return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;&#13;
  }&#13;
&#13;
  /**&#13;
   * Circular easing in and out&#13;
   * @memberOf fabric.util.ease&#13;
   */&#13;
  function easeInOutCirc(t, b, c, d) {&#13;
    t /= d / 2;&#13;
    if (t &lt; 1) {&#13;
      return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;&#13;
    }&#13;
    return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;&#13;
  }&#13;
&#13;
  /**&#13;
   * Elastic easing in&#13;
   * @memberOf fabric.util.ease&#13;
   */&#13;
  function easeInElastic(t, b, c, d) {&#13;
    var s = 1.70158, p = 0, a = c;&#13;
    if (t === 0) {&#13;
      return b;&#13;
    }&#13;
    t /= d;&#13;
    if (t === 1) {&#13;
      return b + c;&#13;
    }&#13;
    if (!p) {&#13;
      p = d * 0.3;&#13;
    }&#13;
    var opts = normalize(a, c, p, s);&#13;
    return -elastic(opts, t, d) + b;&#13;
  }&#13;
&#13;
  /**&#13;
   * Elastic easing out&#13;
   * @memberOf fabric.util.ease&#13;
   */&#13;
  function easeOutElastic(t, b, c, d) {&#13;
    var s = 1.70158, p = 0, a = c;&#13;
    if (t === 0) {&#13;
      return b;&#13;
    }&#13;
    t /= d;&#13;
    if (t === 1) {&#13;
      return b + c;&#13;
    }&#13;
    if (!p) {&#13;
      p = d * 0.3;&#13;
    }&#13;
    var opts = normalize(a, c, p, s);&#13;
    return opts.a * Math.pow(2, -10 * t) * Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p ) + opts.c + b;&#13;
  }&#13;
&#13;
  /**&#13;
   * Elastic easing in and out&#13;
   * @memberOf fabric.util.ease&#13;
   */&#13;
  function easeInOutElastic(t, b, c, d) {&#13;
    var s = 1.70158, p = 0, a = c;&#13;
    if (t === 0) {&#13;
      return b;&#13;
    }&#13;
    t /= d / 2;&#13;
    if (t === 2) {&#13;
      return b + c;&#13;
    }&#13;
    if (!p) {&#13;
      p = d * (0.3 * 1.5);&#13;
    }&#13;
    var opts = normalize(a, c, p, s);&#13;
    if (t &lt; 1) {&#13;
      return -0.5 * elastic(opts, t, d) + b;&#13;
    }&#13;
    return opts.a * Math.pow(2, -10 * (t -= 1)) *&#13;
      Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p ) * 0.5 + opts.c + b;&#13;
  }&#13;
&#13;
  /**&#13;
   * Backwards easing in&#13;
   * @memberOf fabric.util.ease&#13;
   */&#13;
  function easeInBack(t, b, c, d, s) {&#13;
    if (s === undefined) {&#13;
      s = 1.70158;&#13;
    }&#13;
    return c * (t /= d) * t * ((s + 1) * t - s) + b;&#13;
  }&#13;
&#13;
  /**&#13;
   * Backwards easing out&#13;
   * @memberOf fabric.util.ease&#13;
   */&#13;
  function easeOutBack(t, b, c, d, s) {&#13;
    if (s === undefined) {&#13;
      s = 1.70158;&#13;
    }&#13;
    return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;&#13;
  }&#13;
&#13;
  /**&#13;
   * Backwards easing in and out&#13;
   * @memberOf fabric.util.ease&#13;
   */&#13;
  function easeInOutBack(t, b, c, d, s) {&#13;
    if (s === undefined) {&#13;
      s = 1.70158;&#13;
    }&#13;
    t /= d / 2;&#13;
    if (t &lt; 1) {&#13;
      return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;&#13;
    }&#13;
    return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;&#13;
  }&#13;
&#13;
  /**&#13;
   * Bouncing easing in&#13;
   * @memberOf fabric.util.ease&#13;
   */&#13;
  function easeInBounce(t, b, c, d) {&#13;
    return c - easeOutBounce (d - t, 0, c, d) + b;&#13;
  }&#13;
&#13;
  /**&#13;
   * Bouncing easing out&#13;
   * @memberOf fabric.util.ease&#13;
   */&#13;
  function easeOutBounce(t, b, c, d) {&#13;
    if ((t /= d) &lt; (1 / 2.75)) {&#13;
      return c * (7.5625 * t * t) + b;&#13;
    }&#13;
    else if (t &lt; (2 / 2.75)) {&#13;
      return c * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75) + b;&#13;
    }&#13;
    else if (t &lt; (2.5 / 2.75)) {&#13;
      return c * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375) + b;&#13;
    }&#13;
    else {&#13;
      return c * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375) + b;&#13;
    }&#13;
  }&#13;
&#13;
  /**&#13;
   * Bouncing easing in and out&#13;
   * @memberOf fabric.util.ease&#13;
   */&#13;
  function easeInOutBounce(t, b, c, d) {&#13;
    if (t &lt; d / 2) {&#13;
      return easeInBounce (t * 2, 0, c, d) * 0.5 + b;&#13;
    }&#13;
    return easeOutBounce(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;&#13;
  }&#13;
&#13;
  /**&#13;
   * Easing functions&#13;
   * See &lt;a href="http://gizma.com/easing/"&gt;Easing Equations by Robert Penner&lt;/a&gt;&#13;
   * @namespace fabric.util.ease&#13;
   */&#13;
  fabric.util.ease = {&#13;
&#13;
    /**&#13;
     * Quadratic easing in&#13;
     * @memberOf fabric.util.ease&#13;
     */&#13;
    easeInQuad: function(t, b, c, d) {&#13;
      return c * (t /= d) * t + b;&#13;
    },&#13;
&#13;
    /**&#13;
     * Quadratic easing out&#13;
     * @memberOf fabric.util.ease&#13;
     */&#13;
    easeOutQuad: function(t, b, c, d) {&#13;
      return -c * (t /= d) * (t - 2) + b;&#13;
    },&#13;
&#13;
    /**&#13;
     * Quadratic easing in and out&#13;
     * @memberOf fabric.util.ease&#13;
     */&#13;
    easeInOutQuad: function(t, b, c, d) {&#13;
      t /= (d / 2);&#13;
      if (t &lt; 1) {&#13;
        return c / 2 * t * t + b;&#13;
      }&#13;
      return -c / 2 * ((--t) * (t - 2) - 1) + b;&#13;
    },&#13;
&#13;
    /**&#13;
     * Cubic easing in&#13;
     * @memberOf fabric.util.ease&#13;
     */&#13;
    easeInCubic: function(t, b, c, d) {&#13;
      return c * (t /= d) * t * t + b;&#13;
    },&#13;
&#13;
    easeOutCubic: easeOutCubic,&#13;
    easeInOutCubic: easeInOutCubic,&#13;
    easeInQuart: easeInQuart,&#13;
    easeOutQuart: easeOutQuart,&#13;
    easeInOutQuart: easeInOutQuart,&#13;
    easeInQuint: easeInQuint,&#13;
    easeOutQuint: easeOutQuint,&#13;
    easeInOutQuint: easeInOutQuint,&#13;
    easeInSine: easeInSine,&#13;
    easeOutSine: easeOutSine,&#13;
    easeInOutSine: easeInOutSine,&#13;
    easeInExpo: easeInExpo,&#13;
    easeOutExpo: easeOutExpo,&#13;
    easeInOutExpo: easeInOutExpo,&#13;
    easeInCirc: easeInCirc,&#13;
    easeOutCirc: easeOutCirc,&#13;
    easeInOutCirc: easeInOutCirc,&#13;
    easeInElastic: easeInElastic,&#13;
    easeOutElastic: easeOutElastic,&#13;
    easeInOutElastic: easeInOutElastic,&#13;
    easeInBack: easeInBack,&#13;
    easeOutBack: easeOutBack,&#13;
    easeInOutBack: easeInOutBack,&#13;
    easeInBounce: easeInBounce,&#13;
    easeOutBounce: easeOutBounce,&#13;
    easeInOutBounce: easeInOutBounce&#13;
  };&#13;
&#13;
})();&#13;
&#13;
&#13;
(function(global) {&#13;
&#13;
  'use strict';&#13;
&#13;
  /**&#13;
   * @name fabric&#13;
   * @namespace&#13;
   */&#13;
&#13;
  var fabric = global.fabric || (global.fabric = { }),&#13;
      extend = fabric.util.object.extend,&#13;
      clone = fabric.util.object.clone,&#13;
      toFixed = fabric.util.toFixed,&#13;
      parseUnit = fabric.util.parseUnit,&#13;
      multiplyTransformMatrices = fabric.util.multiplyTransformMatrices,&#13;
&#13;
      svgValidTagNames = ['path', 'circle', 'polygon', 'polyline', 'ellipse', 'rect', 'line',&#13;
        'image', 'text', 'linearGradient', 'radialGradient', 'stop'],&#13;
      svgViewBoxElements = ['symbol', 'image', 'marker', 'pattern', 'view', 'svg'],&#13;
      svgInvalidAncestors = ['pattern', 'defs', 'symbol', 'metadata', 'clipPath', 'mask', 'desc'],&#13;
      svgValidParents = ['symbol', 'g', 'a', 'svg'],&#13;
&#13;
      attributesMap = {&#13;
        cx:                   'left',&#13;
        x:                    'left',&#13;
        r:                    'radius',&#13;
        cy:                   'top',&#13;
        y:                    'top',&#13;
        display:              'visible',&#13;
        visibility:           'visible',&#13;
        transform:            'transformMatrix',&#13;
        'fill-opacity':       'fillOpacity',&#13;
        'fill-rule':          'fillRule',&#13;
        'font-family':        'fontFamily',&#13;
        'font-size':          'fontSize',&#13;
        'font-style':         'fontStyle',&#13;
        'font-weight':        'fontWeight',&#13;
        'paint-order':        'paintFirst',&#13;
        'stroke-dasharray':   'strokeDashArray',&#13;
        'stroke-linecap':     'strokeLineCap',&#13;
        'stroke-linejoin':    'strokeLineJoin',&#13;
        'stroke-miterlimit':  'strokeMiterLimit',&#13;
        'stroke-opacity':     'strokeOpacity',&#13;
        'stroke-width':       'strokeWidth',&#13;
        'text-decoration':    'textDecoration',&#13;
        'text-anchor':        'textAnchor',&#13;
        opacity:              'opacity'&#13;
      },&#13;
&#13;
      colorAttributes = {&#13;
        stroke: 'strokeOpacity',&#13;
        fill:   'fillOpacity'&#13;
      };&#13;
&#13;
  fabric.svgValidTagNamesRegEx = getSvgRegex(svgValidTagNames);&#13;
  fabric.svgViewBoxElementsRegEx = getSvgRegex(svgViewBoxElements);&#13;
  fabric.svgInvalidAncestorsRegEx = getSvgRegex(svgInvalidAncestors);&#13;
  fabric.svgValidParentsRegEx = getSvgRegex(svgValidParents);&#13;
&#13;
  fabric.cssRules = { };&#13;
  fabric.gradientDefs = { };&#13;
&#13;
  function normalizeAttr(attr) {&#13;
    // transform attribute names&#13;
    if (attr in attributesMap) {&#13;
      return attributesMap[attr];&#13;
    }&#13;
    return attr;&#13;
  }&#13;
&#13;
  function normalizeValue(attr, value, parentAttributes, fontSize) {&#13;
    var isArray = Object.prototype.toString.call(value) === '[object Array]',&#13;
        parsed;&#13;
&#13;
    if ((attr === 'fill' || attr === 'stroke') &amp;&amp; value === 'none') {&#13;
      value = '';&#13;
    }&#13;
    else if (attr === 'strokeDashArray') {&#13;
      if (value === 'none') {&#13;
        value = null;&#13;
      }&#13;
      else {&#13;
        value = value.replace(/,/g, ' ').split(/\s+/).map(function(n) {&#13;
          return parseFloat(n);&#13;
        });&#13;
      }&#13;
    }&#13;
    else if (attr === 'transformMatrix') {&#13;
      if (parentAttributes &amp;&amp; parentAttributes.transformMatrix) {&#13;
        value = multiplyTransformMatrices(&#13;
          parentAttributes.transformMatrix, fabric.parseTransformAttribute(value));&#13;
      }&#13;
      else {&#13;
        value = fabric.parseTransformAttribute(value);&#13;
      }&#13;
    }&#13;
    else if (attr === 'visible') {&#13;
      value = value !== 'none' &amp;&amp; value !== 'hidden';&#13;
      // display=none on parent element always takes precedence over child element&#13;
      if (parentAttributes &amp;&amp; parentAttributes.visible === false) {&#13;
        value = false;&#13;
      }&#13;
    }&#13;
    else if (attr === 'opacity') {&#13;
      value = parseFloat(value);&#13;
      if (parentAttributes &amp;&amp; typeof parentAttributes.opacity !== 'undefined') {&#13;
        value *= parentAttributes.opacity;&#13;
      }&#13;
    }&#13;
    else if (attr === 'textAnchor' /* text-anchor */) {&#13;
      value = value === 'start' ? 'left' : value === 'end' ? 'right' : 'center';&#13;
    }&#13;
    else if (attr === 'paintFirst') {&#13;
      var fillIndex = value.indexOf('fill');&#13;
      var strokeIndex = value.indexOf('stroke');&#13;
      var value = 'fill';&#13;
      if (fillIndex &gt; -1 &amp;&amp; strokeIndex &gt; -1 &amp;&amp; strokeIndex &lt; fillIndex) {&#13;
        value = 'stroke';&#13;
      }&#13;
      else if (fillIndex === -1 &amp;&amp; strokeIndex &gt; -1) {&#13;
        value = 'stroke';&#13;
      }&#13;
    }&#13;
    else {&#13;
      parsed = isArray ? value.map(parseUnit) : parseUnit(value, fontSize);&#13;
    }&#13;
&#13;
    return (!isArray &amp;&amp; isNaN(parsed) ? value : parsed);&#13;
  }&#13;
&#13;
  /**&#13;
    * @private&#13;
    */&#13;
  function getSvgRegex(arr) {&#13;
    return new RegExp('^(' + arr.join('|') + ')\\b', 'i');&#13;
  }&#13;
&#13;
  /**&#13;
   * @private&#13;
   * @param {Object} attributes Array of attributes to parse&#13;
   */&#13;
  function _setStrokeFillOpacity(attributes) {&#13;
    for (var attr in colorAttributes) {&#13;
&#13;
      if (typeof attributes[colorAttributes[attr]] === 'undefined' || attributes[attr] === '') {&#13;
        continue;&#13;
      }&#13;
&#13;
      if (typeof attributes[attr] === 'undefined') {&#13;
        if (!fabric.Object.prototype[attr]) {&#13;
          continue;&#13;
        }&#13;
        attributes[attr] = fabric.Object.prototype[attr];&#13;
      }&#13;
&#13;
      if (attributes[attr].indexOf('url(') === 0) {&#13;
        continue;&#13;
      }&#13;
&#13;
      var color = new fabric.Color(attributes[attr]);&#13;
      attributes[attr] = color.setAlpha(toFixed(color.getAlpha() * attributes[colorAttributes[attr]], 2)).toRgba();&#13;
    }&#13;
    return attributes;&#13;
  }&#13;
&#13;
  /**&#13;
   * @private&#13;
   */&#13;
  function _getMultipleNodes(doc, nodeNames) {&#13;
    var nodeName, nodeArray = [], nodeList, i, len;&#13;
    for (i = 0, len = nodeNames.length; i &lt; len; i++) {&#13;
      nodeName = nodeNames[i];&#13;
      nodeList = doc.getElementsByTagName(nodeName);&#13;
      nodeArray = nodeArray.concat(Array.prototype.slice.call(nodeList));&#13;
    }&#13;
    return nodeArray;&#13;
  }&#13;
&#13;
  /**&#13;
   * Parses "transform" attribute, returning an array of values&#13;
   * @static&#13;
   * @function&#13;
   * @memberOf fabric&#13;
   * @param {String} attributeValue String containing attribute value&#13;
   * @return {Array} Array of 6 elements representing transformation matrix&#13;
   */&#13;
  fabric.parseTransformAttribute = (function() {&#13;
    function rotateMatrix(matrix, args) {&#13;
      var cos = Math.cos(args[0]), sin = Math.sin(args[0]),&#13;
          x = 0, y = 0;&#13;
      if (args.length === 3) {&#13;
        x = args[1];&#13;
        y = args[2];&#13;
      }&#13;
&#13;
      matrix[0] = cos;&#13;
      matrix[1] = sin;&#13;
      matrix[2] = -sin;&#13;
      matrix[3] = cos;&#13;
      matrix[4] = x - (cos * x - sin * y);&#13;
      matrix[5] = y - (sin * x + cos * y);&#13;
    }&#13;
&#13;
    function scaleMatrix(matrix, args) {&#13;
      var multiplierX = args[0],&#13;
          multiplierY = (args.length === 2) ? args[1] : args[0];&#13;
&#13;
      matrix[0] = multiplierX;&#13;
      matrix[3] = multiplierY;&#13;
    }&#13;
&#13;
    function skewMatrix(matrix, args, pos) {&#13;
      matrix[pos] = Math.tan(fabric.util.degreesToRadians(args[0]));&#13;
    }&#13;
&#13;
    function translateMatrix(matrix, args) {&#13;
      matrix[4] = args[0];&#13;
      if (args.length === 2) {&#13;
        matrix[5] = args[1];&#13;
      }&#13;
    }&#13;
&#13;
    // identity matrix&#13;
    var iMatrix = [&#13;
          1, // a&#13;
          0, // b&#13;
          0, // c&#13;
          1, // d&#13;
          0, // e&#13;
          0  // f&#13;
        ],&#13;
&#13;
        // == begin transform regexp&#13;
        number = fabric.reNum,&#13;
&#13;
        commaWsp = '(?:\\s+,?\\s*|,\\s*)',&#13;
&#13;
        skewX = '(?:(skewX)\\s*\\(\\s*(' + number + ')\\s*\\))',&#13;
&#13;
        skewY = '(?:(skewY)\\s*\\(\\s*(' + number + ')\\s*\\))',&#13;
&#13;
        rotate = '(?:(rotate)\\s*\\(\\s*(' + number + ')(?:' +&#13;
                    commaWsp + '(' + number + ')' +&#13;
                    commaWsp + '(' + number + '))?\\s*\\))',&#13;
&#13;
        scale = '(?:(scale)\\s*\\(\\s*(' + number + ')(?:' +&#13;
                    commaWsp + '(' + number + '))?\\s*\\))',&#13;
&#13;
        translate = '(?:(translate)\\s*\\(\\s*(' + number + ')(?:' +&#13;
                    commaWsp + '(' + number + '))?\\s*\\))',&#13;
&#13;
        matrix = '(?:(matrix)\\s*\\(\\s*' +&#13;
                  '(' + number + ')' + commaWsp +&#13;
                  '(' + number + ')' + commaWsp +&#13;
                  '(' + number + ')' + commaWsp +&#13;
                  '(' + number + ')' + commaWsp +&#13;
                  '(' + number + ')' + commaWsp +&#13;
                  '(' + number + ')' +&#13;
                  '\\s*\\))',&#13;
&#13;
        transform = '(?:' +&#13;
                    matrix + '|' +&#13;
                    translate + '|' +&#13;
                    scale + '|' +&#13;
                    rotate + '|' +&#13;
                    skewX + '|' +&#13;
                    skewY +&#13;
                    ')',&#13;
&#13;
        transforms = '(?:' + transform + '(?:' + commaWsp + '*' + transform + ')*' + ')',&#13;
&#13;
        transformList = '^\\s*(?:' + transforms + '?)\\s*$',&#13;
&#13;
        // http://www.w3.org/TR/SVG/coords.html#TransformAttribute&#13;
        reTransformList = new RegExp(transformList),&#13;
        // == end transform regexp&#13;
&#13;
        reTransform = new RegExp(transform, 'g');&#13;
&#13;
    return function(attributeValue) {&#13;
&#13;
      // start with identity matrix&#13;
      var matrix = iMatrix.concat(),&#13;
          matrices = [];&#13;
&#13;
      // return if no argument was given or&#13;
      // an argument does not match transform attribute regexp&#13;
      if (!attributeValue || (attributeValue &amp;&amp; !reTransformList.test(attributeValue))) {&#13;
        return matrix;&#13;
      }&#13;
&#13;
      attributeValue.replace(reTransform, function(match) {&#13;
&#13;
        var m = new RegExp(transform).exec(match).filter(function (match) {&#13;
              // match !== '' &amp;&amp; match != null&#13;
              return (!!match);&#13;
            }),&#13;
            operation = m[1],&#13;
            args = m.slice(2).map(parseFloat);&#13;
&#13;
        switch (operation) {&#13;
          case 'translate':&#13;
            translateMatrix(matrix, args);&#13;
            break;&#13;
          case 'rotate':&#13;
            args[0] = fabric.util.degreesToRadians(args[0]);&#13;
            rotateMatrix(matrix, args);&#13;
            break;&#13;
          case 'scale':&#13;
            scaleMatrix(matrix, args);&#13;
            break;&#13;
          case 'skewX':&#13;
            skewMatrix(matrix, args, 2);&#13;
            break;&#13;
          case 'skewY':&#13;
            skewMatrix(matrix, args, 1);&#13;
            break;&#13;
          case 'matrix':&#13;
            matrix = args;&#13;
            break;&#13;
        }&#13;
&#13;
        // snapshot current matrix into matrices array&#13;
        matrices.push(matrix.concat());&#13;
        // reset&#13;
        matrix = iMatrix.concat();&#13;
      });&#13;
&#13;
      var combinedMatrix = matrices[0];&#13;
      while (matrices.length &gt; 1) {&#13;
        matrices.shift();&#13;
        combinedMatrix = fabric.util.multiplyTransformMatrices(combinedMatrix, matrices[0]);&#13;
      }&#13;
      return combinedMatrix;&#13;
    };&#13;
  })();&#13;
&#13;
  /**&#13;
   * @private&#13;
   */&#13;
  function parseStyleString(style, oStyle) {&#13;
    var attr, value;&#13;
    style.replace(/;\s*$/, '').split(';').forEach(function (chunk) {&#13;
      var pair = chunk.split(':');&#13;
&#13;
      attr = pair[0].trim().toLowerCase();&#13;
      value =  pair[1].trim();&#13;
&#13;
      oStyle[attr] = value;&#13;
    });&#13;
  }&#13;
&#13;
  /**&#13;
   * @private&#13;
   */&#13;
  function parseStyleObject(style, oStyle) {&#13;
    var attr, value;&#13;
    for (var prop in style) {&#13;
      if (typeof style[prop] === 'undefined') {&#13;
        continue;&#13;
      }&#13;
&#13;
      attr = prop.toLowerCase();&#13;
      value = style[prop];&#13;
&#13;
      oStyle[attr] = value;&#13;
    }&#13;
  }&#13;
&#13;
  /**&#13;
   * @private&#13;
   */&#13;
  function getGlobalStylesForElement(element, svgUid) {&#13;
    var styles = { };&#13;
    for (var rule in fabric.cssRules[svgUid]) {&#13;
      if (elementMatchesRule(element, rule.split(' '))) {&#13;
        for (var property in fabric.cssRules[svgUid][rule]) {&#13;
          styles[property] = fabric.cssRules[svgUid][rule][property];&#13;
        }&#13;
      }&#13;
    }&#13;
    return styles;&#13;
  }&#13;
&#13;
  /**&#13;
   * @private&#13;
   */&#13;
  function elementMatchesRule(element, selectors) {&#13;
    var firstMatching, parentMatching = true;&#13;
    //start from rightmost selector.&#13;
    firstMatching = selectorMatches(element, selectors.pop());&#13;
    if (firstMatching &amp;&amp; selectors.length) {&#13;
      parentMatching = doesSomeParentMatch(element, selectors);&#13;
    }&#13;
    return firstMatching &amp;&amp; parentMatching &amp;&amp; (selectors.length === 0);&#13;
  }&#13;
&#13;
  function doesSomeParentMatch(element, selectors) {&#13;
    var selector, parentMatching = true;&#13;
    while (element.parentNode &amp;&amp; element.parentNode.nodeType === 1 &amp;&amp; selectors.length) {&#13;
      if (parentMatching) {&#13;
        selector = selectors.pop();&#13;
      }&#13;
      element = element.parentNode;&#13;
      parentMatching = selectorMatches(element, selector);&#13;
    }&#13;
    return selectors.length === 0;&#13;
  }&#13;
&#13;
  /**&#13;
   * @private&#13;
   */&#13;
  function selectorMatches(element, selector) {&#13;
    var nodeName = element.nodeName,&#13;
        classNames = element.getAttribute('class'),&#13;
        id = element.getAttribute('id'), matcher, i;&#13;
    // i check if a selector matches slicing away part from it.&#13;
    // if i get empty string i should match&#13;
    matcher = new RegExp('^' + nodeName, 'i');&#13;
    selector = selector.replace(matcher, '');&#13;
    if (id &amp;&amp; selector.length) {&#13;
      matcher = new RegExp('#' + id + '(?![a-zA-Z\\-]+)', 'i');&#13;
      selector = selector.replace(matcher, '');&#13;
    }&#13;
    if (classNames &amp;&amp; selector.length) {&#13;
      classNames = classNames.split(' ');&#13;
      for (i = classNames.length; i--;) {&#13;
        matcher = new RegExp('\\.' + classNames[i] + '(?![a-zA-Z\\-]+)', 'i');&#13;
        selector = selector.replace(matcher, '');&#13;
      }&#13;
    }&#13;
    return selector.length === 0;&#13;
  }&#13;
&#13;
  /**&#13;
   * @private&#13;
   * to support IE8 missing getElementById on SVGdocument&#13;
   */&#13;
  function elementById(doc, id) {&#13;
    var el;&#13;
    doc.getElementById &amp;&amp; (el = doc.getElementById(id));&#13;
    if (el) {&#13;
      return el;&#13;
    }&#13;
    var node, i, len, nodelist = doc.getElementsByTagName('*');&#13;
    for (i = 0, len = nodelist.length; i &lt; len; i++) {&#13;
      node = nodelist[i];&#13;
      if (id === node.getAttribute('id')) {&#13;
        return node;&#13;
      }&#13;
    }&#13;
  }&#13;
&#13;
  /**&#13;
   * @private&#13;
   */&#13;
  function parseUseDirectives(doc) {&#13;
    var nodelist = _getMultipleNodes(doc, ['use', 'svg:use']), i = 0;&#13;
&#13;
    while (nodelist.length &amp;&amp; i &lt; nodelist.length) {&#13;
      var el = nodelist[i],&#13;
          xlink = el.getAttribute('xlink:href').substr(1),&#13;
          x = el.getAttribute('x') || 0,&#13;
          y = el.getAttribute('y') || 0,&#13;
          el2 = elementById(doc, xlink).cloneNode(true),&#13;
          currentTrans = (el2.getAttribute('transform') || '') + ' translate(' + x + ', ' + y + ')',&#13;
          parentNode, oldLength = nodelist.length, attr, j, attrs, len;&#13;
&#13;
      applyViewboxTransform(el2);&#13;
      if (/^svg$/i.test(el2.nodeName)) {&#13;
        var el3 = el2.ownerDocument.createElement('g');&#13;
        for (j = 0, attrs = el2.attributes, len = attrs.length; j &lt; len; j++) {&#13;
          attr = attrs.item(j);&#13;
          el3.setAttribute(attr.nodeName, attr.nodeValue);&#13;
        }&#13;
        // el2.firstChild != null&#13;
        while (el2.firstChild) {&#13;
          el3.appendChild(el2.firstChild);&#13;
        }&#13;
        el2 = el3;&#13;
      }&#13;
&#13;
      for (j = 0, attrs = el.attributes, len = attrs.length; j &lt; len; j++) {&#13;
        attr = attrs.item(j);&#13;
        if (attr.nodeName === 'x' || attr.nodeName === 'y' || attr.nodeName === 'xlink:href') {&#13;
          continue;&#13;
        }&#13;
&#13;
        if (attr.nodeName === 'transform') {&#13;
          currentTrans = attr.nodeValue + ' ' + currentTrans;&#13;
        }&#13;
        else {&#13;
          el2.setAttribute(attr.nodeName, attr.nodeValue);&#13;
        }&#13;
      }&#13;
&#13;
      el2.setAttribute('transform', currentTrans);&#13;
      el2.setAttribute('instantiated_by_use', '1');&#13;
      el2.removeAttribute('id');&#13;
      parentNode = el.parentNode;&#13;
      parentNode.replaceChild(el2, el);&#13;
      // some browsers do not shorten nodelist after replaceChild (IE8)&#13;
      if (nodelist.length === oldLength) {&#13;
        i++;&#13;
      }&#13;
    }&#13;
  }&#13;
&#13;
  // http://www.w3.org/TR/SVG/coords.html#ViewBoxAttribute&#13;
  // matches, e.g.: +14.56e-12, etc.&#13;
  var reViewBoxAttrValue = new RegExp(&#13;
    '^' +&#13;
    '\\s*(' + fabric.reNum + '+)\\s*,?' +&#13;
    '\\s*(' + fabric.reNum + '+)\\s*,?' +&#13;
    '\\s*(' + fabric.reNum + '+)\\s*,?' +&#13;
    '\\s*(' + fabric.reNum + '+)\\s*' +&#13;
    '$'&#13;
  );&#13;
&#13;
  /**&#13;
   * Add a &lt;g&gt; element that envelop all child elements and makes the viewbox transformMatrix descend on all elements&#13;
   */&#13;
  function applyViewboxTransform(element) {&#13;
&#13;
    var viewBoxAttr = element.getAttribute('viewBox'),&#13;
        scaleX = 1,&#13;
        scaleY = 1,&#13;
        minX = 0,&#13;
        minY = 0,&#13;
        viewBoxWidth, viewBoxHeight, matrix, el,&#13;
        widthAttr = element.getAttribute('width'),&#13;
        heightAttr = element.getAttribute('height'),&#13;
        x = element.getAttribute('x') || 0,&#13;
        y = element.getAttribute('y') || 0,&#13;
        preserveAspectRatio = element.getAttribute('preserveAspectRatio') || '',&#13;
        missingViewBox = (!viewBoxAttr || !fabric.svgViewBoxElementsRegEx.test(element.nodeName)&#13;
                           || !(viewBoxAttr = viewBoxAttr.match(reViewBoxAttrValue))),&#13;
        missingDimAttr = (!widthAttr || !heightAttr || widthAttr === '100%' || heightAttr === '100%'),&#13;
        toBeParsed = missingViewBox &amp;&amp; missingDimAttr,&#13;
        parsedDim = { }, translateMatrix = '';&#13;
&#13;
    parsedDim.width = 0;&#13;
    parsedDim.height = 0;&#13;
    parsedDim.toBeParsed = toBeParsed;&#13;
&#13;
    if (toBeParsed) {&#13;
      return parsedDim;&#13;
    }&#13;
&#13;
    if (missingViewBox) {&#13;
      parsedDim.width = parseUnit(widthAttr);&#13;
      parsedDim.height = parseUnit(heightAttr);&#13;
      return parsedDim;&#13;
    }&#13;
&#13;
    minX = -parseFloat(viewBoxAttr[1]);&#13;
    minY = -parseFloat(viewBoxAttr[2]);&#13;
    viewBoxWidth = parseFloat(viewBoxAttr[3]);&#13;
    viewBoxHeight = parseFloat(viewBoxAttr[4]);&#13;
&#13;
    if (!missingDimAttr) {&#13;
      parsedDim.width = parseUnit(widthAttr);&#13;
      parsedDim.height = parseUnit(heightAttr);&#13;
      scaleX = parsedDim.width / viewBoxWidth;&#13;
      scaleY = parsedDim.height / viewBoxHeight;&#13;
    }&#13;
    else {&#13;
      parsedDim.width = viewBoxWidth;&#13;
      parsedDim.height = viewBoxHeight;&#13;
    }&#13;
&#13;
    // default is to preserve aspect ratio&#13;
    preserveAspectRatio = fabric.util.parsePreserveAspectRatioAttribute(preserveAspectRatio);&#13;
    if (preserveAspectRatio.alignX !== 'none') {&#13;
      //translate all container for the effect of Mid, Min, Max&#13;
      scaleY = scaleX = (scaleX &gt; scaleY ? scaleY : scaleX);&#13;
    }&#13;
&#13;
    if (scaleX === 1 &amp;&amp; scaleY === 1 &amp;&amp; minX === 0 &amp;&amp; minY === 0 &amp;&amp; x === 0 &amp;&amp; y === 0) {&#13;
      return parsedDim;&#13;
    }&#13;
&#13;
    if (x || y) {&#13;
      translateMatrix = ' translate(' + parseUnit(x) + ' ' + parseUnit(y) + ') ';&#13;
    }&#13;
&#13;
    matrix = translateMatrix + ' matrix(' + scaleX +&#13;
                  ' 0' +&#13;
                  ' 0 ' +&#13;
                  scaleY + ' ' +&#13;
                  (minX * scaleX) + ' ' +&#13;
                  (minY * scaleY) + ') ';&#13;
&#13;
    if (element.nodeName === 'svg') {&#13;
      el = element.ownerDocument.createElement('g');&#13;
      // element.firstChild != null&#13;
      while (element.firstChild) {&#13;
        el.appendChild(element.firstChild);&#13;
      }&#13;
      element.appendChild(el);&#13;
    }&#13;
    else {&#13;
      el = element;&#13;
      matrix = el.getAttribute('transform') + matrix;&#13;
    }&#13;
&#13;
    el.setAttribute('transform', matrix);&#13;
    return parsedDim;&#13;
  }&#13;
&#13;
  function hasAncestorWithNodeName(element, nodeName) {&#13;
    while (element &amp;&amp; (element = element.parentNode)) {&#13;
      if (element.nodeName &amp;&amp; nodeName.test(element.nodeName.replace('svg:', ''))&#13;
        &amp;&amp; !element.getAttribute('instantiated_by_use')) {&#13;
        return true;&#13;
      }&#13;
    }&#13;
    return false;&#13;
  }&#13;
&#13;
  /**&#13;
   * Parses an SVG document, converts it to an array of corresponding fabric.* instances and passes them to a callback&#13;
   * @static&#13;
   * @function&#13;
   * @memberOf fabric&#13;
   * @param {SVGDocument} doc SVG document to parse&#13;
   * @param {Function} callback Callback to call when parsing is finished;&#13;
   * It's being passed an array of elements (parsed from a document).&#13;
   * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.&#13;
   * @param {Object} [parsingOptions] options for parsing document&#13;
   * @param {String} [parsingOptions.crossOrigin] crossOrigin settings&#13;
   */&#13;
  fabric.parseSVGDocument = function(doc, callback, reviver, parsingOptions) {&#13;
    if (!doc) {&#13;
      return;&#13;
    }&#13;
&#13;
    parseUseDirectives(doc);&#13;
&#13;
    var svgUid =  fabric.Object.__uid++, i, len,&#13;
        options = applyViewboxTransform(doc),&#13;
        descendants = fabric.util.toArray(doc.getElementsByTagName('*'));&#13;
    options.crossOrigin = parsingOptions &amp;&amp; parsingOptions.crossOrigin;&#13;
    options.svgUid = svgUid;&#13;
&#13;
    if (descendants.length === 0 &amp;&amp; fabric.isLikelyNode) {&#13;
      // we're likely in node, where "o3-xml" library fails to gEBTN("*")&#13;
      // https://github.com/ajaxorg/node-o3-xml/issues/21&#13;
      descendants = doc.selectNodes('//*[name(.)!="svg"]');&#13;
      var arr = [];&#13;
      for (i = 0, len = descendants.length; i &lt; len; i++) {&#13;
        arr[i] = descendants[i];&#13;
      }&#13;
      descendants = arr;&#13;
    }&#13;
&#13;
    var elements = descendants.filter(function(el) {&#13;
      applyViewboxTransform(el);&#13;
      return fabric.svgValidTagNamesRegEx.test(el.nodeName.replace('svg:', '')) &amp;&amp;&#13;
            !hasAncestorWithNodeName(el, fabric.svgInvalidAncestorsRegEx); // http://www.w3.org/TR/SVG/struct.html#DefsElement&#13;
    });&#13;
&#13;
    if (!elements || (elements &amp;&amp; !elements.length)) {&#13;
      callback &amp;&amp; callback([], {});&#13;
      return;&#13;
    }&#13;
&#13;
    fabric.gradientDefs[svgUid] = fabric.getGradientDefs(doc);&#13;
    fabric.cssRules[svgUid] = fabric.getCSSRules(doc);&#13;
    // Precedence of rules:   style &gt; class &gt; attribute&#13;
    fabric.parseElements(elements, function(instances, elements) {&#13;
      if (callback) {&#13;
        callback(instances, options, elements, descendants);&#13;
      }&#13;
    }, clone(options), reviver, parsingOptions);&#13;
  };&#13;
&#13;
  var reFontDeclaration = new RegExp(&#13;
    '(normal|italic)?\\s*(normal|small-caps)?\\s*' +&#13;
    '(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\s*(' +&#13;
      fabric.reNum +&#13;
    '(?:px|cm|mm|em|pt|pc|in)*)(?:\\/(normal|' + fabric.reNum + '))?\\s+(.*)');&#13;
&#13;
  extend(fabric, {&#13;
    /**&#13;
     * Parses a short font declaration, building adding its properties to a style object&#13;
     * @static&#13;
     * @function&#13;
     * @memberOf fabric&#13;
     * @param {String} value font declaration&#13;
     * @param {Object} oStyle definition&#13;
     */&#13;
    parseFontDeclaration: function(value, oStyle) {&#13;
      var match = value.match(reFontDeclaration);&#13;
&#13;
      if (!match) {&#13;
        return;&#13;
      }&#13;
      var fontStyle = match[1],&#13;
          // font variant is not used&#13;
          // fontVariant = match[2],&#13;
          fontWeight = match[3],&#13;
          fontSize = match[4],&#13;
          lineHeight = match[5],&#13;
          fontFamily = match[6];&#13;
&#13;
      if (fontStyle) {&#13;
        oStyle.fontStyle = fontStyle;&#13;
      }&#13;
      if (fontWeight) {&#13;
        oStyle.fontWeight = isNaN(parseFloat(fontWeight)) ? fontWeight : parseFloat(fontWeight);&#13;
      }&#13;
      if (fontSize) {&#13;
        oStyle.fontSize = parseUnit(fontSize);&#13;
      }&#13;
      if (fontFamily) {&#13;
        oStyle.fontFamily = fontFamily;&#13;
      }&#13;
      if (lineHeight) {&#13;
        oStyle.lineHeight = lineHeight === 'normal' ? 1 : lineHeight;&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Parses an SVG document, returning all of the gradient declarations found in it&#13;
     * @static&#13;
     * @function&#13;
     * @memberOf fabric&#13;
     * @param {SVGDocument} doc SVG document to parse&#13;
     * @return {Object} Gradient definitions; key corresponds to element id, value -- to gradient definition element&#13;
     */&#13;
    getGradientDefs: function(doc) {&#13;
      var tagArray = [&#13;
            'linearGradient',&#13;
            'radialGradient',&#13;
            'svg:linearGradient',&#13;
            'svg:radialGradient'],&#13;
          elList = _getMultipleNodes(doc, tagArray),&#13;
          el, j = 0, id, xlink,&#13;
          gradientDefs = { }, idsToXlinkMap = { };&#13;
&#13;
      j = elList.length;&#13;
&#13;
      while (j--) {&#13;
        el = elList[j];&#13;
        xlink = el.getAttribute('xlink:href');&#13;
        id = el.getAttribute('id');&#13;
        if (xlink) {&#13;
          idsToXlinkMap[id] = xlink.substr(1);&#13;
        }&#13;
        gradientDefs[id] = el;&#13;
      }&#13;
&#13;
      for (id in idsToXlinkMap) {&#13;
        var el2 = gradientDefs[idsToXlinkMap[id]].cloneNode(true);&#13;
        el = gradientDefs[id];&#13;
        while (el2.firstChild) {&#13;
          el.appendChild(el2.firstChild);&#13;
        }&#13;
      }&#13;
      return gradientDefs;&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns an object of attributes' name/value, given element and an array of attribute names;&#13;
     * Parses parent "g" nodes recursively upwards.&#13;
     * @static&#13;
     * @memberOf fabric&#13;
     * @param {DOMElement} element Element to parse&#13;
     * @param {Array} attributes Array of attributes to parse&#13;
     * @return {Object} object containing parsed attributes' names/values&#13;
     */&#13;
    parseAttributes: function(element, attributes, svgUid) {&#13;
&#13;
      if (!element) {&#13;
        return;&#13;
      }&#13;
&#13;
      var value,&#13;
          parentAttributes = { },&#13;
          fontSize;&#13;
&#13;
      if (typeof svgUid === 'undefined') {&#13;
        svgUid = element.getAttribute('svgUid');&#13;
      }&#13;
      // if there's a parent container (`g` or `a` or `symbol` node), parse its attributes recursively upwards&#13;
      if (element.parentNode &amp;&amp; fabric.svgValidParentsRegEx.test(element.parentNode.nodeName)) {&#13;
        parentAttributes = fabric.parseAttributes(element.parentNode, attributes, svgUid);&#13;
      }&#13;
      fontSize = (parentAttributes &amp;&amp; parentAttributes.fontSize ) ||&#13;
                 element.getAttribute('font-size') || fabric.Text.DEFAULT_SVG_FONT_SIZE;&#13;
&#13;
      var ownAttributes = attributes.reduce(function(memo, attr) {&#13;
        value = element.getAttribute(attr);&#13;
        if (value) { // eslint-disable-line&#13;
          memo[attr] = value;&#13;
        }&#13;
        return memo;&#13;
      }, { });&#13;
      // add values parsed from style, which take precedence over attributes&#13;
      // (see: http://www.w3.org/TR/SVG/styling.html#UsingPresentationAttributes)&#13;
      ownAttributes = extend(ownAttributes,&#13;
        extend(getGlobalStylesForElement(element, svgUid), fabric.parseStyleAttribute(element)));&#13;
&#13;
      var normalizedAttr, normalizedValue, normalizedStyle = {};&#13;
      for (var attr in ownAttributes) {&#13;
        normalizedAttr = normalizeAttr(attr);&#13;
        normalizedValue = normalizeValue(normalizedAttr, ownAttributes[attr], parentAttributes, fontSize);&#13;
        normalizedStyle[normalizedAttr] = normalizedValue;&#13;
      }&#13;
      if (normalizedStyle &amp;&amp; normalizedStyle.font) {&#13;
        fabric.parseFontDeclaration(normalizedStyle.font, normalizedStyle);&#13;
      }&#13;
      var mergedAttrs = extend(parentAttributes, normalizedStyle);&#13;
      return fabric.svgValidParentsRegEx.test(element.nodeName) ? mergedAttrs : _setStrokeFillOpacity(mergedAttrs);&#13;
    },&#13;
&#13;
    /**&#13;
     * Transforms an array of svg elements to corresponding fabric.* instances&#13;
     * @static&#13;
     * @memberOf fabric&#13;
     * @param {Array} elements Array of elements to parse&#13;
     * @param {Function} callback Being passed an array of fabric instances (transformed from SVG elements)&#13;
     * @param {Object} [options] Options object&#13;
     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.&#13;
     */&#13;
    parseElements: function(elements, callback, options, reviver, parsingOptions) {&#13;
      new fabric.ElementsParser(elements, callback, options, reviver, parsingOptions).parse();&#13;
    },&#13;
&#13;
    /**&#13;
     * Parses "style" attribute, retuning an object with values&#13;
     * @static&#13;
     * @memberOf fabric&#13;
     * @param {SVGElement} element Element to parse&#13;
     * @return {Object} Objects with values parsed from style attribute of an element&#13;
     */&#13;
    parseStyleAttribute: function(element) {&#13;
      var oStyle = { },&#13;
          style = element.getAttribute('style');&#13;
&#13;
      if (!style) {&#13;
        return oStyle;&#13;
      }&#13;
&#13;
      if (typeof style === 'string') {&#13;
        parseStyleString(style, oStyle);&#13;
      }&#13;
      else {&#13;
        parseStyleObject(style, oStyle);&#13;
      }&#13;
&#13;
      return oStyle;&#13;
    },&#13;
&#13;
    /**&#13;
     * Parses "points" attribute, returning an array of values&#13;
     * @static&#13;
     * @memberOf fabric&#13;
     * @param {String} points points attribute string&#13;
     * @return {Array} array of points&#13;
     */&#13;
    parsePointsAttribute: function(points) {&#13;
&#13;
      // points attribute is required and must not be empty&#13;
      if (!points) {&#13;
        return null;&#13;
      }&#13;
&#13;
      // replace commas with whitespace and remove bookending whitespace&#13;
      points = points.replace(/,/g, ' ').trim();&#13;
&#13;
      points = points.split(/\s+/);&#13;
      var parsedPoints = [], i, len;&#13;
&#13;
      for (i = 0, len = points.length; i &lt; len; i += 2) {&#13;
        parsedPoints.push({&#13;
          x: parseFloat(points[i]),&#13;
          y: parseFloat(points[i + 1])&#13;
        });&#13;
      }&#13;
&#13;
      // odd number of points is an error&#13;
      // if (parsedPoints.length % 2 !== 0) {&#13;
      //   return null;&#13;
      // }&#13;
&#13;
      return parsedPoints;&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns CSS rules for a given SVG document&#13;
     * @static&#13;
     * @function&#13;
     * @memberOf fabric&#13;
     * @param {SVGDocument} doc SVG document to parse&#13;
     * @return {Object} CSS rules of this document&#13;
     */&#13;
    getCSSRules: function(doc) {&#13;
      var styles = doc.getElementsByTagName('style'), i, len,&#13;
          allRules = { }, rules;&#13;
&#13;
      // very crude parsing of style contents&#13;
      for (i = 0, len = styles.length; i &lt; len; i++) {&#13;
        // IE9 doesn't support textContent, but provides text instead.&#13;
        var styleContents = styles[i].textContent || styles[i].text;&#13;
&#13;
        // remove comments&#13;
        styleContents = styleContents.replace(/\/\*[\s\S]*?\*\//g, '');&#13;
        if (styleContents.trim() === '') {&#13;
          continue;&#13;
        }&#13;
        rules = styleContents.match(/[^{]*\{[\s\S]*?\}/g);&#13;
        rules = rules.map(function(rule) { return rule.trim(); });&#13;
        // eslint-disable-next-line no-loop-func&#13;
        rules.forEach(function(rule) {&#13;
&#13;
          var match = rule.match(/([\s\S]*?)\s*\{([^}]*)\}/),&#13;
              ruleObj = { }, declaration = match[2].trim(),&#13;
              propertyValuePairs = declaration.replace(/;$/, '').split(/\s*;\s*/);&#13;
&#13;
          for (i = 0, len = propertyValuePairs.length; i &lt; len; i++) {&#13;
            var pair = propertyValuePairs[i].split(/\s*:\s*/),&#13;
                property = pair[0],&#13;
                value = pair[1];&#13;
            ruleObj[property] = value;&#13;
          }&#13;
          rule = match[1];&#13;
          rule.split(',').forEach(function(_rule) {&#13;
            _rule = _rule.replace(/^svg/i, '').trim();&#13;
            if (_rule === '') {&#13;
              return;&#13;
            }&#13;
            if (allRules[_rule]) {&#13;
              fabric.util.object.extend(allRules[_rule], ruleObj);&#13;
            }&#13;
            else {&#13;
              allRules[_rule] = fabric.util.object.clone(ruleObj);&#13;
            }&#13;
          });&#13;
        });&#13;
      }&#13;
      return allRules;&#13;
    },&#13;
&#13;
    /**&#13;
     * Takes url corresponding to an SVG document, and parses it into a set of fabric objects.&#13;
     * Note that SVG is fetched via XMLHttpRequest, so it needs to conform to SOP (Same Origin Policy)&#13;
     * @memberOf fabric&#13;
     * @param {String} url&#13;
     * @param {Function} callback&#13;
     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.&#13;
     * @param {Object} [options] Object containing options for parsing&#13;
     * @param {String} [options.crossOrigin] crossOrigin crossOrigin setting to use for external resources&#13;
     */&#13;
    loadSVGFromURL: function(url, callback, reviver, options) {&#13;
&#13;
      url = url.replace(/^\n\s*/, '').trim();&#13;
      new fabric.util.request(url, {&#13;
        method: 'get',&#13;
        onComplete: onComplete&#13;
      });&#13;
&#13;
      function onComplete(r) {&#13;
&#13;
        var xml = r.responseXML;&#13;
        if (xml &amp;&amp; !xml.documentElement &amp;&amp; fabric.window.ActiveXObject &amp;&amp; r.responseText) {&#13;
          xml = new ActiveXObject('Microsoft.XMLDOM');&#13;
          xml.async = 'false';&#13;
          //IE chokes on DOCTYPE&#13;
          xml.loadXML(r.responseText.replace(/&lt;!DOCTYPE[\s\S]*?(\[[\s\S]*\])*?&gt;/i, ''));&#13;
        }&#13;
        if (!xml || !xml.documentElement) {&#13;
          callback &amp;&amp; callback(null);&#13;
        }&#13;
&#13;
        fabric.parseSVGDocument(xml.documentElement, function (results, _options, elements, allElements) {&#13;
          callback &amp;&amp; callback(results, _options, elements, allElements);&#13;
        }, reviver, options);&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Takes string corresponding to an SVG document, and parses it into a set of fabric objects&#13;
     * @memberOf fabric&#13;
     * @param {String} string&#13;
     * @param {Function} callback&#13;
     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.&#13;
     * @param {Object} [options] Object containing options for parsing&#13;
     * @param {String} [options.crossOrigin] crossOrigin crossOrigin setting to use for external resources&#13;
     */&#13;
    loadSVGFromString: function(string, callback, reviver, options) {&#13;
      string = string.trim();&#13;
      var doc;&#13;
      if (typeof DOMParser !== 'undefined') {&#13;
        var parser = new DOMParser();&#13;
        if (parser &amp;&amp; parser.parseFromString) {&#13;
          doc = parser.parseFromString(string, 'text/xml');&#13;
        }&#13;
      }&#13;
      else if (fabric.window.ActiveXObject) {&#13;
        doc = new ActiveXObject('Microsoft.XMLDOM');&#13;
        doc.async = 'false';&#13;
        // IE chokes on DOCTYPE&#13;
        doc.loadXML(string.replace(/&lt;!DOCTYPE[\s\S]*?(\[[\s\S]*\])*?&gt;/i, ''));&#13;
      }&#13;
&#13;
      fabric.parseSVGDocument(doc.documentElement, function (results, _options, elements, allElements) {&#13;
        callback(results, _options, elements, allElements);&#13;
      }, reviver, options);&#13;
    }&#13;
  });&#13;
&#13;
})(typeof exports !== 'undefined' ? exports : this);&#13;
&#13;
&#13;
fabric.ElementsParser = function(elements, callback, options, reviver, parsingOptions) {&#13;
  this.elements = elements;&#13;
  this.callback = callback;&#13;
  this.options = options;&#13;
  this.reviver = reviver;&#13;
  this.svgUid = (options &amp;&amp; options.svgUid) || 0;&#13;
  this.parsingOptions = parsingOptions;&#13;
};&#13;
&#13;
fabric.ElementsParser.prototype.parse = function() {&#13;
  this.instances = new Array(this.elements.length);&#13;
  this.numElements = this.elements.length;&#13;
&#13;
  this.createObjects();&#13;
};&#13;
&#13;
fabric.ElementsParser.prototype.createObjects = function() {&#13;
  for (var i = 0, len = this.elements.length; i &lt; len; i++) {&#13;
    this.elements[i].setAttribute('svgUid', this.svgUid);&#13;
    (function(_obj, i) {&#13;
      setTimeout(function() {&#13;
        _obj.createObject(_obj.elements[i], i);&#13;
      }, 0);&#13;
    })(this, i);&#13;
  }&#13;
};&#13;
&#13;
fabric.ElementsParser.prototype.createObject = function(el, index) {&#13;
  var klass = fabric[fabric.util.string.capitalize(el.tagName.replace('svg:', ''))];&#13;
  if (klass &amp;&amp; klass.fromElement) {&#13;
    try {&#13;
      this._createObject(klass, el, index);&#13;
    }&#13;
    catch (err) {&#13;
      fabric.log(err);&#13;
    }&#13;
  }&#13;
  else {&#13;
    this.checkIfDone();&#13;
  }&#13;
};&#13;
&#13;
fabric.ElementsParser.prototype._createObject = function(klass, el, index) {&#13;
  klass.fromElement(el, this.createCallback(index, el), this.options);&#13;
};&#13;
&#13;
fabric.ElementsParser.prototype.createCallback = function(index, el) {&#13;
  var _this = this;&#13;
  return function(obj) {&#13;
    var _options;&#13;
    _this.resolveGradient(obj, 'fill');&#13;
    _this.resolveGradient(obj, 'stroke');&#13;
    if (obj instanceof fabric.Image) {&#13;
      _options = obj.parsePreserveAspectRatioAttribute(el);&#13;
    }&#13;
    obj._removeTransformMatrix(_options);&#13;
    _this.reviver &amp;&amp; _this.reviver(el, obj);&#13;
    _this.instances[index] = obj;&#13;
    _this.checkIfDone();&#13;
  };&#13;
};&#13;
&#13;
fabric.ElementsParser.prototype.resolveGradient = function(obj, property) {&#13;
&#13;
  var instanceFillValue = obj.get(property);&#13;
  if (!(/^url\(/).test(instanceFillValue)) {&#13;
    return;&#13;
  }&#13;
  var gradientId = instanceFillValue.slice(5, instanceFillValue.length - 1);&#13;
  if (fabric.gradientDefs[this.svgUid][gradientId]) {&#13;
    obj.set(property,&#13;
      fabric.Gradient.fromElement(fabric.gradientDefs[this.svgUid][gradientId], obj));&#13;
  }&#13;
};&#13;
&#13;
fabric.ElementsParser.prototype.checkIfDone = function() {&#13;
  if (--this.numElements === 0) {&#13;
    this.instances = this.instances.filter(function(el) {&#13;
      // eslint-disable-next-line no-eq-null, eqeqeq&#13;
      return el != null;&#13;
    });&#13;
    this.callback(this.instances, this.elements);&#13;
  }&#13;
};&#13;
&#13;
&#13;
(function(global) {&#13;
&#13;
  'use strict';&#13;
&#13;
  /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */&#13;
&#13;
  var fabric = global.fabric || (global.fabric = { });&#13;
&#13;
  if (fabric.Point) {&#13;
    fabric.warn('fabric.Point is already defined');&#13;
    return;&#13;
  }&#13;
&#13;
  fabric.Point = Point;&#13;
&#13;
  /**&#13;
   * Point class&#13;
   * @class fabric.Point&#13;
   * @memberOf fabric&#13;
   * @constructor&#13;
   * @param {Number} x&#13;
   * @param {Number} y&#13;
   * @return {fabric.Point} thisArg&#13;
   */&#13;
  function Point(x, y) {&#13;
    this.x = x;&#13;
    this.y = y;&#13;
  }&#13;
&#13;
  Point.prototype = /** @lends fabric.Point.prototype */ {&#13;
&#13;
    type: 'point',&#13;
&#13;
    constructor: Point,&#13;
&#13;
    /**&#13;
     * Adds another point to this one and returns another one&#13;
     * @param {fabric.Point} that&#13;
     * @return {fabric.Point} new Point instance with added values&#13;
     */&#13;
    add: function (that) {&#13;
      return new Point(this.x + that.x, this.y + that.y);&#13;
    },&#13;
&#13;
    /**&#13;
     * Adds another point to this one&#13;
     * @param {fabric.Point} that&#13;
     * @return {fabric.Point} thisArg&#13;
     * @chainable&#13;
     */&#13;
    addEquals: function (that) {&#13;
      this.x += that.x;&#13;
      this.y += that.y;&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Adds value to this point and returns a new one&#13;
     * @param {Number} scalar&#13;
     * @return {fabric.Point} new Point with added value&#13;
     */&#13;
    scalarAdd: function (scalar) {&#13;
      return new Point(this.x + scalar, this.y + scalar);&#13;
    },&#13;
&#13;
    /**&#13;
     * Adds value to this point&#13;
     * @param {Number} scalar&#13;
     * @return {fabric.Point} thisArg&#13;
     * @chainable&#13;
     */&#13;
    scalarAddEquals: function (scalar) {&#13;
      this.x += scalar;&#13;
      this.y += scalar;&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Subtracts another point from this point and returns a new one&#13;
     * @param {fabric.Point} that&#13;
     * @return {fabric.Point} new Point object with subtracted values&#13;
     */&#13;
    subtract: function (that) {&#13;
      return new Point(this.x - that.x, this.y - that.y);&#13;
    },&#13;
&#13;
    /**&#13;
     * Subtracts another point from this point&#13;
     * @param {fabric.Point} that&#13;
     * @return {fabric.Point} thisArg&#13;
     * @chainable&#13;
     */&#13;
    subtractEquals: function (that) {&#13;
      this.x -= that.x;&#13;
      this.y -= that.y;&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Subtracts value from this point and returns a new one&#13;
     * @param {Number} scalar&#13;
     * @return {fabric.Point}&#13;
     */&#13;
    scalarSubtract: function (scalar) {&#13;
      return new Point(this.x - scalar, this.y - scalar);&#13;
    },&#13;
&#13;
    /**&#13;
     * Subtracts value from this point&#13;
     * @param {Number} scalar&#13;
     * @return {fabric.Point} thisArg&#13;
     * @chainable&#13;
     */&#13;
    scalarSubtractEquals: function (scalar) {&#13;
      this.x -= scalar;&#13;
      this.y -= scalar;&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Multiplies this point by a value and returns a new one&#13;
     * TODO: rename in scalarMultiply in 2.0&#13;
     * @param {Number} scalar&#13;
     * @return {fabric.Point}&#13;
     */&#13;
    multiply: function (scalar) {&#13;
      return new Point(this.x * scalar, this.y * scalar);&#13;
    },&#13;
&#13;
    /**&#13;
     * Multiplies this point by a value&#13;
     * TODO: rename in scalarMultiplyEquals in 2.0&#13;
     * @param {Number} scalar&#13;
     * @return {fabric.Point} thisArg&#13;
     * @chainable&#13;
     */&#13;
    multiplyEquals: function (scalar) {&#13;
      this.x *= scalar;&#13;
      this.y *= scalar;&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Divides this point by a value and returns a new one&#13;
     * TODO: rename in scalarDivide in 2.0&#13;
     * @param {Number} scalar&#13;
     * @return {fabric.Point}&#13;
     */&#13;
    divide: function (scalar) {&#13;
      return new Point(this.x / scalar, this.y / scalar);&#13;
    },&#13;
&#13;
    /**&#13;
     * Divides this point by a value&#13;
     * TODO: rename in scalarDivideEquals in 2.0&#13;
     * @param {Number} scalar&#13;
     * @return {fabric.Point} thisArg&#13;
     * @chainable&#13;
     */&#13;
    divideEquals: function (scalar) {&#13;
      this.x /= scalar;&#13;
      this.y /= scalar;&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns true if this point is equal to another one&#13;
     * @param {fabric.Point} that&#13;
     * @return {Boolean}&#13;
     */&#13;
    eq: function (that) {&#13;
      return (this.x === that.x &amp;&amp; this.y === that.y);&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns true if this point is less than another one&#13;
     * @param {fabric.Point} that&#13;
     * @return {Boolean}&#13;
     */&#13;
    lt: function (that) {&#13;
      return (this.x &lt; that.x &amp;&amp; this.y &lt; that.y);&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns true if this point is less than or equal to another one&#13;
     * @param {fabric.Point} that&#13;
     * @return {Boolean}&#13;
     */&#13;
    lte: function (that) {&#13;
      return (this.x &lt;= that.x &amp;&amp; this.y &lt;= that.y);&#13;
    },&#13;
&#13;
    /**&#13;
&#13;
     * Returns true if this point is greater another one&#13;
     * @param {fabric.Point} that&#13;
     * @return {Boolean}&#13;
     */&#13;
    gt: function (that) {&#13;
      return (this.x &gt; that.x &amp;&amp; this.y &gt; that.y);&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns true if this point is greater than or equal to another one&#13;
     * @param {fabric.Point} that&#13;
     * @return {Boolean}&#13;
     */&#13;
    gte: function (that) {&#13;
      return (this.x &gt;= that.x &amp;&amp; this.y &gt;= that.y);&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns new point which is the result of linear interpolation with this one and another one&#13;
     * @param {fabric.Point} that&#13;
     * @param {Number} t , position of interpolation, between 0 and 1 default 0.5&#13;
     * @return {fabric.Point}&#13;
     */&#13;
    lerp: function (that, t) {&#13;
      if (typeof t === 'undefined') {&#13;
        t = 0.5;&#13;
      }&#13;
      t = Math.max(Math.min(1, t), 0);&#13;
      return new Point(this.x + (that.x - this.x) * t, this.y + (that.y - this.y) * t);&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns distance from this point and another one&#13;
     * @param {fabric.Point} that&#13;
     * @return {Number}&#13;
     */&#13;
    distanceFrom: function (that) {&#13;
      var dx = this.x - that.x,&#13;
          dy = this.y - that.y;&#13;
      return Math.sqrt(dx * dx + dy * dy);&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns the point between this point and another one&#13;
     * @param {fabric.Point} that&#13;
     * @return {fabric.Point}&#13;
     */&#13;
    midPointFrom: function (that) {&#13;
      return this.lerp(that);&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns a new point which is the min of this and another one&#13;
     * @param {fabric.Point} that&#13;
     * @return {fabric.Point}&#13;
     */&#13;
    min: function (that) {&#13;
      return new Point(Math.min(this.x, that.x), Math.min(this.y, that.y));&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns a new point which is the max of this and another one&#13;
     * @param {fabric.Point} that&#13;
     * @return {fabric.Point}&#13;
     */&#13;
    max: function (that) {&#13;
      return new Point(Math.max(this.x, that.x), Math.max(this.y, that.y));&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns string representation of this point&#13;
     * @return {String}&#13;
     */&#13;
    toString: function () {&#13;
      return this.x + ',' + this.y;&#13;
    },&#13;
&#13;
    /**&#13;
     * Sets x/y of this point&#13;
     * @param {Number} x&#13;
     * @param {Number} y&#13;
     * @chainable&#13;
     */&#13;
    setXY: function (x, y) {&#13;
      this.x = x;&#13;
      this.y = y;&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Sets x of this point&#13;
     * @param {Number} x&#13;
     * @chainable&#13;
     */&#13;
    setX: function (x) {&#13;
      this.x = x;&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Sets y of this point&#13;
     * @param {Number} y&#13;
     * @chainable&#13;
     */&#13;
    setY: function (y) {&#13;
      this.y = y;&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Sets x/y of this point from another point&#13;
     * @param {fabric.Point} that&#13;
     * @chainable&#13;
     */&#13;
    setFromPoint: function (that) {&#13;
      this.x = that.x;&#13;
      this.y = that.y;&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Swaps x/y of this point and another point&#13;
     * @param {fabric.Point} that&#13;
     */&#13;
    swap: function (that) {&#13;
      var x = this.x,&#13;
          y = this.y;&#13;
      this.x = that.x;&#13;
      this.y = that.y;&#13;
      that.x = x;&#13;
      that.y = y;&#13;
    },&#13;
&#13;
    /**&#13;
     * return a cloned instance of the point&#13;
     * @return {fabric.Point}&#13;
     */&#13;
    clone: function () {&#13;
      return new Point(this.x, this.y);&#13;
    }&#13;
  };&#13;
&#13;
})(typeof exports !== 'undefined' ? exports : this);&#13;
&#13;
&#13;
(function(global) {&#13;
&#13;
  'use strict';&#13;
&#13;
  /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */&#13;
  var fabric = global.fabric || (global.fabric = { });&#13;
&#13;
  if (fabric.Intersection) {&#13;
    fabric.warn('fabric.Intersection is already defined');&#13;
    return;&#13;
  }&#13;
&#13;
  /**&#13;
   * Intersection class&#13;
   * @class fabric.Intersection&#13;
   * @memberOf fabric&#13;
   * @constructor&#13;
   */&#13;
  function Intersection(status) {&#13;
    this.status = status;&#13;
    this.points = [];&#13;
  }&#13;
&#13;
  fabric.Intersection = Intersection;&#13;
&#13;
  fabric.Intersection.prototype = /** @lends fabric.Intersection.prototype */ {&#13;
&#13;
    constructor: Intersection,&#13;
&#13;
    /**&#13;
     * Appends a point to intersection&#13;
     * @param {fabric.Point} point&#13;
     * @return {fabric.Intersection} thisArg&#13;
     * @chainable&#13;
     */&#13;
    appendPoint: function (point) {&#13;
      this.points.push(point);&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Appends points to intersection&#13;
     * @param {Array} points&#13;
     * @return {fabric.Intersection} thisArg&#13;
     * @chainable&#13;
     */&#13;
    appendPoints: function (points) {&#13;
      this.points = this.points.concat(points);&#13;
      return this;&#13;
    }&#13;
  };&#13;
&#13;
  /**&#13;
   * Checks if one line intersects another&#13;
   * TODO: rename in intersectSegmentSegment&#13;
   * @static&#13;
   * @param {fabric.Point} a1&#13;
   * @param {fabric.Point} a2&#13;
   * @param {fabric.Point} b1&#13;
   * @param {fabric.Point} b2&#13;
   * @return {fabric.Intersection}&#13;
   */&#13;
  fabric.Intersection.intersectLineLine = function (a1, a2, b1, b2) {&#13;
    var result,&#13;
        uaT = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x),&#13;
        ubT = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x),&#13;
        uB = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);&#13;
    if (uB !== 0) {&#13;
      var ua = uaT / uB,&#13;
          ub = ubT / uB;&#13;
      if (0 &lt;= ua &amp;&amp; ua &lt;= 1 &amp;&amp; 0 &lt;= ub &amp;&amp; ub &lt;= 1) {&#13;
        result = new Intersection('Intersection');&#13;
        result.appendPoint(new fabric.Point(a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y)));&#13;
      }&#13;
      else {&#13;
        result = new Intersection();&#13;
      }&#13;
    }&#13;
    else {&#13;
      if (uaT === 0 || ubT === 0) {&#13;
        result = new Intersection('Coincident');&#13;
      }&#13;
      else {&#13;
        result = new Intersection('Parallel');&#13;
      }&#13;
    }&#13;
    return result;&#13;
  };&#13;
&#13;
  /**&#13;
   * Checks if line intersects polygon&#13;
   * TODO: rename in intersectSegmentPolygon&#13;
   * fix detection of coincident&#13;
   * @static&#13;
   * @param {fabric.Point} a1&#13;
   * @param {fabric.Point} a2&#13;
   * @param {Array} points&#13;
   * @return {fabric.Intersection}&#13;
   */&#13;
  fabric.Intersection.intersectLinePolygon = function(a1, a2, points) {&#13;
    var result = new Intersection(),&#13;
        length = points.length,&#13;
        b1, b2, inter, i;&#13;
&#13;
    for (i = 0; i &lt; length; i++) {&#13;
      b1 = points[i];&#13;
      b2 = points[(i + 1) % length];&#13;
      inter = Intersection.intersectLineLine(a1, a2, b1, b2);&#13;
&#13;
      result.appendPoints(inter.points);&#13;
    }&#13;
    if (result.points.length &gt; 0) {&#13;
      result.status = 'Intersection';&#13;
    }&#13;
    return result;&#13;
  };&#13;
&#13;
  /**&#13;
   * Checks if polygon intersects another polygon&#13;
   * @static&#13;
   * @param {Array} points1&#13;
   * @param {Array} points2&#13;
   * @return {fabric.Intersection}&#13;
   */&#13;
  fabric.Intersection.intersectPolygonPolygon = function (points1, points2) {&#13;
    var result = new Intersection(),&#13;
        length = points1.length, i;&#13;
&#13;
    for (i = 0; i &lt; length; i++) {&#13;
      var a1 = points1[i],&#13;
          a2 = points1[(i + 1) % length],&#13;
          inter = Intersection.intersectLinePolygon(a1, a2, points2);&#13;
&#13;
      result.appendPoints(inter.points);&#13;
    }&#13;
    if (result.points.length &gt; 0) {&#13;
      result.status = 'Intersection';&#13;
    }&#13;
    return result;&#13;
  };&#13;
&#13;
  /**&#13;
   * Checks if polygon intersects rectangle&#13;
   * @static&#13;
   * @param {Array} points&#13;
   * @param {fabric.Point} r1&#13;
   * @param {fabric.Point} r2&#13;
   * @return {fabric.Intersection}&#13;
   */&#13;
  fabric.Intersection.intersectPolygonRectangle = function (points, r1, r2) {&#13;
    var min = r1.min(r2),&#13;
        max = r1.max(r2),&#13;
        topRight = new fabric.Point(max.x, min.y),&#13;
        bottomLeft = new fabric.Point(min.x, max.y),&#13;
        inter1 = Intersection.intersectLinePolygon(min, topRight, points),&#13;
        inter2 = Intersection.intersectLinePolygon(topRight, max, points),&#13;
        inter3 = Intersection.intersectLinePolygon(max, bottomLeft, points),&#13;
        inter4 = Intersection.intersectLinePolygon(bottomLeft, min, points),&#13;
        result = new Intersection();&#13;
&#13;
    result.appendPoints(inter1.points);&#13;
    result.appendPoints(inter2.points);&#13;
    result.appendPoints(inter3.points);&#13;
    result.appendPoints(inter4.points);&#13;
&#13;
    if (result.points.length &gt; 0) {&#13;
      result.status = 'Intersection';&#13;
    }&#13;
    return result;&#13;
  };&#13;
&#13;
})(typeof exports !== 'undefined' ? exports : this);&#13;
&#13;
&#13;
(function(global) {&#13;
&#13;
  'use strict';&#13;
&#13;
  var fabric = global.fabric || (global.fabric = { });&#13;
&#13;
  if (fabric.Color) {&#13;
    fabric.warn('fabric.Color is already defined.');&#13;
    return;&#13;
  }&#13;
&#13;
  /**&#13;
   * Color class&#13;
   * The purpose of {@link fabric.Color} is to abstract and encapsulate common color operations;&#13;
   * {@link fabric.Color} is a constructor and creates instances of {@link fabric.Color} objects.&#13;
   *&#13;
   * @class fabric.Color&#13;
   * @param {String} color optional in hex or rgb(a) or hsl format or from known color list&#13;
   * @return {fabric.Color} thisArg&#13;
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2/#colors}&#13;
   */&#13;
  function Color(color) {&#13;
    if (!color) {&#13;
      this.setSource([0, 0, 0, 1]);&#13;
    }&#13;
    else {&#13;
      this._tryParsingColor(color);&#13;
    }&#13;
  }&#13;
&#13;
  fabric.Color = Color;&#13;
&#13;
  fabric.Color.prototype = /** @lends fabric.Color.prototype */ {&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {String|Array} color Color value to parse&#13;
     */&#13;
    _tryParsingColor: function(color) {&#13;
      var source;&#13;
&#13;
      if (color in Color.colorNameMap) {&#13;
        color = Color.colorNameMap[color];&#13;
      }&#13;
&#13;
      if (color === 'transparent') {&#13;
        source = [255, 255, 255, 0];&#13;
      }&#13;
&#13;
      if (!source) {&#13;
        source = Color.sourceFromHex(color);&#13;
      }&#13;
      if (!source) {&#13;
        source = Color.sourceFromRgb(color);&#13;
      }&#13;
      if (!source) {&#13;
        source = Color.sourceFromHsl(color);&#13;
      }&#13;
      if (!source) {&#13;
        //if color is not recognize let's make black as canvas does&#13;
        source = [0, 0, 0, 1];&#13;
      }&#13;
      if (source) {&#13;
        this.setSource(source);&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Adapted from &lt;a href="https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html"&gt;https://github.com/mjijackson&lt;/a&gt;&#13;
     * @private&#13;
     * @param {Number} r Red color value&#13;
     * @param {Number} g Green color value&#13;
     * @param {Number} b Blue color value&#13;
     * @return {Array} Hsl color&#13;
     */&#13;
    _rgbToHsl: function(r, g, b) {&#13;
      r /= 255; g /= 255; b /= 255;&#13;
&#13;
      var h, s, l,&#13;
          max = fabric.util.array.max([r, g, b]),&#13;
          min = fabric.util.array.min([r, g, b]);&#13;
&#13;
      l = (max + min) / 2;&#13;
&#13;
      if (max === min) {&#13;
        h = s = 0; // achromatic&#13;
      }&#13;
      else {&#13;
        var d = max - min;&#13;
        s = l &gt; 0.5 ? d / (2 - max - min) : d / (max + min);&#13;
        switch (max) {&#13;
          case r:&#13;
            h = (g - b) / d + (g &lt; b ? 6 : 0);&#13;
            break;&#13;
          case g:&#13;
            h = (b - r) / d + 2;&#13;
            break;&#13;
          case b:&#13;
            h = (r - g) / d + 4;&#13;
            break;&#13;
        }&#13;
        h /= 6;&#13;
      }&#13;
&#13;
      return [&#13;
        Math.round(h * 360),&#13;
        Math.round(s * 100),&#13;
        Math.round(l * 100)&#13;
      ];&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns source of this color (where source is an array representation; ex: [200, 200, 100, 1])&#13;
     * @return {Array}&#13;
     */&#13;
    getSource: function() {&#13;
      return this._source;&#13;
    },&#13;
&#13;
    /**&#13;
     * Sets source of this color (where source is an array representation; ex: [200, 200, 100, 1])&#13;
     * @param {Array} source&#13;
     */&#13;
    setSource: function(source) {&#13;
      this._source = source;&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns color representation in RGB format&#13;
     * @return {String} ex: rgb(0-255,0-255,0-255)&#13;
     */&#13;
    toRgb: function() {&#13;
      var source = this.getSource();&#13;
      return 'rgb(' + source[0] + ',' + source[1] + ',' + source[2] + ')';&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns color representation in RGBA format&#13;
     * @return {String} ex: rgba(0-255,0-255,0-255,0-1)&#13;
     */&#13;
    toRgba: function() {&#13;
      var source = this.getSource();&#13;
      return 'rgba(' + source[0] + ',' + source[1] + ',' + source[2] + ',' + source[3] + ')';&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns color representation in HSL format&#13;
     * @return {String} ex: hsl(0-360,0%-100%,0%-100%)&#13;
     */&#13;
    toHsl: function() {&#13;
      var source = this.getSource(),&#13;
          hsl = this._rgbToHsl(source[0], source[1], source[2]);&#13;
&#13;
      return 'hsl(' + hsl[0] + ',' + hsl[1] + '%,' + hsl[2] + '%)';&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns color representation in HSLA format&#13;
     * @return {String} ex: hsla(0-360,0%-100%,0%-100%,0-1)&#13;
     */&#13;
    toHsla: function() {&#13;
      var source = this.getSource(),&#13;
          hsl = this._rgbToHsl(source[0], source[1], source[2]);&#13;
&#13;
      return 'hsla(' + hsl[0] + ',' + hsl[1] + '%,' + hsl[2] + '%,' + source[3] + ')';&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns color representation in HEX format&#13;
     * @return {String} ex: FF5555&#13;
     */&#13;
    toHex: function() {&#13;
      var source = this.getSource(), r, g, b;&#13;
&#13;
      r = source[0].toString(16);&#13;
      r = (r.length === 1) ? ('0' + r) : r;&#13;
&#13;
      g = source[1].toString(16);&#13;
      g = (g.length === 1) ? ('0' + g) : g;&#13;
&#13;
      b = source[2].toString(16);&#13;
      b = (b.length === 1) ? ('0' + b) : b;&#13;
&#13;
      return r.toUpperCase() + g.toUpperCase() + b.toUpperCase();&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns color representation in HEXA format&#13;
     * @return {String} ex: FF5555CC&#13;
     */&#13;
    toHexa: function() {&#13;
      var source = this.getSource(), a;&#13;
&#13;
      a = source[3] * 255;&#13;
      a = a.toString(16);&#13;
      a = (a.length === 1) ? ('0' + a) : a;&#13;
&#13;
      return this.toHex() + a.toUpperCase();&#13;
    },&#13;
&#13;
    /**&#13;
     * Gets value of alpha channel for this color&#13;
     * @return {Number} 0-1&#13;
     */&#13;
    getAlpha: function() {&#13;
      return this.getSource()[3];&#13;
    },&#13;
&#13;
    /**&#13;
     * Sets value of alpha channel for this color&#13;
     * @param {Number} alpha Alpha value 0-1&#13;
     * @return {fabric.Color} thisArg&#13;
     */&#13;
    setAlpha: function(alpha) {&#13;
      var source = this.getSource();&#13;
      source[3] = alpha;&#13;
      this.setSource(source);&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Transforms color to its grayscale representation&#13;
     * @return {fabric.Color} thisArg&#13;
     */&#13;
    toGrayscale: function() {&#13;
      var source = this.getSource(),&#13;
          average = parseInt((source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0), 10),&#13;
          currentAlpha = source[3];&#13;
      this.setSource([average, average, average, currentAlpha]);&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Transforms color to its black and white representation&#13;
     * @param {Number} threshold&#13;
     * @return {fabric.Color} thisArg&#13;
     */&#13;
    toBlackWhite: function(threshold) {&#13;
      var source = this.getSource(),&#13;
          average = (source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0),&#13;
          currentAlpha = source[3];&#13;
&#13;
      threshold = threshold || 127;&#13;
&#13;
      average = (Number(average) &lt; Number(threshold)) ? 0 : 255;&#13;
      this.setSource([average, average, average, currentAlpha]);&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Overlays color with another color&#13;
     * @param {String|fabric.Color} otherColor&#13;
     * @return {fabric.Color} thisArg&#13;
     */&#13;
    overlayWith: function(otherColor) {&#13;
      if (!(otherColor instanceof Color)) {&#13;
        otherColor = new Color(otherColor);&#13;
      }&#13;
&#13;
      var result = [],&#13;
          alpha = this.getAlpha(),&#13;
          otherAlpha = 0.5,&#13;
          source = this.getSource(),&#13;
          otherSource = otherColor.getSource(), i;&#13;
&#13;
      for (i = 0; i &lt; 3; i++) {&#13;
        result.push(Math.round((source[i] * (1 - otherAlpha)) + (otherSource[i] * otherAlpha)));&#13;
      }&#13;
&#13;
      result[3] = alpha;&#13;
      this.setSource(result);&#13;
      return this;&#13;
    }&#13;
  };&#13;
&#13;
  /**&#13;
   * Regex matching color in RGB or RGBA formats (ex: rgb(0, 0, 0), rgba(255, 100, 10, 0.5), rgba( 255 , 100 , 10 , 0.5 ), rgb(1,1,1), rgba(100%, 60%, 10%, 0.5))&#13;
   * @static&#13;
   * @field&#13;
   * @memberOf fabric.Color&#13;
   */&#13;
  // eslint-disable-next-line max-len&#13;
  fabric.Color.reRGBa = /^rgba?\(\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*(?:\s*,\s*((?:\d*\.?\d+)?)\s*)?\)$/;&#13;
&#13;
  /**&#13;
   * Regex matching color in HSL or HSLA formats (ex: hsl(200, 80%, 10%), hsla(300, 50%, 80%, 0.5), hsla( 300 , 50% , 80% , 0.5 ))&#13;
   * @static&#13;
   * @field&#13;
   * @memberOf fabric.Color&#13;
   */&#13;
  fabric.Color.reHSLa = /^hsla?\(\s*(\d{1,3})\s*,\s*(\d{1,3}\%)\s*,\s*(\d{1,3}\%)\s*(?:\s*,\s*(\d+(?:\.\d+)?)\s*)?\)$/;&#13;
&#13;
  /**&#13;
   * Regex matching color in HEX format (ex: #FF5544CC, #FF5555, 010155, aff)&#13;
   * @static&#13;
   * @field&#13;
   * @memberOf fabric.Color&#13;
   */&#13;
  fabric.Color.reHex = /^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i;&#13;
&#13;
  /**&#13;
   * Map of the 148 color names with HEX code&#13;
   * @static&#13;
   * @field&#13;
   * @memberOf fabric.Color&#13;
   * @see: https://www.w3.org/TR/css3-color/#svg-color&#13;
   */&#13;
  fabric.Color.colorNameMap = {&#13;
    aliceblue:            '#F0F8FF',&#13;
    antiquewhite:         '#FAEBD7',&#13;
    aqua:                 '#00FFFF',&#13;
    aquamarine:           '#7FFFD4',&#13;
    azure:                '#F0FFFF',&#13;
    beige:                '#F5F5DC',&#13;
    bisque:               '#FFE4C4',&#13;
    black:                '#000000',&#13;
    blanchedalmond:       '#FFEBCD',&#13;
    blue:                 '#0000FF',&#13;
    blueviolet:           '#8A2BE2',&#13;
    brown:                '#A52A2A',&#13;
    burlywood:            '#DEB887',&#13;
    cadetblue:            '#5F9EA0',&#13;
    chartreuse:           '#7FFF00',&#13;
    chocolate:            '#D2691E',&#13;
    coral:                '#FF7F50',&#13;
    cornflowerblue:       '#6495ED',&#13;
    cornsilk:             '#FFF8DC',&#13;
    crimson:              '#DC143C',&#13;
    cyan:                 '#00FFFF',&#13;
    darkblue:             '#00008B',&#13;
    darkcyan:             '#008B8B',&#13;
    darkgoldenrod:        '#B8860B',&#13;
    darkgray:             '#A9A9A9',&#13;
    darkgrey:             '#A9A9A9',&#13;
    darkgreen:            '#006400',&#13;
    darkkhaki:            '#BDB76B',&#13;
    darkmagenta:          '#8B008B',&#13;
    darkolivegreen:       '#556B2F',&#13;
    darkorange:           '#FF8C00',&#13;
    darkorchid:           '#9932CC',&#13;
    darkred:              '#8B0000',&#13;
    darksalmon:           '#E9967A',&#13;
    darkseagreen:         '#8FBC8F',&#13;
    darkslateblue:        '#483D8B',&#13;
    darkslategray:        '#2F4F4F',&#13;
    darkslategrey:        '#2F4F4F',&#13;
    darkturquoise:        '#00CED1',&#13;
    darkviolet:           '#9400D3',&#13;
    deeppink:             '#FF1493',&#13;
    deepskyblue:          '#00BFFF',&#13;
    dimgray:              '#696969',&#13;
    dimgrey:              '#696969',&#13;
    dodgerblue:           '#1E90FF',&#13;
    firebrick:            '#B22222',&#13;
    floralwhite:          '#FFFAF0',&#13;
    forestgreen:          '#228B22',&#13;
    fuchsia:              '#FF00FF',&#13;
    gainsboro:            '#DCDCDC',&#13;
    ghostwhite:           '#F8F8FF',&#13;
    gold:                 '#FFD700',&#13;
    goldenrod:            '#DAA520',&#13;
    gray:                 '#808080',&#13;
    grey:                 '#808080',&#13;
    green:                '#008000',&#13;
    greenyellow:          '#ADFF2F',&#13;
    honeydew:             '#F0FFF0',&#13;
    hotpink:              '#FF69B4',&#13;
    indianred:            '#CD5C5C',&#13;
    indigo:               '#4B0082',&#13;
    ivory:                '#FFFFF0',&#13;
    khaki:                '#F0E68C',&#13;
    lavender:             '#E6E6FA',&#13;
    lavenderblush:        '#FFF0F5',&#13;
    lawngreen:            '#7CFC00',&#13;
    lemonchiffon:         '#FFFACD',&#13;
    lightblue:            '#ADD8E6',&#13;
    lightcoral:           '#F08080',&#13;
    lightcyan:            '#E0FFFF',&#13;
    lightgoldenrodyellow: '#FAFAD2',&#13;
    lightgray:            '#D3D3D3',&#13;
    lightgrey:            '#D3D3D3',&#13;
    lightgreen:           '#90EE90',&#13;
    lightpink:            '#FFB6C1',&#13;
    lightsalmon:          '#FFA07A',&#13;
    lightseagreen:        '#20B2AA',&#13;
    lightskyblue:         '#87CEFA',&#13;
    lightslategray:       '#778899',&#13;
    lightslategrey:       '#778899',&#13;
    lightsteelblue:       '#B0C4DE',&#13;
    lightyellow:          '#FFFFE0',&#13;
    lime:                 '#00FF00',&#13;
    limegreen:            '#32CD32',&#13;
    linen:                '#FAF0E6',&#13;
    magenta:              '#FF00FF',&#13;
    maroon:               '#800000',&#13;
    mediumaquamarine:     '#66CDAA',&#13;
    mediumblue:           '#0000CD',&#13;
    mediumorchid:         '#BA55D3',&#13;
    mediumpurple:         '#9370DB',&#13;
    mediumseagreen:       '#3CB371',&#13;
    mediumslateblue:      '#7B68EE',&#13;
    mediumspringgreen:    '#00FA9A',&#13;
    mediumturquoise:      '#48D1CC',&#13;
    mediumvioletred:      '#C71585',&#13;
    midnightblue:         '#191970',&#13;
    mintcream:            '#F5FFFA',&#13;
    mistyrose:            '#FFE4E1',&#13;
    moccasin:             '#FFE4B5',&#13;
    navajowhite:          '#FFDEAD',&#13;
    navy:                 '#000080',&#13;
    oldlace:              '#FDF5E6',&#13;
    olive:                '#808000',&#13;
    olivedrab:            '#6B8E23',&#13;
    orange:               '#FFA500',&#13;
    orangered:            '#FF4500',&#13;
    orchid:               '#DA70D6',&#13;
    palegoldenrod:        '#EEE8AA',&#13;
    palegreen:            '#98FB98',&#13;
    paleturquoise:        '#AFEEEE',&#13;
    palevioletred:        '#DB7093',&#13;
    papayawhip:           '#FFEFD5',&#13;
    peachpuff:            '#FFDAB9',&#13;
    peru:                 '#CD853F',&#13;
    pink:                 '#FFC0CB',&#13;
    plum:                 '#DDA0DD',&#13;
    powderblue:           '#B0E0E6',&#13;
    purple:               '#800080',&#13;
    rebeccapurple:        '#663399',&#13;
    red:                  '#FF0000',&#13;
    rosybrown:            '#BC8F8F',&#13;
    royalblue:            '#4169E1',&#13;
    saddlebrown:          '#8B4513',&#13;
    salmon:               '#FA8072',&#13;
    sandybrown:           '#F4A460',&#13;
    seagreen:             '#2E8B57',&#13;
    seashell:             '#FFF5EE',&#13;
    sienna:               '#A0522D',&#13;
    silver:               '#C0C0C0',&#13;
    skyblue:              '#87CEEB',&#13;
    slateblue:            '#6A5ACD',&#13;
    slategray:            '#708090',&#13;
    slategrey:            '#708090',&#13;
    snow:                 '#FFFAFA',&#13;
    springgreen:          '#00FF7F',&#13;
    steelblue:            '#4682B4',&#13;
    tan:                  '#D2B48C',&#13;
    teal:                 '#008080',&#13;
    thistle:              '#D8BFD8',&#13;
    tomato:               '#FF6347',&#13;
    turquoise:            '#40E0D0',&#13;
    violet:               '#EE82EE',&#13;
    wheat:                '#F5DEB3',&#13;
    white:                '#FFFFFF',&#13;
    whitesmoke:           '#F5F5F5',&#13;
    yellow:               '#FFFF00',&#13;
    yellowgreen:          '#9ACD32'&#13;
  };&#13;
&#13;
  /**&#13;
   * @private&#13;
   * @param {Number} p&#13;
   * @param {Number} q&#13;
   * @param {Number} t&#13;
   * @return {Number}&#13;
   */&#13;
  function hue2rgb(p, q, t) {&#13;
    if (t &lt; 0) {&#13;
      t += 1;&#13;
    }&#13;
    if (t &gt; 1) {&#13;
      t -= 1;&#13;
    }&#13;
    if (t &lt; 1 / 6) {&#13;
      return p + (q - p) * 6 * t;&#13;
    }&#13;
    if (t &lt; 1 / 2) {&#13;
      return q;&#13;
    }&#13;
    if (t &lt; 2 / 3) {&#13;
      return p + (q - p) * (2 / 3 - t) * 6;&#13;
    }&#13;
    return p;&#13;
  }&#13;
&#13;
  /**&#13;
   * Returns new color object, when given a color in RGB format&#13;
   * @memberOf fabric.Color&#13;
   * @param {String} color Color value ex: rgb(0-255,0-255,0-255)&#13;
   * @return {fabric.Color}&#13;
   */&#13;
  fabric.Color.fromRgb = function(color) {&#13;
    return Color.fromSource(Color.sourceFromRgb(color));&#13;
  };&#13;
&#13;
  /**&#13;
   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in RGB or RGBA format&#13;
   * @memberOf fabric.Color&#13;
   * @param {String} color Color value ex: rgb(0-255,0-255,0-255), rgb(0%-100%,0%-100%,0%-100%)&#13;
   * @return {Array} source&#13;
   */&#13;
  fabric.Color.sourceFromRgb = function(color) {&#13;
    var match = color.match(Color.reRGBa);&#13;
    if (match) {&#13;
      var r = parseInt(match[1], 10) / (/%$/.test(match[1]) ? 100 : 1) * (/%$/.test(match[1]) ? 255 : 1),&#13;
          g = parseInt(match[2], 10) / (/%$/.test(match[2]) ? 100 : 1) * (/%$/.test(match[2]) ? 255 : 1),&#13;
          b = parseInt(match[3], 10) / (/%$/.test(match[3]) ? 100 : 1) * (/%$/.test(match[3]) ? 255 : 1);&#13;
&#13;
      return [&#13;
        parseInt(r, 10),&#13;
        parseInt(g, 10),&#13;
        parseInt(b, 10),&#13;
        match[4] ? parseFloat(match[4]) : 1&#13;
      ];&#13;
    }&#13;
  };&#13;
&#13;
  /**&#13;
   * Returns new color object, when given a color in RGBA format&#13;
   * @static&#13;
   * @function&#13;
   * @memberOf fabric.Color&#13;
   * @param {String} color&#13;
   * @return {fabric.Color}&#13;
   */&#13;
  fabric.Color.fromRgba = Color.fromRgb;&#13;
&#13;
  /**&#13;
   * Returns new color object, when given a color in HSL format&#13;
   * @param {String} color Color value ex: hsl(0-260,0%-100%,0%-100%)&#13;
   * @memberOf fabric.Color&#13;
   * @return {fabric.Color}&#13;
   */&#13;
  fabric.Color.fromHsl = function(color) {&#13;
    return Color.fromSource(Color.sourceFromHsl(color));&#13;
  };&#13;
&#13;
  /**&#13;
   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in HSL or HSLA format.&#13;
   * Adapted from &lt;a href="https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html"&gt;https://github.com/mjijackson&lt;/a&gt;&#13;
   * @memberOf fabric.Color&#13;
   * @param {String} color Color value ex: hsl(0-360,0%-100%,0%-100%) or hsla(0-360,0%-100%,0%-100%, 0-1)&#13;
   * @return {Array} source&#13;
   * @see http://http://www.w3.org/TR/css3-color/#hsl-color&#13;
   */&#13;
  fabric.Color.sourceFromHsl = function(color) {&#13;
    var match = color.match(Color.reHSLa);&#13;
    if (!match) {&#13;
      return;&#13;
    }&#13;
&#13;
    var h = (((parseFloat(match[1]) % 360) + 360) % 360) / 360,&#13;
        s = parseFloat(match[2]) / (/%$/.test(match[2]) ? 100 : 1),&#13;
        l = parseFloat(match[3]) / (/%$/.test(match[3]) ? 100 : 1),&#13;
        r, g, b;&#13;
&#13;
    if (s === 0) {&#13;
      r = g = b = l;&#13;
    }&#13;
    else {&#13;
      var q = l &lt;= 0.5 ? l * (s + 1) : l + s - l * s,&#13;
          p = l * 2 - q;&#13;
&#13;
      r = hue2rgb(p, q, h + 1 / 3);&#13;
      g = hue2rgb(p, q, h);&#13;
      b = hue2rgb(p, q, h - 1 / 3);&#13;
    }&#13;
&#13;
    return [&#13;
      Math.round(r * 255),&#13;
      Math.round(g * 255),&#13;
      Math.round(b * 255),&#13;
      match[4] ? parseFloat(match[4]) : 1&#13;
    ];&#13;
  };&#13;
&#13;
  /**&#13;
   * Returns new color object, when given a color in HSLA format&#13;
   * @static&#13;
   * @function&#13;
   * @memberOf fabric.Color&#13;
   * @param {String} color&#13;
   * @return {fabric.Color}&#13;
   */&#13;
  fabric.Color.fromHsla = Color.fromHsl;&#13;
&#13;
  /**&#13;
   * Returns new color object, when given a color in HEX format&#13;
   * @static&#13;
   * @memberOf fabric.Color&#13;
   * @param {String} color Color value ex: FF5555&#13;
   * @return {fabric.Color}&#13;
   */&#13;
  fabric.Color.fromHex = function(color) {&#13;
    return Color.fromSource(Color.sourceFromHex(color));&#13;
  };&#13;
&#13;
  /**&#13;
   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in HEX format&#13;
   * @static&#13;
   * @memberOf fabric.Color&#13;
   * @param {String} color ex: FF5555 or FF5544CC (RGBa)&#13;
   * @return {Array} source&#13;
   */&#13;
  fabric.Color.sourceFromHex = function(color) {&#13;
    if (color.match(Color.reHex)) {&#13;
      var value = color.slice(color.indexOf('#') + 1),&#13;
          isShortNotation = (value.length === 3 || value.length === 4),&#13;
          isRGBa = (value.length === 8 || value.length === 4),&#13;
          r = isShortNotation ? (value.charAt(0) + value.charAt(0)) : value.substring(0, 2),&#13;
          g = isShortNotation ? (value.charAt(1) + value.charAt(1)) : value.substring(2, 4),&#13;
          b = isShortNotation ? (value.charAt(2) + value.charAt(2)) : value.substring(4, 6),&#13;
          a = isRGBa ? (isShortNotation ? (value.charAt(3) + value.charAt(3)) : value.substring(6, 8)) : 'FF';&#13;
&#13;
      return [&#13;
        parseInt(r, 16),&#13;
        parseInt(g, 16),&#13;
        parseInt(b, 16),&#13;
        parseFloat((parseInt(a, 16) / 255).toFixed(2))&#13;
      ];&#13;
    }&#13;
  };&#13;
&#13;
  /**&#13;
   * Returns new color object, when given color in array representation (ex: [200, 100, 100, 0.5])&#13;
   * @static&#13;
   * @memberOf fabric.Color&#13;
   * @param {Array} source&#13;
   * @return {fabric.Color}&#13;
   */&#13;
  fabric.Color.fromSource = function(source) {&#13;
    var oColor = new Color();&#13;
    oColor.setSource(source);&#13;
    return oColor;&#13;
  };&#13;
&#13;
})(typeof exports !== 'undefined' ? exports : this);&#13;
&#13;
&#13;
(function() {&#13;
&#13;
  /* _FROM_SVG_START_ */&#13;
  function getColorStop(el) {&#13;
    var style = el.getAttribute('style'),&#13;
        offset = el.getAttribute('offset') || 0,&#13;
        color, colorAlpha, opacity, i;&#13;
&#13;
    // convert percents to absolute values&#13;
    offset = parseFloat(offset) / (/%$/.test(offset) ? 100 : 1);&#13;
    offset = offset &lt; 0 ? 0 : offset &gt; 1 ? 1 : offset;&#13;
    if (style) {&#13;
      var keyValuePairs = style.split(/\s*;\s*/);&#13;
&#13;
      if (keyValuePairs[keyValuePairs.length - 1] === '') {&#13;
        keyValuePairs.pop();&#13;
      }&#13;
&#13;
      for (i = keyValuePairs.length; i--; ) {&#13;
&#13;
        var split = keyValuePairs[i].split(/\s*:\s*/),&#13;
            key = split[0].trim(),&#13;
            value = split[1].trim();&#13;
&#13;
        if (key === 'stop-color') {&#13;
          color = value;&#13;
        }&#13;
        else if (key === 'stop-opacity') {&#13;
          opacity = value;&#13;
        }&#13;
      }&#13;
    }&#13;
&#13;
    if (!color) {&#13;
      color = el.getAttribute('stop-color') || 'rgb(0,0,0)';&#13;
    }&#13;
    if (!opacity) {&#13;
      opacity = el.getAttribute('stop-opacity');&#13;
    }&#13;
&#13;
    color = new fabric.Color(color);&#13;
    colorAlpha = color.getAlpha();&#13;
    opacity = isNaN(parseFloat(opacity)) ? 1 : parseFloat(opacity);&#13;
    opacity *= colorAlpha;&#13;
&#13;
    return {&#13;
      offset: offset,&#13;
      color: color.toRgb(),&#13;
      opacity: opacity&#13;
    };&#13;
  }&#13;
&#13;
  function getLinearCoords(el) {&#13;
    return {&#13;
      x1: el.getAttribute('x1') || 0,&#13;
      y1: el.getAttribute('y1') || 0,&#13;
      x2: el.getAttribute('x2') || '100%',&#13;
      y2: el.getAttribute('y2') || 0&#13;
    };&#13;
  }&#13;
&#13;
  function getRadialCoords(el) {&#13;
    return {&#13;
      x1: el.getAttribute('fx') || el.getAttribute('cx') || '50%',&#13;
      y1: el.getAttribute('fy') || el.getAttribute('cy') || '50%',&#13;
      r1: 0,&#13;
      x2: el.getAttribute('cx') || '50%',&#13;
      y2: el.getAttribute('cy') || '50%',&#13;
      r2: el.getAttribute('r') || '50%'&#13;
    };&#13;
  }&#13;
  /* _FROM_SVG_END_ */&#13;
&#13;
  var clone = fabric.util.object.clone;&#13;
&#13;
  /**&#13;
   * Gradient class&#13;
   * @class fabric.Gradient&#13;
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#gradients}&#13;
   * @see {@link fabric.Gradient#initialize} for constructor definition&#13;
   */&#13;
  fabric.Gradient = fabric.util.createClass(/** @lends fabric.Gradient.prototype */ {&#13;
&#13;
    /**&#13;
     * Horizontal offset for aligning gradients coming from SVG when outside pathgroups&#13;
     * @type Number&#13;
     * @default 0&#13;
     */&#13;
    offsetX: 0,&#13;
&#13;
    /**&#13;
     * Vertical offset for aligning gradients coming from SVG when outside pathgroups&#13;
     * @type Number&#13;
     * @default 0&#13;
     */&#13;
    offsetY: 0,&#13;
&#13;
    /**&#13;
     * Constructor&#13;
     * @param {Object} [options] Options object with type, coords, gradientUnits and colorStops&#13;
     * @return {fabric.Gradient} thisArg&#13;
     */&#13;
    initialize: function(options) {&#13;
      options || (options = { });&#13;
&#13;
      var coords = { };&#13;
&#13;
      this.id = fabric.Object.__uid++;&#13;
      this.type = options.type || 'linear';&#13;
&#13;
      coords = {&#13;
        x1: options.coords.x1 || 0,&#13;
        y1: options.coords.y1 || 0,&#13;
        x2: options.coords.x2 || 0,&#13;
        y2: options.coords.y2 || 0&#13;
      };&#13;
&#13;
      if (this.type === 'radial') {&#13;
        coords.r1 = options.coords.r1 || 0;&#13;
        coords.r2 = options.coords.r2 || 0;&#13;
      }&#13;
      this.coords = coords;&#13;
      this.colorStops = options.colorStops.slice();&#13;
      if (options.gradientTransform) {&#13;
        this.gradientTransform = options.gradientTransform;&#13;
      }&#13;
      this.offsetX = options.offsetX || this.offsetX;&#13;
      this.offsetY = options.offsetY || this.offsetY;&#13;
    },&#13;
&#13;
    /**&#13;
     * Adds another colorStop&#13;
     * @param {Object} colorStop Object with offset and color&#13;
     * @return {fabric.Gradient} thisArg&#13;
     */&#13;
    addColorStop: function(colorStops) {&#13;
      for (var position in colorStops) {&#13;
        var color = new fabric.Color(colorStops[position]);&#13;
        this.colorStops.push({&#13;
          offset: parseFloat(position),&#13;
          color: color.toRgb(),&#13;
          opacity: color.getAlpha()&#13;
        });&#13;
      }&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns object representation of a gradient&#13;
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output&#13;
     * @return {Object}&#13;
     */&#13;
    toObject: function(propertiesToInclude) {&#13;
      var object = {&#13;
        type: this.type,&#13;
        coords: this.coords,&#13;
        colorStops: this.colorStops,&#13;
        offsetX: this.offsetX,&#13;
        offsetY: this.offsetY,&#13;
        gradientTransform: this.gradientTransform ? this.gradientTransform.concat() : this.gradientTransform&#13;
      };&#13;
      fabric.util.populateWithProperties(this, object, propertiesToInclude);&#13;
&#13;
      return object;&#13;
    },&#13;
&#13;
    /* _TO_SVG_START_ */&#13;
    /**&#13;
     * Returns SVG representation of an gradient&#13;
     * @param {Object} object Object to create a gradient for&#13;
     * @return {String} SVG representation of an gradient (linear/radial)&#13;
     */&#13;
    toSVG: function(object) {&#13;
      var coords = clone(this.coords, true), i, len,&#13;
          markup, commonAttributes, colorStops = clone(this.colorStops, true),&#13;
          needsSwap = coords.r1 &gt; coords.r2,&#13;
          offsetX = object.width / 2, offsetY = object.height / 2;&#13;
      // colorStops must be sorted ascending&#13;
      colorStops.sort(function(a, b) {&#13;
        return a.offset - b.offset;&#13;
      });&#13;
      if (object.type === 'path') {&#13;
        offsetX -= object.pathOffset.x;&#13;
        offsetY -= object.pathOffset.y;&#13;
      }&#13;
      for (var prop in coords) {&#13;
        if (prop === 'x1' || prop === 'x2') {&#13;
          coords[prop] += this.offsetX - offsetX;&#13;
        }&#13;
        else if (prop === 'y1' || prop === 'y2') {&#13;
          coords[prop] += this.offsetY - offsetY;&#13;
        }&#13;
      }&#13;
&#13;
      commonAttributes = 'id="SVGID_' + this.id +&#13;
                     '" gradientUnits="userSpaceOnUse"';&#13;
      if (this.gradientTransform) {&#13;
        commonAttributes += ' gradientTransform="matrix(' + this.gradientTransform.join(' ') + ')" ';&#13;
      }&#13;
      if (this.type === 'linear') {&#13;
        markup = [&#13;
          '&lt;linearGradient ',&#13;
          commonAttributes,&#13;
          ' x1="', coords.x1,&#13;
          '" y1="', coords.y1,&#13;
          '" x2="', coords.x2,&#13;
          '" y2="', coords.y2,&#13;
          '"&gt;\n'&#13;
        ];&#13;
      }&#13;
      else if (this.type === 'radial') {&#13;
        // svg radial gradient has just 1 radius. the biggest.&#13;
        markup = [&#13;
          '&lt;radialGradient ',&#13;
          commonAttributes,&#13;
          ' cx="', needsSwap ? coords.x1 : coords.x2,&#13;
          '" cy="', needsSwap ? coords.y1 : coords.y2,&#13;
          '" r="', needsSwap ? coords.r1 : coords.r2,&#13;
          '" fx="', needsSwap ? coords.x2 : coords.x1,&#13;
          '" fy="', needsSwap ? coords.y2 : coords.y1,&#13;
          '"&gt;\n'&#13;
        ];&#13;
      }&#13;
&#13;
      if (this.type === 'radial') {&#13;
        if (needsSwap) {&#13;
          // svg goes from internal to external radius. if radius are inverted, swap color stops.&#13;
          colorStops = colorStops.concat();&#13;
          colorStops.reverse();&#13;
          for (i = 0, len = colorStops.length; i &lt; len; i++) {&#13;
            colorStops[i].offset = 1 - colorStops[i].offset;&#13;
          }&#13;
        }&#13;
        var minRadius = Math.min(coords.r1, coords.r2);&#13;
        if (minRadius &gt; 0) {&#13;
          // i have to shift all colorStops and add new one in 0.&#13;
          var maxRadius = Math.max(coords.r1, coords.r2),&#13;
              percentageShift = minRadius / maxRadius;&#13;
          for (i = 0, len = colorStops.length; i &lt; len; i++) {&#13;
            colorStops[i].offset += percentageShift * (1 - colorStops[i].offset);&#13;
          }&#13;
        }&#13;
      }&#13;
&#13;
      for (i = 0, len = colorStops.length; i &lt; len; i++) {&#13;
        var colorStop = colorStops[i];&#13;
        markup.push(&#13;
          '&lt;stop ',&#13;
          'offset="', (colorStop.offset * 100) + '%',&#13;
          '" style="stop-color:', colorStop.color,&#13;
          (colorStop.opacity !== null ? ';stop-opacity: ' + colorStop.opacity : ';'),&#13;
          '"/&gt;\n'&#13;
        );&#13;
      }&#13;
&#13;
      markup.push((this.type === 'linear' ? '&lt;/linearGradient&gt;\n' : '&lt;/radialGradient&gt;\n'));&#13;
&#13;
      return markup.join('');&#13;
    },&#13;
    /* _TO_SVG_END_ */&#13;
&#13;
    /**&#13;
     * Returns an instance of CanvasGradient&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     * @return {CanvasGradient}&#13;
     */&#13;
    toLive: function(ctx) {&#13;
      var gradient, coords = fabric.util.object.clone(this.coords), i, len;&#13;
&#13;
      if (!this.type) {&#13;
        return;&#13;
      }&#13;
&#13;
      if (this.type === 'linear') {&#13;
        gradient = ctx.createLinearGradient(&#13;
          coords.x1, coords.y1, coords.x2, coords.y2);&#13;
      }&#13;
      else if (this.type === 'radial') {&#13;
        gradient = ctx.createRadialGradient(&#13;
          coords.x1, coords.y1, coords.r1, coords.x2, coords.y2, coords.r2);&#13;
      }&#13;
&#13;
      for (i = 0, len = this.colorStops.length; i &lt; len; i++) {&#13;
        var color = this.colorStops[i].color,&#13;
            opacity = this.colorStops[i].opacity,&#13;
            offset = this.colorStops[i].offset;&#13;
&#13;
        if (typeof opacity !== 'undefined') {&#13;
          color = new fabric.Color(color).setAlpha(opacity).toRgba();&#13;
        }&#13;
        gradient.addColorStop(offset, color);&#13;
      }&#13;
&#13;
      return gradient;&#13;
    }&#13;
  });&#13;
&#13;
  fabric.util.object.extend(fabric.Gradient, {&#13;
&#13;
    /* _FROM_SVG_START_ */&#13;
    /**&#13;
     * Returns {@link fabric.Gradient} instance from an SVG element&#13;
     * @static&#13;
     * @memberOf fabric.Gradient&#13;
     * @param {SVGGradientElement} el SVG gradient element&#13;
     * @param {fabric.Object} instance&#13;
     * @return {fabric.Gradient} Gradient instance&#13;
     * @see http://www.w3.org/TR/SVG/pservers.html#LinearGradientElement&#13;
     * @see http://www.w3.org/TR/SVG/pservers.html#RadialGradientElement&#13;
     */&#13;
    fromElement: function(el, instance) {&#13;
&#13;
      /**&#13;
       *  @example:&#13;
       *&#13;
       *  &lt;linearGradient id="linearGrad1"&gt;&#13;
       *    &lt;stop offset="0%" stop-color="white"/&gt;&#13;
       *    &lt;stop offset="100%" stop-color="black"/&gt;&#13;
       *  &lt;/linearGradient&gt;&#13;
       *&#13;
       *  OR&#13;
       *&#13;
       *  &lt;linearGradient id="linearGrad2"&gt;&#13;
       *    &lt;stop offset="0" style="stop-color:rgb(255,255,255)"/&gt;&#13;
       *    &lt;stop offset="1" style="stop-color:rgb(0,0,0)"/&gt;&#13;
       *  &lt;/linearGradient&gt;&#13;
       *&#13;
       *  OR&#13;
       *&#13;
       *  &lt;radialGradient id="radialGrad1"&gt;&#13;
       *    &lt;stop offset="0%" stop-color="white" stop-opacity="1" /&gt;&#13;
       *    &lt;stop offset="50%" stop-color="black" stop-opacity="0.5" /&gt;&#13;
       *    &lt;stop offset="100%" stop-color="white" stop-opacity="1" /&gt;&#13;
       *  &lt;/radialGradient&gt;&#13;
       *&#13;
       *  OR&#13;
       *&#13;
       *  &lt;radialGradient id="radialGrad2"&gt;&#13;
       *    &lt;stop offset="0" stop-color="rgb(255,255,255)" /&gt;&#13;
       *    &lt;stop offset="0.5" stop-color="rgb(0,0,0)" /&gt;&#13;
       *    &lt;stop offset="1" stop-color="rgb(255,255,255)" /&gt;&#13;
       *  &lt;/radialGradient&gt;&#13;
       *&#13;
       */&#13;
&#13;
      var colorStopEls = el.getElementsByTagName('stop'),&#13;
          type,&#13;
          gradientUnits = el.getAttribute('gradientUnits') || 'objectBoundingBox',&#13;
          gradientTransform = el.getAttribute('gradientTransform'),&#13;
          colorStops = [],&#13;
          coords, ellipseMatrix, i;&#13;
&#13;
      if (el.nodeName === 'linearGradient' || el.nodeName === 'LINEARGRADIENT') {&#13;
        type = 'linear';&#13;
      }&#13;
      else {&#13;
        type = 'radial';&#13;
      }&#13;
&#13;
      if (type === 'linear') {&#13;
        coords = getLinearCoords(el);&#13;
      }&#13;
      else if (type === 'radial') {&#13;
        coords = getRadialCoords(el);&#13;
      }&#13;
&#13;
      for (i = colorStopEls.length; i--; ) {&#13;
        colorStops.push(getColorStop(colorStopEls[i]));&#13;
      }&#13;
&#13;
      ellipseMatrix = _convertPercentUnitsToValues(instance, coords, gradientUnits);&#13;
&#13;
      var gradient = new fabric.Gradient({&#13;
        type: type,&#13;
        coords: coords,&#13;
        colorStops: colorStops,&#13;
        offsetX: -instance.left,&#13;
        offsetY: -instance.top&#13;
      });&#13;
&#13;
      if (gradientTransform || ellipseMatrix !== '') {&#13;
        gradient.gradientTransform = fabric.parseTransformAttribute((gradientTransform || '') + ellipseMatrix);&#13;
      }&#13;
&#13;
      return gradient;&#13;
    },&#13;
    /* _FROM_SVG_END_ */&#13;
&#13;
    /**&#13;
     * Returns {@link fabric.Gradient} instance from its object representation&#13;
     * @static&#13;
     * @memberOf fabric.Gradient&#13;
     * @param {Object} obj&#13;
     * @param {Object} [options] Options object&#13;
     */&#13;
    forObject: function(obj, options) {&#13;
      options || (options = { });&#13;
      _convertPercentUnitsToValues(obj, options.coords, 'userSpaceOnUse');&#13;
      return new fabric.Gradient(options);&#13;
    }&#13;
  });&#13;
&#13;
  /**&#13;
   * @private&#13;
   */&#13;
  function _convertPercentUnitsToValues(object, options, gradientUnits) {&#13;
    var propValue, addFactor = 0, multFactor = 1, ellipseMatrix = '';&#13;
    for (var prop in options) {&#13;
      if (options[prop] === 'Infinity') {&#13;
        options[prop] = 1;&#13;
      }&#13;
      else if (options[prop] === '-Infinity') {&#13;
        options[prop] = 0;&#13;
      }&#13;
      propValue = parseFloat(options[prop], 10);&#13;
      if (typeof options[prop] === 'string' &amp;&amp; /^\d+%$/.test(options[prop])) {&#13;
        multFactor = 0.01;&#13;
      }&#13;
      else {&#13;
        multFactor = 1;&#13;
      }&#13;
      if (prop === 'x1' || prop === 'x2' || prop === 'r2') {&#13;
        multFactor *= gradientUnits === 'objectBoundingBox' ? object.width : 1;&#13;
        addFactor = gradientUnits === 'objectBoundingBox' ? object.left || 0 : 0;&#13;
      }&#13;
      else if (prop === 'y1' || prop === 'y2') {&#13;
        multFactor *= gradientUnits === 'objectBoundingBox' ? object.height : 1;&#13;
        addFactor = gradientUnits === 'objectBoundingBox' ? object.top || 0 : 0;&#13;
      }&#13;
      options[prop] = propValue * multFactor + addFactor;&#13;
    }&#13;
    if (object.type === 'ellipse' &amp;&amp;&#13;
        options.r2 !== null &amp;&amp;&#13;
        gradientUnits === 'objectBoundingBox' &amp;&amp;&#13;
        object.rx !== object.ry) {&#13;
&#13;
      var scaleFactor = object.ry / object.rx;&#13;
      ellipseMatrix = ' scale(1, ' + scaleFactor + ')';&#13;
      if (options.y1) {&#13;
        options.y1 /= scaleFactor;&#13;
      }&#13;
      if (options.y2) {&#13;
        options.y2 /= scaleFactor;&#13;
      }&#13;
    }&#13;
    return ellipseMatrix;&#13;
  }&#13;
})();&#13;
&#13;
&#13;
(function() {&#13;
&#13;
  'use strict';&#13;
&#13;
  var toFixed = fabric.util.toFixed;&#13;
&#13;
  /**&#13;
   * Pattern class&#13;
   * @class fabric.Pattern&#13;
   * @see {@link http://fabricjs.com/patterns|Pattern demo}&#13;
   * @see {@link http://fabricjs.com/dynamic-patterns|DynamicPattern demo}&#13;
   * @see {@link fabric.Pattern#initialize} for constructor definition&#13;
   */&#13;
&#13;
&#13;
  fabric.Pattern = fabric.util.createClass(/** @lends fabric.Pattern.prototype */ {&#13;
&#13;
    /**&#13;
     * Repeat property of a pattern (one of repeat, repeat-x, repeat-y or no-repeat)&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    repeat: 'repeat',&#13;
&#13;
    /**&#13;
     * Pattern horizontal offset from object's left/top corner&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    offsetX: 0,&#13;
&#13;
    /**&#13;
     * Pattern vertical offset from object's left/top corner&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    offsetY: 0,&#13;
&#13;
    /**&#13;
     * Constructor&#13;
     * @param {Object} [options] Options object&#13;
     * @param {Function} [callback] function to invoke after callback init.&#13;
     * @return {fabric.Pattern} thisArg&#13;
     */&#13;
    initialize: function(options, callback) {&#13;
      options || (options = { });&#13;
&#13;
      this.id = fabric.Object.__uid++;&#13;
      this.setOptions(options);&#13;
      if (!options.source || (options.source &amp;&amp; typeof options.source !== 'string')) {&#13;
        callback &amp;&amp; callback(this);&#13;
        return;&#13;
      }&#13;
      // function string&#13;
      if (typeof fabric.util.getFunctionBody(options.source) !== 'undefined') {&#13;
        this.source = new Function(fabric.util.getFunctionBody(options.source));&#13;
        callback &amp;&amp; callback(this);&#13;
      }&#13;
      else {&#13;
        // img src string&#13;
        var _this = this;&#13;
        this.source = fabric.util.createImage();&#13;
        fabric.util.loadImage(options.source, function(img) {&#13;
          _this.source = img;&#13;
          callback &amp;&amp; callback(_this);&#13;
        });&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns object representation of a pattern&#13;
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output&#13;
     * @return {Object} Object representation of a pattern instance&#13;
     */&#13;
    toObject: function(propertiesToInclude) {&#13;
      var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,&#13;
          source, object;&#13;
&#13;
      // callback&#13;
      if (typeof this.source === 'function') {&#13;
        source = String(this.source);&#13;
      }&#13;
      // &lt;img&gt; element&#13;
      else if (typeof this.source.src === 'string') {&#13;
        source = this.source.src;&#13;
      }&#13;
      // &lt;canvas&gt; element&#13;
      else if (typeof this.source === 'object' &amp;&amp; this.source.toDataURL) {&#13;
        source = this.source.toDataURL();&#13;
      }&#13;
&#13;
      object = {&#13;
        type: 'pattern',&#13;
        source: source,&#13;
        repeat: this.repeat,&#13;
        offsetX: toFixed(this.offsetX, NUM_FRACTION_DIGITS),&#13;
        offsetY: toFixed(this.offsetY, NUM_FRACTION_DIGITS),&#13;
      };&#13;
      fabric.util.populateWithProperties(this, object, propertiesToInclude);&#13;
&#13;
      return object;&#13;
    },&#13;
&#13;
    /* _TO_SVG_START_ */&#13;
    /**&#13;
     * Returns SVG representation of a pattern&#13;
     * @param {fabric.Object} object&#13;
     * @return {String} SVG representation of a pattern&#13;
     */&#13;
    toSVG: function(object) {&#13;
      var patternSource = typeof this.source === 'function' ? this.source() : this.source,&#13;
          patternWidth = patternSource.width / object.width,&#13;
          patternHeight = patternSource.height / object.height,&#13;
          patternOffsetX = this.offsetX / object.width,&#13;
          patternOffsetY = this.offsetY / object.height,&#13;
          patternImgSrc = '';&#13;
      if (this.repeat === 'repeat-x' || this.repeat === 'no-repeat') {&#13;
        patternHeight = 1;&#13;
      }&#13;
      if (this.repeat === 'repeat-y' || this.repeat === 'no-repeat') {&#13;
        patternWidth = 1;&#13;
      }&#13;
      if (patternSource.src) {&#13;
        patternImgSrc = patternSource.src;&#13;
      }&#13;
      else if (patternSource.toDataURL) {&#13;
        patternImgSrc = patternSource.toDataURL();&#13;
      }&#13;
&#13;
      return '&lt;pattern id="SVGID_' + this.id +&#13;
                    '" x="' + patternOffsetX +&#13;
                    '" y="' + patternOffsetY +&#13;
                    '" width="' + patternWidth +&#13;
                    '" height="' + patternHeight + '"&gt;\n' +&#13;
               '&lt;image x="0" y="0"' +&#13;
                      ' width="' + patternSource.width +&#13;
                      '" height="' + patternSource.height +&#13;
                      '" xlink:href="' + patternImgSrc +&#13;
               '"&gt;&lt;/image&gt;\n' +&#13;
             '&lt;/pattern&gt;\n';&#13;
    },&#13;
    /* _TO_SVG_END_ */&#13;
&#13;
    setOptions: function(options) {&#13;
      for (var prop in options) {&#13;
        this[prop] = options[prop];&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns an instance of CanvasPattern&#13;
     * @param {CanvasRenderingContext2D} ctx Context to create pattern&#13;
     * @return {CanvasPattern}&#13;
     */&#13;
    toLive: function(ctx) {&#13;
      var source = typeof this.source === 'function' ? this.source() : this.source;&#13;
&#13;
      // if the image failed to load, return, and allow rest to continue loading&#13;
      if (!source) {&#13;
        return '';&#13;
      }&#13;
&#13;
      // if an image&#13;
      if (typeof source.src !== 'undefined') {&#13;
        if (!source.complete) {&#13;
          return '';&#13;
        }&#13;
        if (source.naturalWidth === 0 || source.naturalHeight === 0) {&#13;
          return '';&#13;
        }&#13;
      }&#13;
      return ctx.createPattern(source, this.repeat);&#13;
    }&#13;
  });&#13;
})();&#13;
&#13;
&#13;
(function(global) {&#13;
&#13;
  'use strict';&#13;
&#13;
  var fabric = global.fabric || (global.fabric = { }),&#13;
      toFixed = fabric.util.toFixed;&#13;
&#13;
  if (fabric.Shadow) {&#13;
    fabric.warn('fabric.Shadow is already defined.');&#13;
    return;&#13;
  }&#13;
&#13;
  /**&#13;
   * Shadow class&#13;
   * @class fabric.Shadow&#13;
   * @see {@link http://fabricjs.com/shadows|Shadow demo}&#13;
   * @see {@link fabric.Shadow#initialize} for constructor definition&#13;
   */&#13;
  fabric.Shadow = fabric.util.createClass(/** @lends fabric.Shadow.prototype */ {&#13;
&#13;
    /**&#13;
     * Shadow color&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    color: 'rgb(0,0,0)',&#13;
&#13;
    /**&#13;
     * Shadow blur&#13;
     * @type Number&#13;
     */&#13;
    blur: 0,&#13;
&#13;
    /**&#13;
     * Shadow horizontal offset&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    offsetX: 0,&#13;
&#13;
    /**&#13;
     * Shadow vertical offset&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    offsetY: 0,&#13;
&#13;
    /**&#13;
     * Whether the shadow should affect stroke operations&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    affectStroke: false,&#13;
&#13;
    /**&#13;
     * Indicates whether toObject should include default values&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    includeDefaultValues: true,&#13;
&#13;
    /**&#13;
     * Constructor&#13;
     * @param {Object|String} [options] Options object with any of color, blur, offsetX, offsetY properties or string (e.g. "rgba(0,0,0,0.2) 2px 2px 10px")&#13;
     * @return {fabric.Shadow} thisArg&#13;
     */&#13;
    initialize: function(options) {&#13;
&#13;
      if (typeof options === 'string') {&#13;
        options = this._parseShadow(options);&#13;
      }&#13;
&#13;
      for (var prop in options) {&#13;
        this[prop] = options[prop];&#13;
      }&#13;
&#13;
      this.id = fabric.Object.__uid++;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {String} shadow Shadow value to parse&#13;
     * @return {Object} Shadow object with color, offsetX, offsetY and blur&#13;
     */&#13;
    _parseShadow: function(shadow) {&#13;
      var shadowStr = shadow.trim(),&#13;
          offsetsAndBlur = fabric.Shadow.reOffsetsAndBlur.exec(shadowStr) || [],&#13;
          color = shadowStr.replace(fabric.Shadow.reOffsetsAndBlur, '') || 'rgb(0,0,0)';&#13;
&#13;
      return {&#13;
        color: color.trim(),&#13;
        offsetX: parseInt(offsetsAndBlur[1], 10) || 0,&#13;
        offsetY: parseInt(offsetsAndBlur[2], 10) || 0,&#13;
        blur: parseInt(offsetsAndBlur[3], 10) || 0&#13;
      };&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns a string representation of an instance&#13;
     * @see http://www.w3.org/TR/css-text-decor-3/#text-shadow&#13;
     * @return {String} Returns CSS3 text-shadow declaration&#13;
     */&#13;
    toString: function() {&#13;
      return [this.offsetX, this.offsetY, this.blur, this.color].join('px ');&#13;
    },&#13;
&#13;
    /* _TO_SVG_START_ */&#13;
    /**&#13;
     * Returns SVG representation of a shadow&#13;
     * @param {fabric.Object} object&#13;
     * @return {String} SVG representation of a shadow&#13;
     */&#13;
    toSVG: function(object) {&#13;
      var fBoxX = 40, fBoxY = 40, NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,&#13;
          offset = fabric.util.rotateVector(&#13;
            { x: this.offsetX, y: this.offsetY },&#13;
            fabric.util.degreesToRadians(-object.angle)),&#13;
          BLUR_BOX = 20;&#13;
&#13;
      if (object.width &amp;&amp; object.height) {&#13;
        //http://www.w3.org/TR/SVG/filters.html#FilterEffectsRegion&#13;
        // we add some extra space to filter box to contain the blur ( 20 )&#13;
        fBoxX = toFixed((Math.abs(offset.x) + this.blur) / object.width, NUM_FRACTION_DIGITS) * 100 + BLUR_BOX;&#13;
        fBoxY = toFixed((Math.abs(offset.y) + this.blur) / object.height, NUM_FRACTION_DIGITS) * 100 + BLUR_BOX;&#13;
      }&#13;
      if (object.flipX) {&#13;
        offset.x *= -1;&#13;
      }&#13;
      if (object.flipY) {&#13;
        offset.y *= -1;&#13;
      }&#13;
      return (&#13;
        '&lt;filter id="SVGID_' + this.id + '" y="-' + fBoxY + '%" height="' + (100 + 2 * fBoxY) + '%" ' +&#13;
          'x="-' + fBoxX + '%" width="' + (100 + 2 * fBoxX) + '%" ' + '&gt;\n' +&#13;
          '\t&lt;feGaussianBlur in="SourceAlpha" stdDeviation="' +&#13;
            toFixed(this.blur ? this.blur / 2 : 0, NUM_FRACTION_DIGITS) + '"&gt;&lt;/feGaussianBlur&gt;\n' +&#13;
          '\t&lt;feOffset dx="' + toFixed(offset.x, NUM_FRACTION_DIGITS) +&#13;
          '" dy="' + toFixed(offset.y, NUM_FRACTION_DIGITS) + '" result="oBlur" &gt;&lt;/feOffset&gt;\n' +&#13;
          '\t&lt;feFlood flood-color="' + this.color + '"/&gt;\n' +&#13;
          '\t&lt;feComposite in2="oBlur" operator="in" /&gt;\n' +&#13;
          '\t&lt;feMerge&gt;\n' +&#13;
            '\t\t&lt;feMergeNode&gt;&lt;/feMergeNode&gt;\n' +&#13;
            '\t\t&lt;feMergeNode in="SourceGraphic"&gt;&lt;/feMergeNode&gt;\n' +&#13;
          '\t&lt;/feMerge&gt;\n' +&#13;
        '&lt;/filter&gt;\n');&#13;
    },&#13;
    /* _TO_SVG_END_ */&#13;
&#13;
    /**&#13;
     * Returns object representation of a shadow&#13;
     * @return {Object} Object representation of a shadow instance&#13;
     */&#13;
    toObject: function() {&#13;
      if (this.includeDefaultValues) {&#13;
        return {&#13;
          color: this.color,&#13;
          blur: this.blur,&#13;
          offsetX: this.offsetX,&#13;
          offsetY: this.offsetY,&#13;
          affectStroke: this.affectStroke&#13;
        };&#13;
      }&#13;
      var obj = { }, proto = fabric.Shadow.prototype;&#13;
&#13;
      ['color', 'blur', 'offsetX', 'offsetY', 'affectStroke'].forEach(function(prop) {&#13;
        if (this[prop] !== proto[prop]) {&#13;
          obj[prop] = this[prop];&#13;
        }&#13;
      }, this);&#13;
&#13;
      return obj;&#13;
    }&#13;
  });&#13;
&#13;
  /**&#13;
   * Regex matching shadow offsetX, offsetY and blur (ex: "2px 2px 10px rgba(0,0,0,0.2)", "rgb(0,255,0) 2px 2px")&#13;
   * @static&#13;
   * @field&#13;
   * @memberOf fabric.Shadow&#13;
   */&#13;
  // eslint-disable-next-line max-len&#13;
  fabric.Shadow.reOffsetsAndBlur = /(?:\s|^)(-?\d+(?:px)?(?:\s?|$))?(-?\d+(?:px)?(?:\s?|$))?(\d+(?:px)?)?(?:\s?|$)(?:$|\s)/;&#13;
&#13;
})(typeof exports !== 'undefined' ? exports : this);&#13;
&#13;
&#13;
(function () {&#13;
&#13;
  'use strict';&#13;
&#13;
  if (fabric.StaticCanvas) {&#13;
    fabric.warn('fabric.StaticCanvas is already defined.');&#13;
    return;&#13;
  }&#13;
&#13;
  // aliases for faster resolution&#13;
  var extend = fabric.util.object.extend,&#13;
      getElementOffset = fabric.util.getElementOffset,&#13;
      removeFromArray = fabric.util.removeFromArray,&#13;
      toFixed = fabric.util.toFixed,&#13;
      transformPoint = fabric.util.transformPoint,&#13;
      invertTransform = fabric.util.invertTransform,&#13;
&#13;
      CANVAS_INIT_ERROR = new Error('Could not initialize `canvas` element');&#13;
&#13;
  /**&#13;
   * Static canvas class&#13;
   * @class fabric.StaticCanvas&#13;
   * @mixes fabric.Collection&#13;
   * @mixes fabric.Observable&#13;
   * @see {@link http://fabricjs.com/static_canvas|StaticCanvas demo}&#13;
   * @see {@link fabric.StaticCanvas#initialize} for constructor definition&#13;
   * @fires before:render&#13;
   * @fires after:render&#13;
   * @fires canvas:cleared&#13;
   * @fires object:added&#13;
   * @fires object:removed&#13;
   */&#13;
  fabric.StaticCanvas = fabric.util.createClass(fabric.CommonMethods, /** @lends fabric.StaticCanvas.prototype */ {&#13;
&#13;
    /**&#13;
     * Constructor&#13;
     * @param {HTMLElement | String} el &amp;lt;canvas&gt; element to initialize instance on&#13;
     * @param {Object} [options] Options object&#13;
     * @return {Object} thisArg&#13;
     */&#13;
    initialize: function(el, options) {&#13;
      options || (options = { });&#13;
      this.renderAndResetBound = this.renderAndReset.bind(this);&#13;
      this.requestRenderAllBound = this.requestRenderAll.bind(this);&#13;
      this._initStatic(el, options);&#13;
    },&#13;
&#13;
    /**&#13;
     * Background color of canvas instance.&#13;
     * Should be set via {@link fabric.StaticCanvas#setBackgroundColor}.&#13;
     * @type {(String|fabric.Pattern)}&#13;
     * @default&#13;
     */&#13;
    backgroundColor: '',&#13;
&#13;
    /**&#13;
     * Background image of canvas instance.&#13;
     * Should be set via {@link fabric.StaticCanvas#setBackgroundImage}.&#13;
     * &lt;b&gt;Backwards incompatibility note:&lt;/b&gt; The "backgroundImageOpacity"&#13;
     * and "backgroundImageStretch" properties are deprecated since 1.3.9.&#13;
     * Use {@link fabric.Image#opacity}, {@link fabric.Image#width} and {@link fabric.Image#height}.&#13;
     * @type fabric.Image&#13;
     * @default&#13;
     */&#13;
    backgroundImage: null,&#13;
&#13;
    /**&#13;
     * Overlay color of canvas instance.&#13;
     * Should be set via {@link fabric.StaticCanvas#setOverlayColor}&#13;
     * @since 1.3.9&#13;
     * @type {(String|fabric.Pattern)}&#13;
     * @default&#13;
     */&#13;
    overlayColor: '',&#13;
&#13;
    /**&#13;
     * Overlay image of canvas instance.&#13;
     * Should be set via {@link fabric.StaticCanvas#setOverlayImage}.&#13;
     * &lt;b&gt;Backwards incompatibility note:&lt;/b&gt; The "overlayImageLeft"&#13;
     * and "overlayImageTop" properties are deprecated since 1.3.9.&#13;
     * Use {@link fabric.Image#left} and {@link fabric.Image#top}.&#13;
     * @type fabric.Image&#13;
     * @default&#13;
     */&#13;
    overlayImage: null,&#13;
&#13;
    /**&#13;
     * Indicates whether toObject/toDatalessObject should include default values&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    includeDefaultValues: true,&#13;
&#13;
    /**&#13;
     * Indicates whether objects' state should be saved&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    stateful: false,&#13;
&#13;
    /**&#13;
     * Indicates whether {@link fabric.Collection.add}, {@link fabric.Collection.insertAt} and {@link fabric.Collection.remove},&#13;
     * {@link fabric.StaticCanvas.moveTo}, {@link fabric.StaticCanvas.clear} and many more, should also re-render canvas.&#13;
     * Disabling this option will not give a performance boost when adding/removing a lot of objects to/from canvas at once&#13;
     * since the renders are quequed and executed one per frame.&#13;
     * Disabling is suggested anyway and managing the renders of the app manually is not a big effort ( canvas.requestRenderAll() )&#13;
     * Left default to true to do not break documentation and old app, fiddles.&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    renderOnAddRemove: true,&#13;
&#13;
    /**&#13;
     * Function that determines clipping of entire canvas area&#13;
     * Being passed context as first argument. See clipping canvas area in {@link https://github.com/kangax/fabric.js/wiki/FAQ}&#13;
     * @deprecated since 2.0.0&#13;
     * @type Function&#13;
     * @default&#13;
     */&#13;
    clipTo: null,&#13;
&#13;
    /**&#13;
     * Indicates whether object controls (borders/controls) are rendered above overlay image&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    controlsAboveOverlay: false,&#13;
&#13;
    /**&#13;
     * Indicates whether the browser can be scrolled when using a touchscreen and dragging on the canvas&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    allowTouchScrolling: false,&#13;
&#13;
    /**&#13;
     * Indicates whether this canvas will use image smoothing, this is on by default in browsers&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    imageSmoothingEnabled: true,&#13;
&#13;
    /**&#13;
     * The transformation (in the format of Canvas transform) which focuses the viewport&#13;
     * @type Array&#13;
     * @default&#13;
     */&#13;
    viewportTransform: fabric.iMatrix.concat(),&#13;
&#13;
    /**&#13;
     * if set to false background image is not affected by viewport transform&#13;
     * @since 1.6.3&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    backgroundVpt: true,&#13;
&#13;
    /**&#13;
     * if set to false overlya image is not affected by viewport transform&#13;
     * @since 1.6.3&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    overlayVpt: true,&#13;
&#13;
    /**&#13;
     * Callback; invoked right before object is about to be scaled/rotated&#13;
     */&#13;
    onBeforeScaleRotate: function () {&#13;
      /* NOOP */&#13;
    },&#13;
&#13;
    /**&#13;
     * When true, canvas is scaled by devicePixelRatio for better rendering on retina screens&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    enableRetinaScaling: true,&#13;
&#13;
    /**&#13;
     * Describe canvas element extension over design&#13;
     * properties are tl,tr,bl,br.&#13;
     * if canvas is not zoomed/panned those points are the four corner of canvas&#13;
     * if canvas is viewportTransformed you those points indicate the extension&#13;
     * of canvas element in plain untrasformed coordinates&#13;
     * The coordinates get updated with @method calcViewportBoundaries.&#13;
     * @memberOf fabric.StaticCanvas.prototype&#13;
     */&#13;
    vptCoords: { },&#13;
&#13;
    /**&#13;
     * Based on vptCoords and object.aCoords, skip rendering of objects that&#13;
     * are not included in current viewport.&#13;
     * May greatly help in applications with crowded canvas and use of zoom/pan&#13;
     * If One of the corner of the bounding box of the object is on the canvas&#13;
     * the objects get rendered.&#13;
     * @memberOf fabric.StaticCanvas.prototype&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    skipOffscreen: true,&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {HTMLElement | String} el &amp;lt;canvas&gt; element to initialize instance on&#13;
     * @param {Object} [options] Options object&#13;
     */&#13;
    _initStatic: function(el, options) {&#13;
      var cb = this.requestRenderAllBound;&#13;
      this._objects = [];&#13;
      this._createLowerCanvas(el);&#13;
      this._initOptions(options);&#13;
      this._setImageSmoothing();&#13;
      // only initialize retina scaling once&#13;
      if (!this.interactive) {&#13;
        this._initRetinaScaling();&#13;
      }&#13;
&#13;
      if (options.overlayImage) {&#13;
        this.setOverlayImage(options.overlayImage, cb);&#13;
      }&#13;
      if (options.backgroundImage) {&#13;
        this.setBackgroundImage(options.backgroundImage, cb);&#13;
      }&#13;
      if (options.backgroundColor) {&#13;
        this.setBackgroundColor(options.backgroundColor, cb);&#13;
      }&#13;
      if (options.overlayColor) {&#13;
        this.setOverlayColor(options.overlayColor, cb);&#13;
      }&#13;
      this.calcOffset();&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _isRetinaScaling: function() {&#13;
      return (fabric.devicePixelRatio !== 1 &amp;&amp; this.enableRetinaScaling);&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @return {Number} retinaScaling if applied, otherwise 1;&#13;
     */&#13;
    getRetinaScaling: function() {&#13;
      return this._isRetinaScaling() ? fabric.devicePixelRatio : 1;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _initRetinaScaling: function() {&#13;
      if (!this._isRetinaScaling()) {&#13;
        return;&#13;
      }&#13;
      this.lowerCanvasEl.setAttribute('width', this.width * fabric.devicePixelRatio);&#13;
      this.lowerCanvasEl.setAttribute('height', this.height * fabric.devicePixelRatio);&#13;
&#13;
      this.contextContainer.scale(fabric.devicePixelRatio, fabric.devicePixelRatio);&#13;
    },&#13;
&#13;
    /**&#13;
     * Calculates canvas element offset relative to the document&#13;
     * This method is also attached as "resize" event handler of window&#13;
     * @return {fabric.Canvas} instance&#13;
     * @chainable&#13;
     */&#13;
    calcOffset: function () {&#13;
      this._offset = getElementOffset(this.lowerCanvasEl);&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Sets {@link fabric.StaticCanvas#overlayImage|overlay image} for this canvas&#13;
     * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set overlay to&#13;
     * @param {Function} callback callback to invoke when image is loaded and set as an overlay&#13;
     * @param {Object} [options] Optional options to set for the {@link fabric.Image|overlay image}.&#13;
     * @return {fabric.Canvas} thisArg&#13;
     * @chainable&#13;
     * @see {@link http://jsfiddle.net/fabricjs/MnzHT/|jsFiddle demo}&#13;
     * @example &lt;caption&gt;Normal overlayImage with left/top = 0&lt;/caption&gt;&#13;
     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {&#13;
     *   // Needed to position overlayImage at 0/0&#13;
     *   originX: 'left',&#13;
     *   originY: 'top'&#13;
     * });&#13;
     * @example &lt;caption&gt;overlayImage with different properties&lt;/caption&gt;&#13;
     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {&#13;
     *   opacity: 0.5,&#13;
     *   angle: 45,&#13;
     *   left: 400,&#13;
     *   top: 400,&#13;
     *   originX: 'left',&#13;
     *   originY: 'top'&#13;
     * });&#13;
     * @example &lt;caption&gt;Stretched overlayImage #1 - width/height correspond to canvas width/height&lt;/caption&gt;&#13;
     * fabric.Image.fromURL('http://fabricjs.com/assets/jail_cell_bars.png', function(img) {&#13;
     *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});&#13;
     *    canvas.setOverlayImage(img, canvas.renderAll.bind(canvas));&#13;
     * });&#13;
     * @example &lt;caption&gt;Stretched overlayImage #2 - width/height correspond to canvas width/height&lt;/caption&gt;&#13;
     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {&#13;
     *   width: canvas.width,&#13;
     *   height: canvas.height,&#13;
     *   // Needed to position overlayImage at 0/0&#13;
     *   originX: 'left',&#13;
     *   originY: 'top'&#13;
     * });&#13;
     * @example &lt;caption&gt;overlayImage loaded from cross-origin&lt;/caption&gt;&#13;
     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {&#13;
     *   opacity: 0.5,&#13;
     *   angle: 45,&#13;
     *   left: 400,&#13;
     *   top: 400,&#13;
     *   originX: 'left',&#13;
     *   originY: 'top',&#13;
     *   crossOrigin: 'anonymous'&#13;
     * });&#13;
     */&#13;
    setOverlayImage: function (image, callback, options) {&#13;
      return this.__setBgOverlayImage('overlayImage', image, callback, options);&#13;
    },&#13;
&#13;
    /**&#13;
     * Sets {@link fabric.StaticCanvas#backgroundImage|background image} for this canvas&#13;
     * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set background to&#13;
     * @param {Function} callback Callback to invoke when image is loaded and set as background&#13;
     * @param {Object} [options] Optional options to set for the {@link fabric.Image|background image}.&#13;
     * @return {fabric.Canvas} thisArg&#13;
     * @chainable&#13;
     * @see {@link http://jsfiddle.net/fabricjs/YH9yD/|jsFiddle demo}&#13;
     * @example &lt;caption&gt;Normal backgroundImage with left/top = 0&lt;/caption&gt;&#13;
     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {&#13;
     *   // Needed to position backgroundImage at 0/0&#13;
     *   originX: 'left',&#13;
     *   originY: 'top'&#13;
     * });&#13;
     * @example &lt;caption&gt;backgroundImage with different properties&lt;/caption&gt;&#13;
     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {&#13;
     *   opacity: 0.5,&#13;
     *   angle: 45,&#13;
     *   left: 400,&#13;
     *   top: 400,&#13;
     *   originX: 'left',&#13;
     *   originY: 'top'&#13;
     * });&#13;
     * @example &lt;caption&gt;Stretched backgroundImage #1 - width/height correspond to canvas width/height&lt;/caption&gt;&#13;
     * fabric.Image.fromURL('http://fabricjs.com/assets/honey_im_subtle.png', function(img) {&#13;
     *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});&#13;
     *    canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas));&#13;
     * });&#13;
     * @example &lt;caption&gt;Stretched backgroundImage #2 - width/height correspond to canvas width/height&lt;/caption&gt;&#13;
     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {&#13;
     *   width: canvas.width,&#13;
     *   height: canvas.height,&#13;
     *   // Needed to position backgroundImage at 0/0&#13;
     *   originX: 'left',&#13;
     *   originY: 'top'&#13;
     * });&#13;
     * @example &lt;caption&gt;backgroundImage loaded from cross-origin&lt;/caption&gt;&#13;
     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {&#13;
     *   opacity: 0.5,&#13;
     *   angle: 45,&#13;
     *   left: 400,&#13;
     *   top: 400,&#13;
     *   originX: 'left',&#13;
     *   originY: 'top',&#13;
     *   crossOrigin: 'anonymous'&#13;
     * });&#13;
     */&#13;
    setBackgroundImage: function (image, callback, options) {&#13;
      return this.__setBgOverlayImage('backgroundImage', image, callback, options);&#13;
    },&#13;
&#13;
    /**&#13;
     * Sets {@link fabric.StaticCanvas#overlayColor|foreground color} for this canvas&#13;
     * @param {(String|fabric.Pattern)} overlayColor Color or pattern to set foreground color to&#13;
     * @param {Function} callback Callback to invoke when foreground color is set&#13;
     * @return {fabric.Canvas} thisArg&#13;
     * @chainable&#13;
     * @see {@link http://jsfiddle.net/fabricjs/pB55h/|jsFiddle demo}&#13;
     * @example &lt;caption&gt;Normal overlayColor - color value&lt;/caption&gt;&#13;
     * canvas.setOverlayColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));&#13;
     * @example &lt;caption&gt;fabric.Pattern used as overlayColor&lt;/caption&gt;&#13;
     * canvas.setOverlayColor({&#13;
     *   source: 'http://fabricjs.com/assets/escheresque_ste.png'&#13;
     * }, canvas.renderAll.bind(canvas));&#13;
     * @example &lt;caption&gt;fabric.Pattern used as overlayColor with repeat and offset&lt;/caption&gt;&#13;
     * canvas.setOverlayColor({&#13;
     *   source: 'http://fabricjs.com/assets/escheresque_ste.png',&#13;
     *   repeat: 'repeat',&#13;
     *   offsetX: 200,&#13;
     *   offsetY: 100&#13;
     * }, canvas.renderAll.bind(canvas));&#13;
     */&#13;
    setOverlayColor: function(overlayColor, callback) {&#13;
      return this.__setBgOverlayColor('overlayColor', overlayColor, callback);&#13;
    },&#13;
&#13;
    /**&#13;
     * Sets {@link fabric.StaticCanvas#backgroundColor|background color} for this canvas&#13;
     * @param {(String|fabric.Pattern)} backgroundColor Color or pattern to set background color to&#13;
     * @param {Function} callback Callback to invoke when background color is set&#13;
     * @return {fabric.Canvas} thisArg&#13;
     * @chainable&#13;
     * @see {@link http://jsfiddle.net/fabricjs/hXzvk/|jsFiddle demo}&#13;
     * @example &lt;caption&gt;Normal backgroundColor - color value&lt;/caption&gt;&#13;
     * canvas.setBackgroundColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));&#13;
     * @example &lt;caption&gt;fabric.Pattern used as backgroundColor&lt;/caption&gt;&#13;
     * canvas.setBackgroundColor({&#13;
     *   source: 'http://fabricjs.com/assets/escheresque_ste.png'&#13;
     * }, canvas.renderAll.bind(canvas));&#13;
     * @example &lt;caption&gt;fabric.Pattern used as backgroundColor with repeat and offset&lt;/caption&gt;&#13;
     * canvas.setBackgroundColor({&#13;
     *   source: 'http://fabricjs.com/assets/escheresque_ste.png',&#13;
     *   repeat: 'repeat',&#13;
     *   offsetX: 200,&#13;
     *   offsetY: 100&#13;
     * }, canvas.renderAll.bind(canvas));&#13;
     */&#13;
    setBackgroundColor: function(backgroundColor, callback) {&#13;
      return this.__setBgOverlayColor('backgroundColor', backgroundColor, callback);&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-imagesmoothingenabled|WhatWG Canvas Standard}&#13;
     */&#13;
    _setImageSmoothing: function() {&#13;
      var ctx = this.getContext();&#13;
&#13;
      ctx.imageSmoothingEnabled = ctx.imageSmoothingEnabled || ctx.webkitImageSmoothingEnabled&#13;
        || ctx.mozImageSmoothingEnabled || ctx.msImageSmoothingEnabled || ctx.oImageSmoothingEnabled;&#13;
      ctx.imageSmoothingEnabled = this.imageSmoothingEnabled;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundImage|backgroundImage}&#13;
     * or {@link fabric.StaticCanvas#overlayImage|overlayImage})&#13;
     * @param {(fabric.Image|String|null)} image fabric.Image instance, URL of an image or null to set background or overlay to&#13;
     * @param {Function} callback Callback to invoke when image is loaded and set as background or overlay&#13;
     * @param {Object} [options] Optional options to set for the {@link fabric.Image|image}.&#13;
     */&#13;
    __setBgOverlayImage: function(property, image, callback, options) {&#13;
      if (typeof image === 'string') {&#13;
        fabric.util.loadImage(image, function(img) {&#13;
          img &amp;&amp; (this[property] = new fabric.Image(img, options));&#13;
          callback &amp;&amp; callback(img);&#13;
        }, this, options &amp;&amp; options.crossOrigin);&#13;
      }&#13;
      else {&#13;
        options &amp;&amp; image.setOptions(options);&#13;
        this[property] = image;&#13;
        callback &amp;&amp; callback(image);&#13;
      }&#13;
&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundColor|backgroundColor}&#13;
     * or {@link fabric.StaticCanvas#overlayColor|overlayColor})&#13;
     * @param {(Object|String|null)} color Object with pattern information, color value or null&#13;
     * @param {Function} [callback] Callback is invoked when color is set&#13;
     */&#13;
    __setBgOverlayColor: function(property, color, callback) {&#13;
      this[property] = color;&#13;
      this._initGradient(color, property);&#13;
      this._initPattern(color, property, callback);&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _createCanvasElement: function() {&#13;
      var element = fabric.util.createCanvasElement();&#13;
      if (!element) {&#13;
        throw CANVAS_INIT_ERROR;&#13;
      }&#13;
      if (!element.style) {&#13;
        element.style = { };&#13;
      }&#13;
      if (typeof element.getContext === 'undefined') {&#13;
        throw CANVAS_INIT_ERROR;&#13;
      }&#13;
      return element;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Object} [options] Options object&#13;
     */&#13;
    _initOptions: function (options) {&#13;
      this._setOptions(options);&#13;
&#13;
      this.width = this.width || parseInt(this.lowerCanvasEl.width, 10) || 0;&#13;
      this.height = this.height || parseInt(this.lowerCanvasEl.height, 10) || 0;&#13;
&#13;
      if (!this.lowerCanvasEl.style) {&#13;
        return;&#13;
      }&#13;
&#13;
      this.lowerCanvasEl.width = this.width;&#13;
      this.lowerCanvasEl.height = this.height;&#13;
&#13;
      this.lowerCanvasEl.style.width = this.width + 'px';&#13;
      this.lowerCanvasEl.style.height = this.height + 'px';&#13;
&#13;
      this.viewportTransform = this.viewportTransform.slice();&#13;
    },&#13;
&#13;
    /**&#13;
     * Creates a bottom canvas&#13;
     * @private&#13;
     * @param {HTMLElement} [canvasEl]&#13;
     */&#13;
    _createLowerCanvas: function (canvasEl) {&#13;
      // canvasEl === 'HTMLCanvasElement' does not work on jsdom/node&#13;
      if (canvasEl &amp;&amp; canvasEl.getContext) {&#13;
        this.lowerCanvasEl = canvasEl;&#13;
      }&#13;
      else {&#13;
        this.lowerCanvasEl = fabric.util.getById(canvasEl) || this._createCanvasElement();&#13;
      }&#13;
&#13;
      fabric.util.addClass(this.lowerCanvasEl, 'lower-canvas');&#13;
&#13;
      if (this.interactive) {&#13;
        this._applyCanvasStyle(this.lowerCanvasEl);&#13;
      }&#13;
&#13;
      this.contextContainer = this.lowerCanvasEl.getContext('2d');&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns canvas width (in px)&#13;
     * @return {Number}&#13;
     */&#13;
    getWidth: function () {&#13;
      return this.width;&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns canvas height (in px)&#13;
     * @return {Number}&#13;
     */&#13;
    getHeight: function () {&#13;
      return this.height;&#13;
    },&#13;
&#13;
    /**&#13;
     * Sets width of this canvas instance&#13;
     * @param {Number|String} value                         Value to set width to&#13;
     * @param {Object}        [options]                     Options object&#13;
     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions&#13;
     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions&#13;
     * @return {fabric.Canvas} instance&#13;
     * @chainable true&#13;
     */&#13;
    setWidth: function (value, options) {&#13;
      return this.setDimensions({ width: value }, options);&#13;
    },&#13;
&#13;
    /**&#13;
     * Sets height of this canvas instance&#13;
     * @param {Number|String} value                         Value to set height to&#13;
     * @param {Object}        [options]                     Options object&#13;
     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions&#13;
     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions&#13;
     * @return {fabric.Canvas} instance&#13;
     * @chainable true&#13;
     */&#13;
    setHeight: function (value, options) {&#13;
      return this.setDimensions({ height: value }, options);&#13;
    },&#13;
&#13;
    /**&#13;
     * Sets dimensions (width, height) of this canvas instance. when options.cssOnly flag active you should also supply the unit of measure (px/%/em)&#13;
     * @param {Object}        dimensions                    Object with width/height properties&#13;
     * @param {Number|String} [dimensions.width]            Width of canvas element&#13;
     * @param {Number|String} [dimensions.height]           Height of canvas element&#13;
     * @param {Object}        [options]                     Options object&#13;
     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions&#13;
     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions&#13;
     * @return {fabric.Canvas} thisArg&#13;
     * @chainable&#13;
     */&#13;
    setDimensions: function (dimensions, options) {&#13;
      var cssValue;&#13;
&#13;
      options = options || {};&#13;
&#13;
      for (var prop in dimensions) {&#13;
        cssValue = dimensions[prop];&#13;
&#13;
        if (!options.cssOnly) {&#13;
          this._setBackstoreDimension(prop, dimensions[prop]);&#13;
          cssValue += 'px';&#13;
        }&#13;
&#13;
        if (!options.backstoreOnly) {&#13;
          this._setCssDimension(prop, cssValue);&#13;
        }&#13;
      }&#13;
      if (this._isCurrentlyDrawing) {&#13;
        this.freeDrawingBrush &amp;&amp; this.freeDrawingBrush._setBrushStyles();&#13;
      }&#13;
      this._initRetinaScaling();&#13;
      this._setImageSmoothing();&#13;
      this.calcOffset();&#13;
&#13;
      if (!options.cssOnly) {&#13;
        this.requestRenderAll();&#13;
      }&#13;
&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Helper for setting width/height&#13;
     * @private&#13;
     * @param {String} prop property (width|height)&#13;
     * @param {Number} value value to set property to&#13;
     * @return {fabric.Canvas} instance&#13;
     * @chainable true&#13;
     */&#13;
    _setBackstoreDimension: function (prop, value) {&#13;
      this.lowerCanvasEl[prop] = value;&#13;
&#13;
      if (this.upperCanvasEl) {&#13;
        this.upperCanvasEl[prop] = value;&#13;
      }&#13;
&#13;
      if (this.cacheCanvasEl) {&#13;
        this.cacheCanvasEl[prop] = value;&#13;
      }&#13;
&#13;
      this[prop] = value;&#13;
&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Helper for setting css width/height&#13;
     * @private&#13;
     * @param {String} prop property (width|height)&#13;
     * @param {String} value value to set property to&#13;
     * @return {fabric.Canvas} instance&#13;
     * @chainable true&#13;
     */&#13;
    _setCssDimension: function (prop, value) {&#13;
      this.lowerCanvasEl.style[prop] = value;&#13;
&#13;
      if (this.upperCanvasEl) {&#13;
        this.upperCanvasEl.style[prop] = value;&#13;
      }&#13;
&#13;
      if (this.wrapperEl) {&#13;
        this.wrapperEl.style[prop] = value;&#13;
      }&#13;
&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns canvas zoom level&#13;
     * @return {Number}&#13;
     */&#13;
    getZoom: function () {&#13;
      return this.viewportTransform[0];&#13;
    },&#13;
&#13;
    /**&#13;
     * Sets viewport transform of this canvas instance&#13;
     * @param {Array} vpt the transform in the form of context.transform&#13;
     * @return {fabric.Canvas} instance&#13;
     * @chainable true&#13;
     */&#13;
    setViewportTransform: function (vpt) {&#13;
      var activeObject = this._activeObject, object, ignoreVpt = false, skipAbsolute = true, i, len;&#13;
      this.viewportTransform = vpt;&#13;
      for (i = 0, len = this._objects.length; i &lt; len; i++) {&#13;
        object = this._objects[i];&#13;
        object.group || object.setCoords(ignoreVpt, skipAbsolute);&#13;
      }&#13;
      if (activeObject &amp;&amp; activeObject.type === 'activeSelection') {&#13;
        activeObject.setCoords(ignoreVpt, skipAbsolute);&#13;
      }&#13;
      this.calcViewportBoundaries();&#13;
      this.renderOnAddRemove &amp;&amp; this.requestRenderAll();&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Sets zoom level of this canvas instance, zoom centered around point&#13;
     * @param {fabric.Point} point to zoom with respect to&#13;
     * @param {Number} value to set zoom to, less than 1 zooms out&#13;
     * @return {fabric.Canvas} instance&#13;
     * @chainable true&#13;
     */&#13;
    zoomToPoint: function (point, value) {&#13;
      // TODO: just change the scale, preserve other transformations&#13;
      var before = point, vpt = this.viewportTransform.slice(0);&#13;
      point = transformPoint(point, invertTransform(this.viewportTransform));&#13;
      vpt[0] = value;&#13;
      vpt[3] = value;&#13;
      var after = transformPoint(point, vpt);&#13;
      vpt[4] += before.x - after.x;&#13;
      vpt[5] += before.y - after.y;&#13;
      return this.setViewportTransform(vpt);&#13;
    },&#13;
&#13;
    /**&#13;
     * Sets zoom level of this canvas instance&#13;
     * @param {Number} value to set zoom to, less than 1 zooms out&#13;
     * @return {fabric.Canvas} instance&#13;
     * @chainable true&#13;
     */&#13;
    setZoom: function (value) {&#13;
      this.zoomToPoint(new fabric.Point(0, 0), value);&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Pan viewport so as to place point at top left corner of canvas&#13;
     * @param {fabric.Point} point to move to&#13;
     * @return {fabric.Canvas} instance&#13;
     * @chainable true&#13;
     */&#13;
    absolutePan: function (point) {&#13;
      var vpt = this.viewportTransform.slice(0);&#13;
      vpt[4] = -point.x;&#13;
      vpt[5] = -point.y;&#13;
      return this.setViewportTransform(vpt);&#13;
    },&#13;
&#13;
    /**&#13;
     * Pans viewpoint relatively&#13;
     * @param {fabric.Point} point (position vector) to move by&#13;
     * @return {fabric.Canvas} instance&#13;
     * @chainable true&#13;
     */&#13;
    relativePan: function (point) {&#13;
      return this.absolutePan(new fabric.Point(&#13;
        -point.x - this.viewportTransform[4],&#13;
        -point.y - this.viewportTransform[5]&#13;
      ));&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns &amp;lt;canvas&gt; element corresponding to this instance&#13;
     * @return {HTMLCanvasElement}&#13;
     */&#13;
    getElement: function () {&#13;
      return this.lowerCanvasEl;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {fabric.Object} obj Object that was added&#13;
     */&#13;
    _onObjectAdded: function(obj) {&#13;
      this.stateful &amp;&amp; obj.setupState();&#13;
      obj._set('canvas', this);&#13;
      obj.setCoords();&#13;
      this.fire('object:added', { target: obj });&#13;
      obj.fire('added');&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {fabric.Object} obj Object that was removed&#13;
     */&#13;
    _onObjectRemoved: function(obj) {&#13;
      this.fire('object:removed', { target: obj });&#13;
      obj.fire('removed');&#13;
      delete obj.canvas;&#13;
    },&#13;
&#13;
    /**&#13;
     * Clears specified context of canvas element&#13;
     * @param {CanvasRenderingContext2D} ctx Context to clear&#13;
     * @return {fabric.Canvas} thisArg&#13;
     * @chainable&#13;
     */&#13;
    clearContext: function(ctx) {&#13;
      ctx.clearRect(0, 0, this.width, this.height);&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns context of canvas where objects are drawn&#13;
     * @return {CanvasRenderingContext2D}&#13;
     */&#13;
    getContext: function () {&#13;
      return this.contextContainer;&#13;
    },&#13;
&#13;
    /**&#13;
     * Clears all contexts (background, main, top) of an instance&#13;
     * @return {fabric.Canvas} thisArg&#13;
     * @chainable&#13;
     */&#13;
    clear: function () {&#13;
      this._objects.length = 0;&#13;
      this.backgroundImage = null;&#13;
      this.overlayImage = null;&#13;
      this.backgroundColor = '';&#13;
      this.overlayColor = '';&#13;
      if (this._hasITextHandlers) {&#13;
        this.off('mouse:up', this._mouseUpITextHandler);&#13;
        this._iTextInstances = null;&#13;
        this._hasITextHandlers = false;&#13;
      }&#13;
      this.clearContext(this.contextContainer);&#13;
      this.fire('canvas:cleared');&#13;
      this.renderOnAddRemove &amp;&amp; this.requestRenderAll();&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Renders the canvas&#13;
     * @return {fabric.Canvas} instance&#13;
     * @chainable&#13;
     */&#13;
    renderAll: function () {&#13;
      var canvasToDrawOn = this.contextContainer;&#13;
      this.renderCanvas(canvasToDrawOn, this._objects);&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Function created to be instance bound at initialization&#13;
     * used in requestAnimationFrame rendering&#13;
     * @return {fabric.Canvas} instance&#13;
     * @chainable&#13;
     */&#13;
    renderAndReset: function() {&#13;
      this.isRendering = 0;&#13;
      this.renderAll();&#13;
    },&#13;
&#13;
    /**&#13;
     * Append a renderAll request to next animation frame.&#13;
     * a boolean flag will avoid appending more.&#13;
     * @return {fabric.Canvas} instance&#13;
     * @chainable&#13;
     */&#13;
    requestRenderAll: function () {&#13;
      if (!this.isRendering) {&#13;
        this.isRendering = fabric.util.requestAnimFrame(this.renderAndResetBound);&#13;
      }&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Calculate the position of the 4 corner of canvas with current viewportTransform.&#13;
     * helps to determinate when an object is in the current rendering viewport using&#13;
     * object absolute coordinates ( aCoords )&#13;
     * @return {Object} points.tl&#13;
     * @chainable&#13;
     */&#13;
    calcViewportBoundaries: function() {&#13;
      var points = { }, width = this.width, height = this.height,&#13;
          iVpt = invertTransform(this.viewportTransform);&#13;
      points.tl = transformPoint({ x: 0, y: 0 }, iVpt);&#13;
      points.br = transformPoint({ x: width, y: height }, iVpt);&#13;
      points.tr = new fabric.Point(points.br.x, points.tl.y);&#13;
      points.bl = new fabric.Point(points.tl.x, points.br.y);&#13;
      this.vptCoords = points;&#13;
      return points;&#13;
    },&#13;
&#13;
    /**&#13;
     * Renders background, objects, overlay and controls.&#13;
     * @param {CanvasRenderingContext2D} ctx&#13;
     * @param {Array} objects to render&#13;
     * @return {fabric.Canvas} instance&#13;
     * @chainable&#13;
     */&#13;
    renderCanvas: function(ctx, objects) {&#13;
      var v = this.viewportTransform;&#13;
      if (this.isRendering) {&#13;
        fabric.util.cancelAnimFrame(this.isRendering);&#13;
        this.isRendering = 0;&#13;
      }&#13;
      this.calcViewportBoundaries();&#13;
      this.clearContext(ctx);&#13;
      this.fire('before:render');&#13;
      if (this.clipTo) {&#13;
        fabric.util.clipContext(this, ctx);&#13;
      }&#13;
      this._renderBackground(ctx);&#13;
&#13;
      ctx.save();&#13;
      //apply viewport transform once for all rendering process&#13;
      ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);&#13;
      this._renderObjects(ctx, objects);&#13;
      ctx.restore();&#13;
      if (!this.controlsAboveOverlay &amp;&amp; this.interactive) {&#13;
        this.drawControls(ctx);&#13;
      }&#13;
      if (this.clipTo) {&#13;
        ctx.restore();&#13;
      }&#13;
      this._renderOverlay(ctx);&#13;
      if (this.controlsAboveOverlay &amp;&amp; this.interactive) {&#13;
        this.drawControls(ctx);&#13;
      }&#13;
      this.fire('after:render');&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     * @param {Array} objects to render&#13;
     */&#13;
    _renderObjects: function(ctx, objects) {&#13;
      var i, len;&#13;
      for (i = 0, len = objects.length; i &lt; len; ++i) {&#13;
        objects[i] &amp;&amp; objects[i].render(ctx);&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     * @param {string} property 'background' or 'overlay'&#13;
     */&#13;
    _renderBackgroundOrOverlay: function(ctx, property) {&#13;
      var object = this[property + 'Color'], v;&#13;
      if (object) {&#13;
        ctx.fillStyle = object.toLive&#13;
          ? object.toLive(ctx, this)&#13;
          : object;&#13;
&#13;
        ctx.fillRect(&#13;
          object.offsetX || 0,&#13;
          object.offsetY || 0,&#13;
          this.width,&#13;
          this.height);&#13;
      }&#13;
      object = this[property + 'Image'];&#13;
      if (object) {&#13;
        if (this[property + 'Vpt']) {&#13;
          v = this.viewportTransform;&#13;
          ctx.save();&#13;
          ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);&#13;
        }&#13;
        object.render(ctx);&#13;
        this[property + 'Vpt'] &amp;&amp; ctx.restore();&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     */&#13;
    _renderBackground: function(ctx) {&#13;
      this._renderBackgroundOrOverlay(ctx, 'background');&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     */&#13;
    _renderOverlay: function(ctx) {&#13;
      this._renderBackgroundOrOverlay(ctx, 'overlay');&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns coordinates of a center of canvas.&#13;
     * Returned value is an object with top and left properties&#13;
     * @return {Object} object with "top" and "left" number values&#13;
     */&#13;
    getCenter: function () {&#13;
      return {&#13;
        top: this.height / 2,&#13;
        left: this.width / 2&#13;
      };&#13;
    },&#13;
&#13;
    /**&#13;
     * Centers object horizontally in the canvas&#13;
     * @param {fabric.Object} object Object to center horizontally&#13;
     * @return {fabric.Canvas} thisArg&#13;
     */&#13;
    centerObjectH: function (object) {&#13;
      return this._centerObject(object, new fabric.Point(this.getCenter().left, object.getCenterPoint().y));&#13;
    },&#13;
&#13;
    /**&#13;
     * Centers object vertically in the canvas&#13;
     * @param {fabric.Object} object Object to center vertically&#13;
     * @return {fabric.Canvas} thisArg&#13;
     * @chainable&#13;
     */&#13;
    centerObjectV: function (object) {&#13;
      return this._centerObject(object, new fabric.Point(object.getCenterPoint().x, this.getCenter().top));&#13;
    },&#13;
&#13;
    /**&#13;
     * Centers object vertically and horizontally in the canvas&#13;
     * @param {fabric.Object} object Object to center vertically and horizontally&#13;
     * @return {fabric.Canvas} thisArg&#13;
     * @chainable&#13;
     */&#13;
    centerObject: function(object) {&#13;
      var center = this.getCenter();&#13;
&#13;
      return this._centerObject(object, new fabric.Point(center.left, center.top));&#13;
    },&#13;
&#13;
    /**&#13;
     * Centers object vertically and horizontally in the viewport&#13;
     * @param {fabric.Object} object Object to center vertically and horizontally&#13;
     * @return {fabric.Canvas} thisArg&#13;
     * @chainable&#13;
     */&#13;
    viewportCenterObject: function(object) {&#13;
      var vpCenter = this.getVpCenter();&#13;
&#13;
      return this._centerObject(object, vpCenter);&#13;
    },&#13;
&#13;
    /**&#13;
     * Centers object horizontally in the viewport, object.top is unchanged&#13;
     * @param {fabric.Object} object Object to center vertically and horizontally&#13;
     * @return {fabric.Canvas} thisArg&#13;
     * @chainable&#13;
     */&#13;
    viewportCenterObjectH: function(object) {&#13;
      var vpCenter = this.getVpCenter();&#13;
      this._centerObject(object, new fabric.Point(vpCenter.x, object.getCenterPoint().y));&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Centers object Vertically in the viewport, object.top is unchanged&#13;
     * @param {fabric.Object} object Object to center vertically and horizontally&#13;
     * @return {fabric.Canvas} thisArg&#13;
     * @chainable&#13;
     */&#13;
    viewportCenterObjectV: function(object) {&#13;
      var vpCenter = this.getVpCenter();&#13;
&#13;
      return this._centerObject(object, new fabric.Point(object.getCenterPoint().x, vpCenter.y));&#13;
    },&#13;
&#13;
    /**&#13;
     * Calculate the point in canvas that correspond to the center of actual viewport.&#13;
     * @return {fabric.Point} vpCenter, viewport center&#13;
     * @chainable&#13;
     */&#13;
    getVpCenter: function() {&#13;
      var center = this.getCenter(),&#13;
          iVpt = invertTransform(this.viewportTransform);&#13;
      return transformPoint({ x: center.left, y: center.top }, iVpt);&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {fabric.Object} object Object to center&#13;
     * @param {fabric.Point} center Center point&#13;
     * @return {fabric.Canvas} thisArg&#13;
     * @chainable&#13;
     */&#13;
    _centerObject: function(object, center) {&#13;
      object.setPositionByOrigin(center, 'center', 'center');&#13;
      object.setCoords();&#13;
      this.renderOnAddRemove &amp;&amp; this.requestRenderAll();&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Returs dataless JSON representation of canvas&#13;
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output&#13;
     * @return {String} json string&#13;
     */&#13;
    toDatalessJSON: function (propertiesToInclude) {&#13;
      return this.toDatalessObject(propertiesToInclude);&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns object representation of canvas&#13;
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output&#13;
     * @return {Object} object representation of an instance&#13;
     */&#13;
    toObject: function (propertiesToInclude) {&#13;
      return this._toObjectMethod('toObject', propertiesToInclude);&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns dataless object representation of canvas&#13;
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output&#13;
     * @return {Object} object representation of an instance&#13;
     */&#13;
    toDatalessObject: function (propertiesToInclude) {&#13;
      return this._toObjectMethod('toDatalessObject', propertiesToInclude);&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _toObjectMethod: function (methodName, propertiesToInclude) {&#13;
&#13;
      var data = {&#13;
        version: fabric.version,&#13;
        objects: this._toObjects(methodName, propertiesToInclude)&#13;
      };&#13;
&#13;
      extend(data, this.__serializeBgOverlay(methodName, propertiesToInclude));&#13;
&#13;
      fabric.util.populateWithProperties(this, data, propertiesToInclude);&#13;
&#13;
      return data;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _toObjects: function(methodName, propertiesToInclude) {&#13;
      return this.getObjects().filter(function(object) {&#13;
        return !object.excludeFromExport;&#13;
      }).map(function(instance) {&#13;
        return this._toObject(instance, methodName, propertiesToInclude);&#13;
      }, this);&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _toObject: function(instance, methodName, propertiesToInclude) {&#13;
      var originalValue;&#13;
&#13;
      if (!this.includeDefaultValues) {&#13;
        originalValue = instance.includeDefaultValues;&#13;
        instance.includeDefaultValues = false;&#13;
      }&#13;
&#13;
      var object = instance[methodName](propertiesToInclude);&#13;
      if (!this.includeDefaultValues) {&#13;
        instance.includeDefaultValues = originalValue;&#13;
      }&#13;
      return object;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    __serializeBgOverlay: function(methodName, propertiesToInclude) {&#13;
      var data = { }, bgImage = this.backgroundImage, overlay = this.overlayImage;&#13;
&#13;
      if (this.backgroundColor) {&#13;
        data.background = this.backgroundColor.toObject&#13;
          ? this.backgroundColor.toObject(propertiesToInclude)&#13;
          : this.backgroundColor;&#13;
      }&#13;
&#13;
      if (this.overlayColor) {&#13;
        data.overlay = this.overlayColor.toObject&#13;
          ? this.overlayColor.toObject(propertiesToInclude)&#13;
          : this.overlayColor;&#13;
      }&#13;
      if (bgImage &amp;&amp; !bgImage.excludeFromExport) {&#13;
        data.backgroundImage = this._toObject(bgImage, methodName, propertiesToInclude);&#13;
      }&#13;
      if (overlay &amp;&amp; !overlay.excludeFromExport) {&#13;
        data.overlayImage = this._toObject(overlay, methodName, propertiesToInclude);&#13;
      }&#13;
&#13;
      return data;&#13;
    },&#13;
&#13;
    /* _TO_SVG_START_ */&#13;
    /**&#13;
     * When true, getSvgTransform() will apply the StaticCanvas.viewportTransform to the SVG transformation. When true,&#13;
     * a zoomed canvas will then produce zoomed SVG output.&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    svgViewportTransformation: true,&#13;
&#13;
    /**&#13;
     * Returns SVG representation of canvas&#13;
     * @function&#13;
     * @param {Object} [options] Options object for SVG output&#13;
     * @param {Boolean} [options.suppressPreamble=false] If true xml tag is not included&#13;
     * @param {Object} [options.viewBox] SVG viewbox object&#13;
     * @param {Number} [options.viewBox.x] x-cooridnate of viewbox&#13;
     * @param {Number} [options.viewBox.y] y-coordinate of viewbox&#13;
     * @param {Number} [options.viewBox.width] Width of viewbox&#13;
     * @param {Number} [options.viewBox.height] Height of viewbox&#13;
     * @param {String} [options.encoding=UTF-8] Encoding of SVG output&#13;
     * @param {String} [options.width] desired width of svg with or without units&#13;
     * @param {String} [options.height] desired height of svg with or without units&#13;
     * @param {Function} [reviver] Method for further parsing of svg elements, called after each fabric object converted into svg representation.&#13;
     * @return {String} SVG string&#13;
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#serialization}&#13;
     * @see {@link http://jsfiddle.net/fabricjs/jQ3ZZ/|jsFiddle demo}&#13;
     * @example &lt;caption&gt;Normal SVG output&lt;/caption&gt;&#13;
     * var svg = canvas.toSVG();&#13;
     * @example &lt;caption&gt;SVG output without preamble (without &amp;lt;?xml ../&gt;)&lt;/caption&gt;&#13;
     * var svg = canvas.toSVG({suppressPreamble: true});&#13;
     * @example &lt;caption&gt;SVG output with viewBox attribute&lt;/caption&gt;&#13;
     * var svg = canvas.toSVG({&#13;
     *   viewBox: {&#13;
     *     x: 100,&#13;
     *     y: 100,&#13;
     *     width: 200,&#13;
     *     height: 300&#13;
     *   }&#13;
     * });&#13;
     * @example &lt;caption&gt;SVG output with different encoding (default: UTF-8)&lt;/caption&gt;&#13;
     * var svg = canvas.toSVG({encoding: 'ISO-8859-1'});&#13;
     * @example &lt;caption&gt;Modify SVG output with reviver function&lt;/caption&gt;&#13;
     * var svg = canvas.toSVG(null, function(svg) {&#13;
     *   return svg.replace('stroke-dasharray: ; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; ', '');&#13;
     * });&#13;
     */&#13;
    toSVG: function(options, reviver) {&#13;
      options || (options = { });&#13;
&#13;
      var markup = [];&#13;
&#13;
      this._setSVGPreamble(markup, options);&#13;
      this._setSVGHeader(markup, options);&#13;
&#13;
      this._setSVGBgOverlayColor(markup, 'backgroundColor');&#13;
      this._setSVGBgOverlayImage(markup, 'backgroundImage', reviver);&#13;
&#13;
      this._setSVGObjects(markup, reviver);&#13;
&#13;
      this._setSVGBgOverlayColor(markup, 'overlayColor');&#13;
      this._setSVGBgOverlayImage(markup, 'overlayImage', reviver);&#13;
&#13;
      markup.push('&lt;/svg&gt;');&#13;
&#13;
      return markup.join('');&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _setSVGPreamble: function(markup, options) {&#13;
      if (options.suppressPreamble) {&#13;
        return;&#13;
      }&#13;
      markup.push(&#13;
        '&lt;?xml version="1.0" encoding="', (options.encoding || 'UTF-8'), '" standalone="no" ?&gt;\n',&#13;
        '&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" ',&#13;
        '"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt;\n'&#13;
      );&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _setSVGHeader: function(markup, options) {&#13;
      var width = options.width || this.width,&#13;
          height = options.height || this.height,&#13;
          vpt, viewBox = 'viewBox="0 0 ' + this.width + ' ' + this.height + '" ',&#13;
          NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;&#13;
&#13;
      if (options.viewBox) {&#13;
        viewBox = 'viewBox="' +&#13;
                options.viewBox.x + ' ' +&#13;
                options.viewBox.y + ' ' +&#13;
                options.viewBox.width + ' ' +&#13;
                options.viewBox.height + '" ';&#13;
      }&#13;
      else {&#13;
        if (this.svgViewportTransformation) {&#13;
          vpt = this.viewportTransform;&#13;
          viewBox = 'viewBox="' +&#13;
                  toFixed(-vpt[4] / vpt[0], NUM_FRACTION_DIGITS) + ' ' +&#13;
                  toFixed(-vpt[5] / vpt[3], NUM_FRACTION_DIGITS) + ' ' +&#13;
                  toFixed(this.width / vpt[0], NUM_FRACTION_DIGITS) + ' ' +&#13;
                  toFixed(this.height / vpt[3], NUM_FRACTION_DIGITS) + '" ';&#13;
        }&#13;
      }&#13;
&#13;
      markup.push(&#13;
        '&lt;svg ',&#13;
        'xmlns="http://www.w3.org/2000/svg" ',&#13;
        'xmlns:xlink="http://www.w3.org/1999/xlink" ',&#13;
        'version="1.1" ',&#13;
        'width="', width, '" ',&#13;
        'height="', height, '" ',&#13;
        viewBox,&#13;
        'xml:space="preserve"&gt;\n',&#13;
        '&lt;desc&gt;Created with Fabric.js ', fabric.version, '&lt;/desc&gt;\n',&#13;
        '&lt;defs&gt;\n',&#13;
        this.createSVGFontFacesMarkup(),&#13;
        this.createSVGRefElementsMarkup(),&#13;
        '&lt;/defs&gt;\n'&#13;
      );&#13;
    },&#13;
&#13;
    /**&#13;
     * Creates markup containing SVG referenced elements like patterns, gradients etc.&#13;
     * @return {String}&#13;
     */&#13;
    createSVGRefElementsMarkup: function() {&#13;
      var _this = this,&#13;
          markup = ['backgroundColor', 'overlayColor'].map(function(prop) {&#13;
            var fill = _this[prop];&#13;
            if (fill &amp;&amp; fill.toLive) {&#13;
              return fill.toSVG(_this, false);&#13;
            }&#13;
          });&#13;
      return markup.join('');&#13;
    },&#13;
&#13;
    /**&#13;
     * Creates markup containing SVG font faces,&#13;
     * font URLs for font faces must be collected by developers&#13;
     * and are not extracted from the DOM by fabricjs&#13;
     * @param {Array} objects Array of fabric objects&#13;
     * @return {String}&#13;
     */&#13;
    createSVGFontFacesMarkup: function() {&#13;
      var markup = '', fontList = { }, obj, fontFamily,&#13;
          style, row, rowIndex, _char, charIndex, i, len,&#13;
          fontPaths = fabric.fontPaths, objects = this.getObjects();&#13;
&#13;
      for (i = 0, len = objects.length; i &lt; len; i++) {&#13;
        obj = objects[i];&#13;
        fontFamily = obj.fontFamily;&#13;
        if (obj.type.indexOf('text') === -1 || fontList[fontFamily] || !fontPaths[fontFamily]) {&#13;
          continue;&#13;
        }&#13;
        fontList[fontFamily] = true;&#13;
        if (!obj.styles) {&#13;
          continue;&#13;
        }&#13;
        style = obj.styles;&#13;
        for (rowIndex in style) {&#13;
          row = style[rowIndex];&#13;
          for (charIndex in row) {&#13;
            _char = row[charIndex];&#13;
            fontFamily = _char.fontFamily;&#13;
            if (!fontList[fontFamily] &amp;&amp; fontPaths[fontFamily]) {&#13;
              fontList[fontFamily] = true;&#13;
            }&#13;
          }&#13;
        }&#13;
      }&#13;
&#13;
      for (var j in fontList) {&#13;
        markup += [&#13;
          '\t\t@font-face {\n',&#13;
          '\t\t\tfont-family: \'', j, '\';\n',&#13;
          '\t\t\tsrc: url(\'', fontPaths[j], '\');\n',&#13;
          '\t\t}\n'&#13;
        ].join('');&#13;
      }&#13;
&#13;
      if (markup) {&#13;
        markup = [&#13;
          '\t&lt;style type="text/css"&gt;',&#13;
          '&lt;![CDATA[\n',&#13;
          markup,&#13;
          ']]&gt;',&#13;
          '&lt;/style&gt;\n'&#13;
        ].join('');&#13;
      }&#13;
&#13;
      return markup;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _setSVGObjects: function(markup, reviver) {&#13;
      var instance, i, len, objects = this.getObjects();&#13;
      for (i = 0, len = objects.length; i &lt; len; i++) {&#13;
        instance = objects[i];&#13;
        if (instance.excludeFromExport) {&#13;
          continue;&#13;
        }&#13;
        this._setSVGObject(markup, instance, reviver);&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _setSVGObject: function(markup, instance, reviver) {&#13;
      markup.push(instance.toSVG(reviver));&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _setSVGBgOverlayImage: function(markup, property, reviver) {&#13;
      if (this[property] &amp;&amp; this[property].toSVG) {&#13;
        markup.push(this[property].toSVG(reviver));&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _setSVGBgOverlayColor: function(markup, property) {&#13;
      var filler = this[property];&#13;
      if (!filler) {&#13;
        return;&#13;
      }&#13;
      if (filler.toLive) {&#13;
        var repeat = filler.repeat;&#13;
        markup.push(&#13;
          '&lt;rect transform="translate(', this.width / 2, ',', this.height / 2, ')"',&#13;
          ' x="', filler.offsetX - this.width / 2, '" y="', filler.offsetY - this.height / 2, '" ',&#13;
          'width="',&#13;
          (repeat === 'repeat-y' || repeat === 'no-repeat'&#13;
            ? filler.source.width&#13;
            : this.width),&#13;
          '" height="',&#13;
          (repeat === 'repeat-x' || repeat === 'no-repeat'&#13;
            ? filler.source.height&#13;
            : this.height),&#13;
          '" fill="url(#SVGID_' + filler.id + ')"',&#13;
          '&gt;&lt;/rect&gt;\n'&#13;
        );&#13;
      }&#13;
      else {&#13;
        markup.push(&#13;
          '&lt;rect x="0" y="0" ',&#13;
          'width="', this.width,&#13;
          '" height="', this.height,&#13;
          '" fill="', this[property], '"',&#13;
          '&gt;&lt;/rect&gt;\n'&#13;
        );&#13;
      }&#13;
    },&#13;
    /* _TO_SVG_END_ */&#13;
&#13;
    /**&#13;
     * Moves an object or the objects of a multiple selection&#13;
     * to the bottom of the stack of drawn objects&#13;
     * @param {fabric.Object} object Object to send to back&#13;
     * @return {fabric.Canvas} thisArg&#13;
     * @chainable&#13;
     */&#13;
    sendToBack: function (object) {&#13;
      if (!object) {&#13;
        return this;&#13;
      }&#13;
      var activeSelection = this._activeObject,&#13;
          i, obj, objs;&#13;
      if (object === activeSelection &amp;&amp; object.type === 'activeSelection') {&#13;
        objs = activeSelection._objects;&#13;
        for (i = objs.length; i--;) {&#13;
          obj = objs[i];&#13;
          removeFromArray(this._objects, obj);&#13;
          this._objects.unshift(obj);&#13;
        }&#13;
      }&#13;
      else {&#13;
        removeFromArray(this._objects, object);&#13;
        this._objects.unshift(object);&#13;
      }&#13;
      this.renderOnAddRemove &amp;&amp; this.requestRenderAll();&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Moves an object or the objects of a multiple selection&#13;
     * to the top of the stack of drawn objects&#13;
     * @param {fabric.Object} object Object to send&#13;
     * @return {fabric.Canvas} thisArg&#13;
     * @chainable&#13;
     */&#13;
    bringToFront: function (object) {&#13;
      if (!object) {&#13;
        return this;&#13;
      }&#13;
      var activeSelection = this._activeObject,&#13;
          i, obj, objs;&#13;
      if (object === activeSelection &amp;&amp; object.type === 'activeSelection') {&#13;
        objs = activeSelection._objects;&#13;
        for (i = 0; i &lt; objs.length; i++) {&#13;
          obj = objs[i];&#13;
          removeFromArray(this._objects, obj);&#13;
          this._objects.push(obj);&#13;
        }&#13;
      }&#13;
      else {&#13;
        removeFromArray(this._objects, object);&#13;
        this._objects.push(object);&#13;
      }&#13;
      this.renderOnAddRemove &amp;&amp; this.requestRenderAll();&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Moves an object or a selection down in stack of drawn objects&#13;
     * An optional paramter, intersecting allowes to move the object in behind&#13;
     * the first intersecting object. Where intersection is calculated with&#13;
     * bounding box. If no intersection is found, there will not be change in the&#13;
     * stack.&#13;
     * @param {fabric.Object} object Object to send&#13;
     * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object&#13;
     * @return {fabric.Canvas} thisArg&#13;
     * @chainable&#13;
     */&#13;
    sendBackwards: function (object, intersecting) {&#13;
      if (!object) {&#13;
        return this;&#13;
      }&#13;
      var activeSelection = this._activeObject,&#13;
          i, obj, idx, newIdx, objs, objsMoved = 0;&#13;
&#13;
      if (object === activeSelection &amp;&amp; object.type === 'activeSelection') {&#13;
        objs = activeSelection._objects;&#13;
        for (i = 0; i &lt; objs.length; i++) {&#13;
          obj = objs[i];&#13;
          idx = this._objects.indexOf(obj);&#13;
          if (idx &gt; 0 + objsMoved) {&#13;
            newIdx = idx - 1;&#13;
            removeFromArray(this._objects, obj);&#13;
            this._objects.splice(newIdx, 0, obj);&#13;
          }&#13;
          objsMoved++;&#13;
        }&#13;
      }&#13;
      else {&#13;
        idx = this._objects.indexOf(object);&#13;
        if (idx !== 0) {&#13;
          // if object is not on the bottom of stack&#13;
          newIdx = this._findNewLowerIndex(object, idx, intersecting);&#13;
          removeFromArray(this._objects, object);&#13;
          this._objects.splice(newIdx, 0, object);&#13;
        }&#13;
      }&#13;
      this.renderOnAddRemove &amp;&amp; this.requestRenderAll();&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _findNewLowerIndex: function(object, idx, intersecting) {&#13;
      var newIdx, i;&#13;
&#13;
      if (intersecting) {&#13;
        newIdx = idx;&#13;
&#13;
        // traverse down the stack looking for the nearest intersecting object&#13;
        for (i = idx - 1; i &gt;= 0; --i) {&#13;
&#13;
          var isIntersecting = object.intersectsWithObject(this._objects[i]) ||&#13;
                               object.isContainedWithinObject(this._objects[i]) ||&#13;
                               this._objects[i].isContainedWithinObject(object);&#13;
&#13;
          if (isIntersecting) {&#13;
            newIdx = i;&#13;
            break;&#13;
          }&#13;
        }&#13;
      }&#13;
      else {&#13;
        newIdx = idx - 1;&#13;
      }&#13;
&#13;
      return newIdx;&#13;
    },&#13;
&#13;
    /**&#13;
     * Moves an object or a selection up in stack of drawn objects&#13;
     * An optional paramter, intersecting allowes to move the object in front&#13;
     * of the first intersecting object. Where intersection is calculated with&#13;
     * bounding box. If no intersection is found, there will not be change in the&#13;
     * stack.&#13;
     * @param {fabric.Object} object Object to send&#13;
     * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object&#13;
     * @return {fabric.Canvas} thisArg&#13;
     * @chainable&#13;
     */&#13;
    bringForward: function (object, intersecting) {&#13;
      if (!object) {&#13;
        return this;&#13;
      }&#13;
      var activeSelection = this._activeObject,&#13;
          i, obj, idx, newIdx, objs, objsMoved = 0;&#13;
&#13;
      if (object === activeSelection &amp;&amp; object.type === 'activeSelection') {&#13;
        objs = activeSelection._objects;&#13;
        for (i = objs.length; i--;) {&#13;
          obj = objs[i];&#13;
          idx = this._objects.indexOf(obj);&#13;
          if (idx &lt; this._objects.length - 1 - objsMoved) {&#13;
            newIdx = idx + 1;&#13;
            removeFromArray(this._objects, obj);&#13;
            this._objects.splice(newIdx, 0, obj);&#13;
          }&#13;
          objsMoved++;&#13;
        }&#13;
      }&#13;
      else {&#13;
        idx = this._objects.indexOf(object);&#13;
        if (idx !== this._objects.length - 1) {&#13;
          // if object is not on top of stack (last item in an array)&#13;
          newIdx = this._findNewUpperIndex(object, idx, intersecting);&#13;
          removeFromArray(this._objects, object);&#13;
          this._objects.splice(newIdx, 0, object);&#13;
        }&#13;
      }&#13;
      this.renderOnAddRemove &amp;&amp; this.requestRenderAll();&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _findNewUpperIndex: function(object, idx, intersecting) {&#13;
      var newIdx, i, len;&#13;
&#13;
      if (intersecting) {&#13;
        newIdx = idx;&#13;
&#13;
        // traverse up the stack looking for the nearest intersecting object&#13;
        for (i = idx + 1, len = this._objects.length; i &lt; len; ++i) {&#13;
&#13;
          var isIntersecting = object.intersectsWithObject(this._objects[i]) ||&#13;
                               object.isContainedWithinObject(this._objects[i]) ||&#13;
                               this._objects[i].isContainedWithinObject(object);&#13;
&#13;
          if (isIntersecting) {&#13;
            newIdx = i;&#13;
            break;&#13;
          }&#13;
        }&#13;
      }&#13;
      else {&#13;
        newIdx = idx + 1;&#13;
      }&#13;
&#13;
      return newIdx;&#13;
    },&#13;
&#13;
    /**&#13;
     * Moves an object to specified level in stack of drawn objects&#13;
     * @param {fabric.Object} object Object to send&#13;
     * @param {Number} index Position to move to&#13;
     * @return {fabric.Canvas} thisArg&#13;
     * @chainable&#13;
     */&#13;
    moveTo: function (object, index) {&#13;
      removeFromArray(this._objects, object);&#13;
      this._objects.splice(index, 0, object);&#13;
      return this.renderOnAddRemove &amp;&amp; this.requestRenderAll();&#13;
    },&#13;
&#13;
    /**&#13;
     * Clears a canvas element and dispose objects&#13;
     * @return {fabric.Canvas} thisArg&#13;
     * @chainable&#13;
     */&#13;
    dispose: function () {&#13;
      this.forEachObject(function(object) {&#13;
        object.dispose &amp;&amp; object.dispose();&#13;
      });&#13;
      this._objects = [];&#13;
      this.backgroundImage = null;&#13;
      this.overlayImage = null;&#13;
      this._iTextInstances = null;&#13;
      this.lowerCanvasEl = null;&#13;
      this.cacheCanvasEl = null;&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns a string representation of an instance&#13;
     * @return {String} string representation of an instance&#13;
     */&#13;
    toString: function () {&#13;
      return '#&lt;fabric.Canvas (' + this.complexity() + '): ' +&#13;
               '{ objects: ' + this.getObjects().length + ' }&gt;';&#13;
    }&#13;
  });&#13;
&#13;
  extend(fabric.StaticCanvas.prototype, fabric.Observable);&#13;
  extend(fabric.StaticCanvas.prototype, fabric.Collection);&#13;
  extend(fabric.StaticCanvas.prototype, fabric.DataURLExporter);&#13;
&#13;
  extend(fabric.StaticCanvas, /** @lends fabric.StaticCanvas */ {&#13;
&#13;
    /**&#13;
     * @static&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    EMPTY_JSON: '{"objects": [], "background": "white"}',&#13;
&#13;
    /**&#13;
     * Provides a way to check support of some of the canvas methods&#13;
     * (either those of HTMLCanvasElement itself, or rendering context)&#13;
     *&#13;
     * @param {String} methodName Method to check support for;&#13;
     *                            Could be one of "getImageData", "toDataURL", "toDataURLWithQuality" or "setLineDash"&#13;
     * @return {Boolean | null} `true` if method is supported (or at least exists),&#13;
     *                          `null` if canvas element or context can not be initialized&#13;
     */&#13;
    supports: function (methodName) {&#13;
      var el = fabric.util.createCanvasElement();&#13;
&#13;
      if (!el || !el.getContext) {&#13;
        return null;&#13;
      }&#13;
&#13;
      var ctx = el.getContext('2d');&#13;
      if (!ctx) {&#13;
        return null;&#13;
      }&#13;
&#13;
      switch (methodName) {&#13;
&#13;
        case 'getImageData':&#13;
          return typeof ctx.getImageData !== 'undefined';&#13;
&#13;
        case 'setLineDash':&#13;
          return typeof ctx.setLineDash !== 'undefined';&#13;
&#13;
        case 'toDataURL':&#13;
          return typeof el.toDataURL !== 'undefined';&#13;
&#13;
        case 'toDataURLWithQuality':&#13;
          try {&#13;
            el.toDataURL('image/jpeg', 0);&#13;
            return true;&#13;
          }&#13;
          catch (e) { }&#13;
          return false;&#13;
&#13;
        default:&#13;
          return null;&#13;
      }&#13;
    }&#13;
  });&#13;
&#13;
  /**&#13;
   * Returns JSON representation of canvas&#13;
   * @function&#13;
   * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output&#13;
   * @return {String} JSON string&#13;
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#serialization}&#13;
   * @see {@link http://jsfiddle.net/fabricjs/pec86/|jsFiddle demo}&#13;
   * @example &lt;caption&gt;JSON without additional properties&lt;/caption&gt;&#13;
   * var json = canvas.toJSON();&#13;
   * @example &lt;caption&gt;JSON with additional properties included&lt;/caption&gt;&#13;
   * var json = canvas.toJSON(['lockMovementX', 'lockMovementY', 'lockRotation', 'lockScalingX', 'lockScalingY', 'lockUniScaling']);&#13;
   * @example &lt;caption&gt;JSON without default values&lt;/caption&gt;&#13;
   * canvas.includeDefaultValues = false;&#13;
   * var json = canvas.toJSON();&#13;
   */&#13;
  fabric.StaticCanvas.prototype.toJSON = fabric.StaticCanvas.prototype.toObject;&#13;
&#13;
  if (fabric.isLikelyNode) {&#13;
    fabric.StaticCanvas.prototype.createPNGStream = function() {&#13;
      var impl = fabric.util.getNodeCanvas(this.lowerCanvasEl);&#13;
      return impl &amp;&amp; impl.createPNGStream();&#13;
    };&#13;
    fabric.StaticCanvas.prototype.createJPEGStream = function(opts) {&#13;
      var impl = fabric.util.getNodeCanvas(this.lowerCanvasEl);&#13;
      return impl &amp;&amp; impl.createJPEGStream(opts);&#13;
    };&#13;
  }&#13;
})();&#13;
&#13;
&#13;
/**&#13;
 * BaseBrush class&#13;
 * @class fabric.BaseBrush&#13;
 * @see {@link http://fabricjs.com/freedrawing|Freedrawing demo}&#13;
 */&#13;
fabric.BaseBrush = fabric.util.createClass(/** @lends fabric.BaseBrush.prototype */ {&#13;
&#13;
  /**&#13;
   * Color of a brush&#13;
   * @type String&#13;
   * @default&#13;
   */&#13;
  color: 'rgb(0, 0, 0)',&#13;
&#13;
  /**&#13;
   * Width of a brush, has to be a Number, no string literals&#13;
   * @type Number&#13;
   * @default&#13;
   */&#13;
  width: 1,&#13;
&#13;
  /**&#13;
   * Shadow object representing shadow of this shape.&#13;
   * &lt;b&gt;Backwards incompatibility note:&lt;/b&gt; This property replaces "shadowColor" (String), "shadowOffsetX" (Number),&#13;
   * "shadowOffsetY" (Number) and "shadowBlur" (Number) since v1.2.12&#13;
   * @type fabric.Shadow&#13;
   * @default&#13;
   */&#13;
  shadow: null,&#13;
&#13;
  /**&#13;
   * Line endings style of a brush (one of "butt", "round", "square")&#13;
   * @type String&#13;
   * @default&#13;
   */&#13;
  strokeLineCap: 'round',&#13;
&#13;
  /**&#13;
   * Corner style of a brush (one of "bevel", "round", "miter")&#13;
   * @type String&#13;
   * @default&#13;
   */&#13;
  strokeLineJoin: 'round',&#13;
&#13;
  /**&#13;
   * Maximum miter length (used for strokeLineJoin = "miter") of a brush's&#13;
   * @type Number&#13;
   * @default&#13;
   */&#13;
  strokeMiterLimit:         10,&#13;
&#13;
  /**&#13;
   * Stroke Dash Array.&#13;
   * @type Array&#13;
   * @default&#13;
   */&#13;
  strokeDashArray: null,&#13;
&#13;
  /**&#13;
   * Sets shadow of an object&#13;
   * @param {Object|String} [options] Options object or string (e.g. "2px 2px 10px rgba(0,0,0,0.2)")&#13;
   * @return {fabric.Object} thisArg&#13;
   * @chainable&#13;
   */&#13;
  setShadow: function(options) {&#13;
    this.shadow = new fabric.Shadow(options);&#13;
    return this;&#13;
  },&#13;
&#13;
  /**&#13;
   * Sets brush styles&#13;
   * @private&#13;
   */&#13;
  _setBrushStyles: function() {&#13;
    var ctx = this.canvas.contextTop;&#13;
    ctx.strokeStyle = this.color;&#13;
    ctx.lineWidth = this.width;&#13;
    ctx.lineCap = this.strokeLineCap;&#13;
    ctx.miterLimit = this.strokeMiterLimit;&#13;
    ctx.lineJoin = this.strokeLineJoin;&#13;
    if (this.strokeDashArray &amp;&amp; fabric.StaticCanvas.supports('setLineDash')) {&#13;
      ctx.setLineDash(this.strokeDashArray);&#13;
    }&#13;
  },&#13;
&#13;
  /**&#13;
   * Sets brush shadow styles&#13;
   * @private&#13;
   */&#13;
  _setShadow: function() {&#13;
    if (!this.shadow) {&#13;
      return;&#13;
    }&#13;
&#13;
    var ctx = this.canvas.contextTop,&#13;
        zoom = this.canvas.getZoom();&#13;
&#13;
    ctx.shadowColor = this.shadow.color;&#13;
    ctx.shadowBlur = this.shadow.blur * zoom;&#13;
    ctx.shadowOffsetX = this.shadow.offsetX * zoom;&#13;
    ctx.shadowOffsetY = this.shadow.offsetY * zoom;&#13;
  },&#13;
&#13;
  /**&#13;
   * Removes brush shadow styles&#13;
   * @private&#13;
   */&#13;
  _resetShadow: function() {&#13;
    var ctx = this.canvas.contextTop;&#13;
&#13;
    ctx.shadowColor = '';&#13;
    ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;&#13;
  }&#13;
});&#13;
&#13;
&#13;
(function() {&#13;
&#13;
  /**&#13;
   * PencilBrush class&#13;
   * @class fabric.PencilBrush&#13;
   * @extends fabric.BaseBrush&#13;
   */&#13;
  fabric.PencilBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.PencilBrush.prototype */ {&#13;
&#13;
    /**&#13;
     * Constructor&#13;
     * @param {fabric.Canvas} canvas&#13;
     * @return {fabric.PencilBrush} Instance of a pencil brush&#13;
     */&#13;
    initialize: function(canvas) {&#13;
      this.canvas = canvas;&#13;
      this._points = [];&#13;
    },&#13;
&#13;
    /**&#13;
     * Inovoked on mouse down&#13;
     * @param {Object} pointer&#13;
     */&#13;
    onMouseDown: function(pointer) {&#13;
      this._prepareForDrawing(pointer);&#13;
      // capture coordinates immediately&#13;
      // this allows to draw dots (when movement never occurs)&#13;
      this._captureDrawingPath(pointer);&#13;
      this._render();&#13;
    },&#13;
&#13;
    /**&#13;
     * Inovoked on mouse move&#13;
     * @param {Object} pointer&#13;
     */&#13;
    onMouseMove: function(pointer) {&#13;
      this._captureDrawingPath(pointer);&#13;
      // redraw curve&#13;
      // clear top canvas&#13;
      this.canvas.clearContext(this.canvas.contextTop);&#13;
      this._render();&#13;
    },&#13;
&#13;
    /**&#13;
     * Invoked on mouse up&#13;
     */&#13;
    onMouseUp: function() {&#13;
      this._finalizeAndAddPath();&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Object} pointer Actual mouse position related to the canvas.&#13;
     */&#13;
    _prepareForDrawing: function(pointer) {&#13;
&#13;
      var p = new fabric.Point(pointer.x, pointer.y);&#13;
&#13;
      this._reset();&#13;
      this._addPoint(p);&#13;
&#13;
      this.canvas.contextTop.moveTo(p.x, p.y);&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {fabric.Point} point Point to be added to points array&#13;
     */&#13;
    _addPoint: function(point) {&#13;
      if (this._points.length &gt; 1 &amp;&amp; point.eq(this._points[this._points.length - 1])) {&#13;
        return;&#13;
      }&#13;
      this._points.push(point);&#13;
    },&#13;
&#13;
    /**&#13;
     * Clear points array and set contextTop canvas style.&#13;
     * @private&#13;
     */&#13;
    _reset: function() {&#13;
      this._points.length = 0;&#13;
&#13;
      this._setBrushStyles();&#13;
      this._setShadow();&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Object} pointer Actual mouse position related to the canvas.&#13;
     */&#13;
    _captureDrawingPath: function(pointer) {&#13;
      var pointerPoint = new fabric.Point(pointer.x, pointer.y);&#13;
      this._addPoint(pointerPoint);&#13;
    },&#13;
&#13;
    /**&#13;
     * Draw a smooth path on the topCanvas using quadraticCurveTo&#13;
     * @private&#13;
     */&#13;
    _render: function() {&#13;
      var ctx  = this.canvas.contextTop, i, len,&#13;
          v = this.canvas.viewportTransform,&#13;
          p1 = this._points[0],&#13;
          p2 = this._points[1];&#13;
&#13;
      ctx.save();&#13;
      ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);&#13;
      ctx.beginPath();&#13;
      //if we only have 2 points in the path and they are the same&#13;
      //it means that the user only clicked the canvas without moving the mouse&#13;
      //then we should be drawing a dot. A path isn't drawn between two identical dots&#13;
      //that's why we set them apart a bit&#13;
      if (this._points.length === 2 &amp;&amp; p1.x === p2.x &amp;&amp; p1.y === p2.y) {&#13;
        var width = this.width / 1000;&#13;
        p1 = new fabric.Point(p1.x, p1.y);&#13;
        p2 = new fabric.Point(p2.x, p2.y);&#13;
        p1.x -= width;&#13;
        p2.x += width;&#13;
      }&#13;
      ctx.moveTo(p1.x, p1.y);&#13;
&#13;
      for (i = 1, len = this._points.length; i &lt; len; i++) {&#13;
        // we pick the point between pi + 1 &amp; pi + 2 as the&#13;
        // end point and p1 as our control point.&#13;
        var midPoint = p1.midPointFrom(p2);&#13;
        ctx.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);&#13;
&#13;
        p1 = this._points[i];&#13;
        p2 = this._points[i + 1];&#13;
      }&#13;
      // Draw last line as a straight line while&#13;
      // we wait for the next point to be able to calculate&#13;
      // the bezier control point&#13;
      ctx.lineTo(p1.x, p1.y);&#13;
      ctx.stroke();&#13;
      ctx.restore();&#13;
    },&#13;
&#13;
    /**&#13;
     * Converts points to SVG path&#13;
     * @param {Array} points Array of points&#13;
     * @return {String} SVG path&#13;
     */&#13;
    convertPointsToSVGPath: function(points) {&#13;
      var path = [], i, width = this.width / 1000,&#13;
          p1 = new fabric.Point(points[0].x, points[0].y),&#13;
          p2 = new fabric.Point(points[1].x, points[1].y),&#13;
          len = points.length, multSignX = 1, multSignY = 1, manyPoints = len &gt; 2;&#13;
&#13;
      if (manyPoints) {&#13;
        multSignX = points[2].x &lt; p2.x ? -1 : points[2].x === p2.x ? 0 : 1;&#13;
        multSignY = points[2].y &lt; p2.y ? -1 : points[2].y === p2.y ? 0 : 1;&#13;
      }&#13;
      path.push('M ', p1.x - multSignX * width, ' ', p1.y - multSignY * width, ' ');&#13;
      for (i = 1; i &lt; len; i++) {&#13;
        if (!p1.eq(p2)) {&#13;
          var midPoint = p1.midPointFrom(p2);&#13;
          // p1 is our bezier control point&#13;
          // midpoint is our endpoint&#13;
          // start point is p(i-1) value.&#13;
          path.push('Q ', p1.x, ' ', p1.y, ' ', midPoint.x, ' ', midPoint.y, ' ');&#13;
        }&#13;
        p1 = points[i];&#13;
        if ((i + 1) &lt; points.length) {&#13;
          p2 = points[i + 1];&#13;
        }&#13;
      }&#13;
      if (manyPoints) {&#13;
        multSignX = p1.x &gt; points[i - 2].x ? 1 : p1.x === points[i - 2].x ? 0 : -1;&#13;
        multSignY = p1.y &gt; points[i - 2].y ? 1 : p1.y === points[i - 2].y ? 0 : -1;&#13;
      }&#13;
      path.push('L ', p1.x + multSignX * width, ' ', p1.y + multSignY * width);&#13;
      return path;&#13;
    },&#13;
&#13;
    /**&#13;
     * Creates fabric.Path object to add on canvas&#13;
     * @param {String} pathData Path data&#13;
     * @return {fabric.Path} Path to add on canvas&#13;
     */&#13;
    createPath: function(pathData) {&#13;
      var path = new fabric.Path(pathData, {&#13;
        fill: null,&#13;
        stroke: this.color,&#13;
        strokeWidth: this.width,&#13;
        strokeLineCap: this.strokeLineCap,&#13;
        strokeMiterLimit: this.strokeMiterLimit,&#13;
        strokeLineJoin: this.strokeLineJoin,&#13;
        strokeDashArray: this.strokeDashArray,&#13;
      });&#13;
      var position = new fabric.Point(path.left + path.width / 2, path.top + path.height / 2);&#13;
      position = path.translateToGivenOrigin(position, 'center', 'center', path.originX, path.originY);&#13;
      path.top = position.y;&#13;
      path.left = position.x;&#13;
      if (this.shadow) {&#13;
        this.shadow.affectStroke = true;&#13;
        path.setShadow(this.shadow);&#13;
      }&#13;
&#13;
      return path;&#13;
    },&#13;
&#13;
    /**&#13;
     * On mouseup after drawing the path on contextTop canvas&#13;
     * we use the points captured to create an new fabric path object&#13;
     * and add it to the fabric canvas.&#13;
     */&#13;
    _finalizeAndAddPath: function() {&#13;
      var ctx = this.canvas.contextTop;&#13;
      ctx.closePath();&#13;
&#13;
      var pathData = this.convertPointsToSVGPath(this._points).join('');&#13;
      if (pathData === 'M 0 0 Q 0 0 0 0 L 0 0') {&#13;
        // do not create 0 width/height paths, as they are&#13;
        // rendered inconsistently across browsers&#13;
        // Firefox 4, for example, renders a dot,&#13;
        // whereas Chrome 10 renders nothing&#13;
        this.canvas.requestRenderAll();&#13;
        return;&#13;
      }&#13;
&#13;
      var path = this.createPath(pathData);&#13;
      this.canvas.clearContext(this.canvas.contextTop);&#13;
      this.canvas.add(path);&#13;
      this.canvas.renderAll();&#13;
      path.setCoords();&#13;
      this._resetShadow();&#13;
&#13;
&#13;
      // fire event 'path' created&#13;
      this.canvas.fire('path:created', { path: path });&#13;
    }&#13;
  });&#13;
})();&#13;
&#13;
&#13;
/**&#13;
 * CircleBrush class&#13;
 * @class fabric.CircleBrush&#13;
 */&#13;
fabric.CircleBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.CircleBrush.prototype */ {&#13;
&#13;
  /**&#13;
   * Width of a brush&#13;
   * @type Number&#13;
   * @default&#13;
   */&#13;
  width: 10,&#13;
&#13;
  /**&#13;
   * Constructor&#13;
   * @param {fabric.Canvas} canvas&#13;
   * @return {fabric.CircleBrush} Instance of a circle brush&#13;
   */&#13;
  initialize: function(canvas) {&#13;
    this.canvas = canvas;&#13;
    this.points = [];&#13;
  },&#13;
&#13;
  /**&#13;
   * Invoked inside on mouse down and mouse move&#13;
   * @param {Object} pointer&#13;
   */&#13;
  drawDot: function(pointer) {&#13;
    var point = this.addPoint(pointer),&#13;
        ctx = this.canvas.contextTop,&#13;
        v = this.canvas.viewportTransform;&#13;
    ctx.save();&#13;
    ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);&#13;
&#13;
    ctx.fillStyle = point.fill;&#13;
    ctx.beginPath();&#13;
    ctx.arc(point.x, point.y, point.radius, 0, Math.PI * 2, false);&#13;
    ctx.closePath();&#13;
    ctx.fill();&#13;
&#13;
    ctx.restore();&#13;
  },&#13;
&#13;
  /**&#13;
   * Invoked on mouse down&#13;
   */&#13;
  onMouseDown: function(pointer) {&#13;
    this.points.length = 0;&#13;
    this.canvas.clearContext(this.canvas.contextTop);&#13;
    this._setShadow();&#13;
    this.drawDot(pointer);&#13;
  },&#13;
&#13;
  /**&#13;
   * Invoked on mouse move&#13;
   * @param {Object} pointer&#13;
   */&#13;
  onMouseMove: function(pointer) {&#13;
    this.drawDot(pointer);&#13;
  },&#13;
&#13;
  /**&#13;
   * Invoked on mouse up&#13;
   */&#13;
  onMouseUp: function() {&#13;
    var originalRenderOnAddRemove = this.canvas.renderOnAddRemove, i, len;&#13;
    this.canvas.renderOnAddRemove = false;&#13;
&#13;
    var circles = [];&#13;
&#13;
    for (i = 0, len = this.points.length; i &lt; len; i++) {&#13;
      var point = this.points[i],&#13;
          circle = new fabric.Circle({&#13;
            radius: point.radius,&#13;
            left: point.x,&#13;
            top: point.y,&#13;
            originX: 'center',&#13;
            originY: 'center',&#13;
            fill: point.fill&#13;
          });&#13;
&#13;
      this.shadow &amp;&amp; circle.setShadow(this.shadow);&#13;
&#13;
      circles.push(circle);&#13;
    }&#13;
    var group = new fabric.Group(circles, { originX: 'center', originY: 'center' });&#13;
    group.canvas = this.canvas;&#13;
&#13;
    this.canvas.add(group);&#13;
    this.canvas.fire('path:created', { path: group });&#13;
&#13;
    this.canvas.clearContext(this.canvas.contextTop);&#13;
    this._resetShadow();&#13;
    this.canvas.renderOnAddRemove = originalRenderOnAddRemove;&#13;
    this.canvas.requestRenderAll();&#13;
  },&#13;
&#13;
  /**&#13;
   * @param {Object} pointer&#13;
   * @return {fabric.Point} Just added pointer point&#13;
   */&#13;
  addPoint: function(pointer) {&#13;
    var pointerPoint = new fabric.Point(pointer.x, pointer.y),&#13;
&#13;
        circleRadius = fabric.util.getRandomInt(&#13;
          Math.max(0, this.width - 20), this.width + 20) / 2,&#13;
&#13;
        circleColor = new fabric.Color(this.color)&#13;
          .setAlpha(fabric.util.getRandomInt(0, 100) / 100)&#13;
          .toRgba();&#13;
&#13;
    pointerPoint.radius = circleRadius;&#13;
    pointerPoint.fill = circleColor;&#13;
&#13;
    this.points.push(pointerPoint);&#13;
&#13;
    return pointerPoint;&#13;
  }&#13;
});&#13;
&#13;
&#13;
/**&#13;
 * SprayBrush class&#13;
 * @class fabric.SprayBrush&#13;
 */&#13;
fabric.SprayBrush = fabric.util.createClass( fabric.BaseBrush, /** @lends fabric.SprayBrush.prototype */ {&#13;
&#13;
  /**&#13;
   * Width of a spray&#13;
   * @type Number&#13;
   * @default&#13;
   */&#13;
  width:              10,&#13;
&#13;
  /**&#13;
   * Density of a spray (number of dots per chunk)&#13;
   * @type Number&#13;
   * @default&#13;
   */&#13;
  density:            20,&#13;
&#13;
  /**&#13;
   * Width of spray dots&#13;
   * @type Number&#13;
   * @default&#13;
   */&#13;
  dotWidth:           1,&#13;
&#13;
  /**&#13;
   * Width variance of spray dots&#13;
   * @type Number&#13;
   * @default&#13;
   */&#13;
  dotWidthVariance:   1,&#13;
&#13;
  /**&#13;
   * Whether opacity of a dot should be random&#13;
   * @type Boolean&#13;
   * @default&#13;
   */&#13;
  randomOpacity:        false,&#13;
&#13;
  /**&#13;
   * Whether overlapping dots (rectangles) should be removed (for performance reasons)&#13;
   * @type Boolean&#13;
   * @default&#13;
   */&#13;
  optimizeOverlapping:  true,&#13;
&#13;
  /**&#13;
   * Constructor&#13;
   * @param {fabric.Canvas} canvas&#13;
   * @return {fabric.SprayBrush} Instance of a spray brush&#13;
   */&#13;
  initialize: function(canvas) {&#13;
    this.canvas = canvas;&#13;
    this.sprayChunks = [];&#13;
  },&#13;
&#13;
  /**&#13;
   * Invoked on mouse down&#13;
   * @param {Object} pointer&#13;
   */&#13;
  onMouseDown: function(pointer) {&#13;
    this.sprayChunks.length = 0;&#13;
    this.canvas.clearContext(this.canvas.contextTop);&#13;
    this._setShadow();&#13;
&#13;
    this.addSprayChunk(pointer);&#13;
    this.render();&#13;
  },&#13;
&#13;
  /**&#13;
   * Invoked on mouse move&#13;
   * @param {Object} pointer&#13;
   */&#13;
  onMouseMove: function(pointer) {&#13;
    this.addSprayChunk(pointer);&#13;
    this.render();&#13;
  },&#13;
&#13;
  /**&#13;
   * Invoked on mouse up&#13;
   */&#13;
  onMouseUp: function() {&#13;
    var originalRenderOnAddRemove = this.canvas.renderOnAddRemove;&#13;
    this.canvas.renderOnAddRemove = false;&#13;
&#13;
    var rects = [];&#13;
&#13;
    for (var i = 0, ilen = this.sprayChunks.length; i &lt; ilen; i++) {&#13;
      var sprayChunk = this.sprayChunks[i];&#13;
&#13;
      for (var j = 0, jlen = sprayChunk.length; j &lt; jlen; j++) {&#13;
&#13;
        var rect = new fabric.Rect({&#13;
          width: sprayChunk[j].width,&#13;
          height: sprayChunk[j].width,&#13;
          left: sprayChunk[j].x + 1,&#13;
          top: sprayChunk[j].y + 1,&#13;
          originX: 'center',&#13;
          originY: 'center',&#13;
          fill: this.color&#13;
        });&#13;
&#13;
        this.shadow &amp;&amp; rect.setShadow(this.shadow);&#13;
        rects.push(rect);&#13;
      }&#13;
    }&#13;
&#13;
    if (this.optimizeOverlapping) {&#13;
      rects = this._getOptimizedRects(rects);&#13;
    }&#13;
&#13;
    var group = new fabric.Group(rects, { originX: 'center', originY: 'center' });&#13;
    group.canvas = this.canvas;&#13;
&#13;
    this.canvas.add(group);&#13;
    this.canvas.fire('path:created', { path: group });&#13;
&#13;
    this.canvas.clearContext(this.canvas.contextTop);&#13;
    this._resetShadow();&#13;
    this.canvas.renderOnAddRemove = originalRenderOnAddRemove;&#13;
    this.canvas.requestRenderAll();&#13;
  },&#13;
&#13;
  /**&#13;
   * @private&#13;
   * @param {Array} rects&#13;
   */&#13;
  _getOptimizedRects: function(rects) {&#13;
&#13;
    // avoid creating duplicate rects at the same coordinates&#13;
    var uniqueRects = { }, key, i, len;&#13;
&#13;
    for (i = 0, len = rects.length; i &lt; len; i++) {&#13;
      key = rects[i].left + '' + rects[i].top;&#13;
      if (!uniqueRects[key]) {&#13;
        uniqueRects[key] = rects[i];&#13;
      }&#13;
    }&#13;
    var uniqueRectsArray = [];&#13;
    for (key in uniqueRects) {&#13;
      uniqueRectsArray.push(uniqueRects[key]);&#13;
    }&#13;
&#13;
    return uniqueRectsArray;&#13;
  },&#13;
&#13;
  /**&#13;
   * Renders brush&#13;
   */&#13;
  render: function() {&#13;
    var ctx = this.canvas.contextTop;&#13;
    ctx.fillStyle = this.color;&#13;
&#13;
    var v = this.canvas.viewportTransform, i, len;&#13;
    ctx.save();&#13;
    ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);&#13;
&#13;
    for (i = 0, len = this.sprayChunkPoints.length; i &lt; len; i++) {&#13;
      var point = this.sprayChunkPoints[i];&#13;
      if (typeof point.opacity !== 'undefined') {&#13;
        ctx.globalAlpha = point.opacity;&#13;
      }&#13;
      ctx.fillRect(point.x, point.y, point.width, point.width);&#13;
    }&#13;
    ctx.restore();&#13;
  },&#13;
&#13;
  /**&#13;
   * @param {Object} pointer&#13;
   */&#13;
  addSprayChunk: function(pointer) {&#13;
    this.sprayChunkPoints = [];&#13;
&#13;
    var x, y, width, radius = this.width / 2, i;&#13;
&#13;
    for (i = 0; i &lt; this.density; i++) {&#13;
&#13;
      x = fabric.util.getRandomInt(pointer.x - radius, pointer.x + radius);&#13;
      y = fabric.util.getRandomInt(pointer.y - radius, pointer.y + radius);&#13;
&#13;
      if (this.dotWidthVariance) {&#13;
        width = fabric.util.getRandomInt(&#13;
          // bottom clamp width to 1&#13;
          Math.max(1, this.dotWidth - this.dotWidthVariance),&#13;
          this.dotWidth + this.dotWidthVariance);&#13;
      }&#13;
      else {&#13;
        width = this.dotWidth;&#13;
      }&#13;
&#13;
      var point = new fabric.Point(x, y);&#13;
      point.width = width;&#13;
&#13;
      if (this.randomOpacity) {&#13;
        point.opacity = fabric.util.getRandomInt(0, 100) / 100;&#13;
      }&#13;
&#13;
      this.sprayChunkPoints.push(point);&#13;
    }&#13;
&#13;
    this.sprayChunks.push(this.sprayChunkPoints);&#13;
  }&#13;
});&#13;
&#13;
&#13;
/**&#13;
 * PatternBrush class&#13;
 * @class fabric.PatternBrush&#13;
 * @extends fabric.BaseBrush&#13;
 */&#13;
fabric.PatternBrush = fabric.util.createClass(fabric.PencilBrush, /** @lends fabric.PatternBrush.prototype */ {&#13;
&#13;
  getPatternSrc: function() {&#13;
&#13;
    var dotWidth = 20,&#13;
        dotDistance = 5,&#13;
        patternCanvas = fabric.document.createElement('canvas'),&#13;
        patternCtx = patternCanvas.getContext('2d');&#13;
&#13;
    patternCanvas.width = patternCanvas.height = dotWidth + dotDistance;&#13;
&#13;
    patternCtx.fillStyle = this.color;&#13;
    patternCtx.beginPath();&#13;
    patternCtx.arc(dotWidth / 2, dotWidth / 2, dotWidth / 2, 0, Math.PI * 2, false);&#13;
    patternCtx.closePath();&#13;
    patternCtx.fill();&#13;
&#13;
    return patternCanvas;&#13;
  },&#13;
&#13;
  getPatternSrcFunction: function() {&#13;
    return String(this.getPatternSrc).replace('this.color', '"' + this.color + '"');&#13;
  },&#13;
&#13;
  /**&#13;
   * Creates "pattern" instance property&#13;
   */&#13;
  getPattern: function() {&#13;
    return this.canvas.contextTop.createPattern(this.source || this.getPatternSrc(), 'repeat');&#13;
  },&#13;
&#13;
  /**&#13;
   * Sets brush styles&#13;
   */&#13;
  _setBrushStyles: function() {&#13;
    this.callSuper('_setBrushStyles');&#13;
    this.canvas.contextTop.strokeStyle = this.getPattern();&#13;
  },&#13;
&#13;
  /**&#13;
   * Creates path&#13;
   */&#13;
  createPath: function(pathData) {&#13;
    var path = this.callSuper('createPath', pathData),&#13;
        topLeft = path._getLeftTopCoords().scalarAdd(path.strokeWidth / 2);&#13;
&#13;
    path.stroke = new fabric.Pattern({&#13;
      source: this.source || this.getPatternSrcFunction(),&#13;
      offsetX: -topLeft.x,&#13;
      offsetY: -topLeft.y&#13;
    });&#13;
    return path;&#13;
  }&#13;
});&#13;
&#13;
&#13;
(function() {&#13;
&#13;
  var getPointer = fabric.util.getPointer,&#13;
      degreesToRadians = fabric.util.degreesToRadians,&#13;
      radiansToDegrees = fabric.util.radiansToDegrees,&#13;
      atan2 = Math.atan2,&#13;
      abs = Math.abs,&#13;
      supportLineDash = fabric.StaticCanvas.supports('setLineDash'),&#13;
&#13;
      STROKE_OFFSET = 0.5;&#13;
&#13;
  /**&#13;
   * Canvas class&#13;
   * @class fabric.Canvas&#13;
   * @extends fabric.StaticCanvas&#13;
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#canvas}&#13;
   * @see {@link fabric.Canvas#initialize} for constructor definition&#13;
   *&#13;
   * @fires object:added&#13;
   * @fires object:removed&#13;
   * @fires object:modified&#13;
   * @fires object:rotating&#13;
   * @fires object:scaling&#13;
   * @fires object:moving&#13;
   * @fires object:selected this event is deprecated. use selection:created&#13;
   *&#13;
   * @fires before:selection:cleared&#13;
   * @fires selection:cleared&#13;
   * @fires selection:updated&#13;
   * @fires selection:created&#13;
   *&#13;
   * @fires path:created&#13;
   * @fires mouse:down&#13;
   * @fires mouse:move&#13;
   * @fires mouse:up&#13;
   * @fires mouse:over&#13;
   * @fires mouse:out&#13;
   * @fires mouse:dblclick&#13;
   *&#13;
   */&#13;
  fabric.Canvas = fabric.util.createClass(fabric.StaticCanvas, /** @lends fabric.Canvas.prototype */ {&#13;
&#13;
    /**&#13;
     * Constructor&#13;
     * @param {HTMLElement | String} el &amp;lt;canvas&gt; element to initialize instance on&#13;
     * @param {Object} [options] Options object&#13;
     * @return {Object} thisArg&#13;
     */&#13;
    initialize: function(el, options) {&#13;
      options || (options = { });&#13;
      this.renderAndResetBound = this.renderAndReset.bind(this);&#13;
      this._initStatic(el, options);&#13;
      this._initInteractive();&#13;
      this._createCacheCanvas();&#13;
    },&#13;
&#13;
    /**&#13;
     * When true, objects can be transformed by one side (unproportionally)&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    uniScaleTransform:      false,&#13;
&#13;
    /**&#13;
     * Indicates which key enable unproportional scaling&#13;
     * values: 'altKey', 'shiftKey', 'ctrlKey'.&#13;
     * If `null` or 'none' or any other string that is not a modifier key&#13;
     * feature is disabled feature disabled.&#13;
     * @since 1.6.2&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    uniScaleKey:           'shiftKey',&#13;
&#13;
    /**&#13;
     * When true, objects use center point as the origin of scale transformation.&#13;
     * &lt;b&gt;Backwards incompatibility note:&lt;/b&gt; This property replaces "centerTransform" (Boolean).&#13;
     * @since 1.3.4&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    centeredScaling:        false,&#13;
&#13;
    /**&#13;
     * When true, objects use center point as the origin of rotate transformation.&#13;
     * &lt;b&gt;Backwards incompatibility note:&lt;/b&gt; This property replaces "centerTransform" (Boolean).&#13;
     * @since 1.3.4&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    centeredRotation:       false,&#13;
&#13;
    /**&#13;
     * Indicates which key enable centered Transform&#13;
     * values: 'altKey', 'shiftKey', 'ctrlKey'.&#13;
     * If `null` or 'none' or any other string that is not a modifier key&#13;
     * feature is disabled feature disabled.&#13;
     * @since 1.6.2&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    centeredKey:           'altKey',&#13;
&#13;
    /**&#13;
     * Indicates which key enable alternate action on corner&#13;
     * values: 'altKey', 'shiftKey', 'ctrlKey'.&#13;
     * If `null` or 'none' or any other string that is not a modifier key&#13;
     * feature is disabled feature disabled.&#13;
     * @since 1.6.2&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    altActionKey:           'shiftKey',&#13;
&#13;
    /**&#13;
     * Indicates that canvas is interactive. This property should not be changed.&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    interactive:            true,&#13;
&#13;
    /**&#13;
     * Indicates whether group selection should be enabled&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    selection:              true,&#13;
&#13;
    /**&#13;
     * Indicates which key or keys enable multiple click selection&#13;
     * Pass value as a string or array of strings&#13;
     * values: 'altKey', 'shiftKey', 'ctrlKey'.&#13;
     * If `null` or empty or containing any other string that is not a modifier key&#13;
     * feature is disabled.&#13;
     * @since 1.6.2&#13;
     * @type String|Array&#13;
     * @default&#13;
     */&#13;
    selectionKey:           'shiftKey',&#13;
&#13;
    /**&#13;
     * Indicates which key enable alternative selection&#13;
     * in case of target overlapping with active object&#13;
     * values: 'altKey', 'shiftKey', 'ctrlKey'.&#13;
     * If `null` or 'none' or any other string that is not a modifier key&#13;
     * feature is disabled feature disabled.&#13;
     * @since 1.6.5&#13;
     * @type null|String&#13;
     * @default&#13;
     */&#13;
    altSelectionKey:           null,&#13;
&#13;
    /**&#13;
     * Color of selection&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    selectionColor:         'rgba(100, 100, 255, 0.3)', // blue&#13;
&#13;
    /**&#13;
     * Default dash array pattern&#13;
     * If not empty the selection border is dashed&#13;
     * @type Array&#13;
     */&#13;
    selectionDashArray:     [],&#13;
&#13;
    /**&#13;
     * Color of the border of selection (usually slightly darker than color of selection itself)&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    selectionBorderColor:   'rgba(255, 255, 255, 0.3)',&#13;
&#13;
    /**&#13;
     * Width of a line used in object/group selection&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    selectionLineWidth:     1,&#13;
&#13;
    /**&#13;
     * Select only shapes that are fully contained in the dragged selection rectangle.&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    selectionFullyContained: false,&#13;
&#13;
    /**&#13;
     * Default cursor value used when hovering over an object on canvas&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    hoverCursor:            'move',&#13;
&#13;
    /**&#13;
     * Default cursor value used when moving an object on canvas&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    moveCursor:             'move',&#13;
&#13;
    /**&#13;
     * Default cursor value used for the entire canvas&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    defaultCursor:          'default',&#13;
&#13;
    /**&#13;
     * Cursor value used during free drawing&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    freeDrawingCursor:      'crosshair',&#13;
&#13;
    /**&#13;
     * Cursor value used for rotation point&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    rotationCursor:         'crosshair',&#13;
&#13;
    /**&#13;
     * Cursor value used for disabled elements ( corners with disabled action )&#13;
     * @type String&#13;
     * @since 2.0.0&#13;
     * @default&#13;
     */&#13;
    notAllowedCursor:         'not-allowed',&#13;
&#13;
    /**&#13;
     * Default element class that's given to wrapper (div) element of canvas&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    containerClass:         'canvas-container',&#13;
&#13;
    /**&#13;
     * When true, object detection happens on per-pixel basis rather than on per-bounding-box&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    perPixelTargetFind:     false,&#13;
&#13;
    /**&#13;
     * Number of pixels around target pixel to tolerate (consider active) during object detection&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    targetFindTolerance:    0,&#13;
&#13;
    /**&#13;
     * When true, target detection is skipped when hovering over canvas. This can be used to improve performance.&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    skipTargetFind:         false,&#13;
&#13;
    /**&#13;
     * When true, mouse events on canvas (mousedown/mousemove/mouseup) result in free drawing.&#13;
     * After mousedown, mousemove creates a shape,&#13;
     * and then mouseup finalizes it and adds an instance of `fabric.Path` onto canvas.&#13;
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-4#free_drawing}&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    isDrawingMode:          false,&#13;
&#13;
    /**&#13;
     * Indicates whether objects should remain in current stack position when selected.&#13;
     * When false objects are brought to top and rendered as part of the selection group&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    preserveObjectStacking: false,&#13;
&#13;
    /**&#13;
     * Indicates the angle that an object will lock to while rotating.&#13;
     * @type Number&#13;
     * @since 1.6.7&#13;
     * @default&#13;
     */&#13;
    snapAngle: 0,&#13;
&#13;
    /**&#13;
     * Indicates the distance from the snapAngle the rotation will lock to the snapAngle.&#13;
     * When `null`, the snapThreshold will default to the snapAngle.&#13;
     * @type null|Number&#13;
     * @since 1.6.7&#13;
     * @default&#13;
     */&#13;
    snapThreshold: null,&#13;
&#13;
    /**&#13;
     * Indicates if the right click on canvas can output the context menu or not&#13;
     * @type Boolean&#13;
     * @since 1.6.5&#13;
     * @default&#13;
     */&#13;
    stopContextMenu: false,&#13;
&#13;
    /**&#13;
     * Indicates if the canvas can fire right click events&#13;
     * @type Boolean&#13;
     * @since 1.6.5&#13;
     * @default&#13;
     */&#13;
    fireRightClick: false,&#13;
&#13;
    /**&#13;
     * Indicates if the canvas can fire middle click events&#13;
     * @type Boolean&#13;
     * @since 1.7.8&#13;
     * @default&#13;
     */&#13;
    fireMiddleClick: false,&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _initInteractive: function() {&#13;
      this._currentTransform = null;&#13;
      this._groupSelector = null;&#13;
      this._initWrapperElement();&#13;
      this._createUpperCanvas();&#13;
      this._initEventListeners();&#13;
&#13;
      this._initRetinaScaling();&#13;
&#13;
      this.freeDrawingBrush = fabric.PencilBrush &amp;&amp; new fabric.PencilBrush(this);&#13;
&#13;
      this.calcOffset();&#13;
    },&#13;
&#13;
    /**&#13;
     * Divides objects in two groups, one to render immediately&#13;
     * and one to render as activeGroup.&#13;
     * @return {Array} objects to render immediately and pushes the other in the activeGroup.&#13;
     */&#13;
    _chooseObjectsToRender: function() {&#13;
      var activeObjects = this.getActiveObjects(),&#13;
          object, objsToRender, activeGroupObjects;&#13;
&#13;
      if (activeObjects.length &gt; 0 &amp;&amp; !this.preserveObjectStacking) {&#13;
        objsToRender = [];&#13;
        activeGroupObjects = [];&#13;
        for (var i = 0, length = this._objects.length; i &lt; length; i++) {&#13;
          object = this._objects[i];&#13;
          if (activeObjects.indexOf(object) === -1 ) {&#13;
            objsToRender.push(object);&#13;
          }&#13;
          else {&#13;
            activeGroupObjects.push(object);&#13;
          }&#13;
        }&#13;
        if (activeObjects.length &gt; 1) {&#13;
          this._activeObject._objects = activeGroupObjects;&#13;
        }&#13;
        objsToRender.push.apply(objsToRender, activeGroupObjects);&#13;
      }&#13;
      else {&#13;
        objsToRender = this._objects;&#13;
      }&#13;
      return objsToRender;&#13;
    },&#13;
&#13;
    /**&#13;
     * Renders both the top canvas and the secondary container canvas.&#13;
     * @return {fabric.Canvas} instance&#13;
     * @chainable&#13;
     */&#13;
    renderAll: function () {&#13;
      if (this.contextTopDirty &amp;&amp; !this._groupSelector &amp;&amp; !this.isDrawingMode) {&#13;
        this.clearContext(this.contextTop);&#13;
        this.contextTopDirty = false;&#13;
      }&#13;
      if (this.isDrawingMode &amp;&amp; this._isCurrentlyDrawing) {&#13;
        this.freeDrawingBrush &amp;&amp; this.freeDrawingBrush._render();&#13;
      }&#13;
      var canvasToDrawOn = this.contextContainer;&#13;
      this.renderCanvas(canvasToDrawOn, this._chooseObjectsToRender());&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Method to render only the top canvas.&#13;
     * Also used to render the group selection box.&#13;
     * @return {fabric.Canvas} thisArg&#13;
     * @chainable&#13;
     */&#13;
    renderTop: function () {&#13;
      var ctx = this.contextTop;&#13;
      this.clearContext(ctx);&#13;
&#13;
      // we render the top context - last object&#13;
      if (this.selection &amp;&amp; this._groupSelector) {&#13;
        this._drawSelection(ctx);&#13;
      }&#13;
&#13;
      this.fire('after:render');&#13;
      this.contextTopDirty = true;&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Resets the current transform to its original values and chooses the type of resizing based on the event&#13;
     * @private&#13;
     */&#13;
    _resetCurrentTransform: function() {&#13;
      var t = this._currentTransform;&#13;
&#13;
      t.target.set({&#13;
        scaleX: t.original.scaleX,&#13;
        scaleY: t.original.scaleY,&#13;
        skewX: t.original.skewX,&#13;
        skewY: t.original.skewY,&#13;
        left: t.original.left,&#13;
        top: t.original.top&#13;
      });&#13;
&#13;
      if (this._shouldCenterTransform(t.target)) {&#13;
        if (t.action === 'rotate') {&#13;
          this._setOriginToCenter(t.target);&#13;
        }&#13;
        else {&#13;
          if (t.originX !== 'center') {&#13;
            if (t.originX === 'right') {&#13;
              t.mouseXSign = -1;&#13;
            }&#13;
            else {&#13;
              t.mouseXSign = 1;&#13;
            }&#13;
          }&#13;
          if (t.originY !== 'center') {&#13;
            if (t.originY === 'bottom') {&#13;
              t.mouseYSign = -1;&#13;
            }&#13;
            else {&#13;
              t.mouseYSign = 1;&#13;
            }&#13;
          }&#13;
&#13;
          t.originX = 'center';&#13;
          t.originY = 'center';&#13;
        }&#13;
      }&#13;
      else {&#13;
        t.originX = t.original.originX;&#13;
        t.originY = t.original.originY;&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Checks if point is contained within an area of given object&#13;
     * @param {Event} e Event object&#13;
     * @param {fabric.Object} target Object to test against&#13;
     * @param {Object} [point] x,y object of point coordinates we want to check.&#13;
     * @return {Boolean} true if point is contained within an area of given object&#13;
     */&#13;
    containsPoint: function (e, target, point) {&#13;
      var ignoreZoom = true,&#13;
          pointer = point || this.getPointer(e, ignoreZoom),&#13;
          xy;&#13;
&#13;
      if (target.group &amp;&amp; target.group === this._activeObject &amp;&amp; target.group.type === 'activeSelection') {&#13;
        xy = this._normalizePointer(target.group, pointer);&#13;
      }&#13;
      else {&#13;
        xy = { x: pointer.x, y: pointer.y };&#13;
      }&#13;
      // http://www.geog.ubc.ca/courses/klink/gis.notes/ncgia/u32.html&#13;
      // http://idav.ucdavis.edu/~okreylos/TAship/Spring2000/PointInPolygon.html&#13;
      return (target.containsPoint(xy) || target._findTargetCorner(pointer));&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _normalizePointer: function (object, pointer) {&#13;
      var m = object.calcTransformMatrix(),&#13;
          invertedM = fabric.util.invertTransform(m),&#13;
          vptPointer = this.restorePointerVpt(pointer);&#13;
      return fabric.util.transformPoint(vptPointer, invertedM);&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns true if object is transparent at a certain location&#13;
     * @param {fabric.Object} target Object to check&#13;
     * @param {Number} x Left coordinate&#13;
     * @param {Number} y Top coordinate&#13;
     * @return {Boolean}&#13;
     */&#13;
    isTargetTransparent: function (target, x, y) {&#13;
      var ctx = this.contextCache,&#13;
          originalColor = target.selectionBackgroundColor, v = this.viewportTransform;&#13;
&#13;
      target.selectionBackgroundColor = '';&#13;
&#13;
      this.clearContext(ctx);&#13;
&#13;
      ctx.save();&#13;
      ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);&#13;
      target.render(ctx);&#13;
      ctx.restore();&#13;
&#13;
      target === this._activeObject &amp;&amp; target._renderControls(ctx, {&#13;
        hasBorders: false,&#13;
        transparentCorners: false&#13;
      }, {&#13;
        hasBorders: false,&#13;
      });&#13;
&#13;
      target.selectionBackgroundColor = originalColor;&#13;
&#13;
      var isTransparent = fabric.util.isTransparent(&#13;
        ctx, x, y, this.targetFindTolerance);&#13;
&#13;
      return isTransparent;&#13;
    },&#13;
&#13;
    /**&#13;
     * takes an event and determins if selection key has been pressed&#13;
     * @private&#13;
     * @param {Event} e Event object&#13;
     */&#13;
    _isSelectionKeyPressed: function(e) {&#13;
      var selectionKeyPressed = false;&#13;
&#13;
      if (Object.prototype.toString.call(this.selectionKey) === '[object Array]') {&#13;
        selectionKeyPressed = !!this.selectionKey.find(function(key) { return e[key] === true; });&#13;
      }&#13;
      else {&#13;
        selectionKeyPressed = e[this.selectionKey];&#13;
      }&#13;
&#13;
      return selectionKeyPressed;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Event} e Event object&#13;
     * @param {fabric.Object} target&#13;
     */&#13;
    _shouldClearSelection: function (e, target) {&#13;
      var activeObjects = this.getActiveObjects(),&#13;
          activeObject = this._activeObject;&#13;
&#13;
      return (&#13;
        !target&#13;
        ||&#13;
        (target &amp;&amp;&#13;
          activeObject &amp;&amp;&#13;
          activeObjects.length &gt; 1 &amp;&amp;&#13;
          activeObjects.indexOf(target) === -1 &amp;&amp;&#13;
          activeObject !== target &amp;&amp;&#13;
          !this._isSelectionKeyPressed(e))&#13;
        ||&#13;
        (target &amp;&amp; !target.evented)&#13;
        ||&#13;
        (target &amp;&amp;&#13;
          !target.selectable &amp;&amp;&#13;
          activeObject &amp;&amp;&#13;
          activeObject !== target)&#13;
      );&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {fabric.Object} target&#13;
     */&#13;
    _shouldCenterTransform: function (target) {&#13;
      if (!target) {&#13;
        return;&#13;
      }&#13;
&#13;
      var t = this._currentTransform,&#13;
          centerTransform;&#13;
&#13;
      if (t.action === 'scale' || t.action === 'scaleX' || t.action === 'scaleY') {&#13;
        centerTransform = this.centeredScaling || target.centeredScaling;&#13;
      }&#13;
      else if (t.action === 'rotate') {&#13;
        centerTransform = this.centeredRotation || target.centeredRotation;&#13;
      }&#13;
&#13;
      return centerTransform ? !t.altKey : t.altKey;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _getOriginFromCorner: function(target, corner) {&#13;
      var origin = {&#13;
        x: target.originX,&#13;
        y: target.originY&#13;
      };&#13;
&#13;
      if (corner === 'ml' || corner === 'tl' || corner === 'bl') {&#13;
        origin.x = 'right';&#13;
      }&#13;
      else if (corner === 'mr' || corner === 'tr' || corner === 'br') {&#13;
        origin.x = 'left';&#13;
      }&#13;
&#13;
      if (corner === 'tl' || corner === 'mt' || corner === 'tr') {&#13;
        origin.y = 'bottom';&#13;
      }&#13;
      else if (corner === 'bl' || corner === 'mb' || corner === 'br') {&#13;
        origin.y = 'top';&#13;
      }&#13;
&#13;
      return origin;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _getActionFromCorner: function(target, corner, e) {&#13;
      if (!corner) {&#13;
        return 'drag';&#13;
      }&#13;
&#13;
      switch (corner) {&#13;
        case 'mtr':&#13;
          return 'rotate';&#13;
        case 'ml':&#13;
        case 'mr':&#13;
          return e[this.altActionKey] ? 'skewY' : 'scaleX';&#13;
        case 'mt':&#13;
        case 'mb':&#13;
          return e[this.altActionKey] ? 'skewX' : 'scaleY';&#13;
        default:&#13;
          return 'scale';&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Event} e Event object&#13;
     * @param {fabric.Object} target&#13;
     */&#13;
    _setupCurrentTransform: function (e, target) {&#13;
      if (!target) {&#13;
        return;&#13;
      }&#13;
&#13;
      var pointer = this.getPointer(e),&#13;
          corner = target._findTargetCorner(this.getPointer(e, true)),&#13;
          action = this._getActionFromCorner(target, corner, e),&#13;
          origin = this._getOriginFromCorner(target, corner);&#13;
&#13;
      this._currentTransform = {&#13;
        target: target,&#13;
        action: action,&#13;
        corner: corner,&#13;
        scaleX: target.scaleX,&#13;
        scaleY: target.scaleY,&#13;
        skewX: target.skewX,&#13;
        skewY: target.skewY,&#13;
        offsetX: pointer.x - target.left,&#13;
        offsetY: pointer.y - target.top,&#13;
        originX: origin.x,&#13;
        originY: origin.y,&#13;
        ex: pointer.x,&#13;
        ey: pointer.y,&#13;
        lastX: pointer.x,&#13;
        lastY: pointer.y,&#13;
        left: target.left,&#13;
        top: target.top,&#13;
        theta: degreesToRadians(target.angle),&#13;
        width: target.width * target.scaleX,&#13;
        mouseXSign: 1,&#13;
        mouseYSign: 1,&#13;
        shiftKey: e.shiftKey,&#13;
        altKey: e[this.centeredKey]&#13;
      };&#13;
&#13;
      this._currentTransform.original = {&#13;
        left: target.left,&#13;
        top: target.top,&#13;
        scaleX: target.scaleX,&#13;
        scaleY: target.scaleY,&#13;
        skewX: target.skewX,&#13;
        skewY: target.skewY,&#13;
        originX: origin.x,&#13;
        originY: origin.y&#13;
      };&#13;
&#13;
      this._resetCurrentTransform();&#13;
    },&#13;
&#13;
    /**&#13;
     * Translates object by "setting" its left/top&#13;
     * @private&#13;
     * @param {Number} x pointer's x coordinate&#13;
     * @param {Number} y pointer's y coordinate&#13;
     * @return {Boolean} true if the translation occurred&#13;
     */&#13;
    _translateObject: function (x, y) {&#13;
      var transform = this._currentTransform,&#13;
          target = transform.target,&#13;
          newLeft = x - transform.offsetX,&#13;
          newTop = y - transform.offsetY,&#13;
          moveX = !target.get('lockMovementX') &amp;&amp; target.left !== newLeft,&#13;
          moveY = !target.get('lockMovementY') &amp;&amp; target.top !== newTop;&#13;
&#13;
      moveX &amp;&amp; target.set('left', newLeft);&#13;
      moveY &amp;&amp; target.set('top', newTop);&#13;
      return moveX || moveY;&#13;
    },&#13;
&#13;
    /**&#13;
     * Check if we are increasing a positive skew or lower it,&#13;
     * checking mouse direction and pressed corner.&#13;
     * @private&#13;
     */&#13;
    _changeSkewTransformOrigin: function(mouseMove, t, by) {&#13;
      var property = 'originX', origins = { 0: 'center' },&#13;
          skew = t.target.skewX, originA = 'left', originB = 'right',&#13;
          corner = t.corner === 'mt' || t.corner === 'ml' ? 1 : -1,&#13;
          flipSign = 1;&#13;
&#13;
      mouseMove = mouseMove &gt; 0 ? 1 : -1;&#13;
      if (by === 'y') {&#13;
        skew = t.target.skewY;&#13;
        originA = 'top';&#13;
        originB = 'bottom';&#13;
        property = 'originY';&#13;
      }&#13;
      origins[-1] = originA;&#13;
      origins[1] = originB;&#13;
&#13;
      t.target.flipX &amp;&amp; (flipSign *= -1);&#13;
      t.target.flipY &amp;&amp; (flipSign *= -1);&#13;
&#13;
      if (skew === 0) {&#13;
        t.skewSign = -corner * mouseMove * flipSign;&#13;
        t[property] = origins[-mouseMove];&#13;
      }&#13;
      else {&#13;
        skew = skew &gt; 0 ? 1 : -1;&#13;
        t.skewSign = skew;&#13;
        t[property] = origins[skew * corner * flipSign];&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Skew object by mouse events&#13;
     * @private&#13;
     * @param {Number} x pointer's x coordinate&#13;
     * @param {Number} y pointer's y coordinate&#13;
     * @param {String} by Either 'x' or 'y'&#13;
     * @return {Boolean} true if the skewing occurred&#13;
     */&#13;
    _skewObject: function (x, y, by) {&#13;
      var t = this._currentTransform,&#13;
          target = t.target, skewed = false,&#13;
          lockSkewingX = target.get('lockSkewingX'),&#13;
          lockSkewingY = target.get('lockSkewingY');&#13;
&#13;
      if ((lockSkewingX &amp;&amp; by === 'x') || (lockSkewingY &amp;&amp; by === 'y')) {&#13;
        return false;&#13;
      }&#13;
&#13;
      // Get the constraint point&#13;
      var center = target.getCenterPoint(),&#13;
          actualMouseByCenter = target.toLocalPoint(new fabric.Point(x, y), 'center', 'center')[by],&#13;
          lastMouseByCenter = target.toLocalPoint(new fabric.Point(t.lastX, t.lastY), 'center', 'center')[by],&#13;
          actualMouseByOrigin, constraintPosition, dim = target._getTransformedDimensions();&#13;
&#13;
      this._changeSkewTransformOrigin(actualMouseByCenter - lastMouseByCenter, t, by);&#13;
      actualMouseByOrigin = target.toLocalPoint(new fabric.Point(x, y), t.originX, t.originY)[by];&#13;
      constraintPosition = target.translateToOriginPoint(center, t.originX, t.originY);&#13;
      // Actually skew the object&#13;
      skewed = this._setObjectSkew(actualMouseByOrigin, t, by, dim);&#13;
      t.lastX = x;&#13;
      t.lastY = y;&#13;
      // Make sure the constraints apply&#13;
      target.setPositionByOrigin(constraintPosition, t.originX, t.originY);&#13;
      return skewed;&#13;
    },&#13;
&#13;
    /**&#13;
     * Set object skew&#13;
     * @private&#13;
     * @return {Boolean} true if the skewing occurred&#13;
     */&#13;
    _setObjectSkew: function(localMouse, transform, by, _dim) {&#13;
      var target = transform.target, newValue, skewed = false,&#13;
          skewSign = transform.skewSign, newDim, dimNoSkew,&#13;
          otherBy, _otherBy, _by, newDimMouse, skewX, skewY;&#13;
&#13;
      if (by === 'x') {&#13;
        otherBy = 'y';&#13;
        _otherBy = 'Y';&#13;
        _by = 'X';&#13;
        skewX = 0;&#13;
        skewY = target.skewY;&#13;
      }&#13;
      else {&#13;
        otherBy = 'x';&#13;
        _otherBy = 'X';&#13;
        _by = 'Y';&#13;
        skewX = target.skewX;&#13;
        skewY = 0;&#13;
      }&#13;
&#13;
      dimNoSkew = target._getTransformedDimensions(skewX, skewY);&#13;
      newDimMouse = 2 * Math.abs(localMouse) - dimNoSkew[by];&#13;
      if (newDimMouse &lt;= 2) {&#13;
        newValue = 0;&#13;
      }&#13;
      else {&#13;
        newValue = skewSign * Math.atan((newDimMouse / target['scale' + _by]) /&#13;
                                        (dimNoSkew[otherBy] / target['scale' + _otherBy]));&#13;
        newValue = fabric.util.radiansToDegrees(newValue);&#13;
      }&#13;
      skewed = target['skew' + _by] !== newValue;&#13;
      target.set('skew' + _by, newValue);&#13;
      if (target['skew' + _otherBy] !== 0) {&#13;
        newDim = target._getTransformedDimensions();&#13;
        newValue = (_dim[otherBy] / newDim[otherBy]) * target['scale' + _otherBy];&#13;
        target.set('scale' + _otherBy, newValue);&#13;
      }&#13;
      return skewed;&#13;
    },&#13;
&#13;
    /**&#13;
     * Scales object by invoking its scaleX/scaleY methods&#13;
     * @private&#13;
     * @param {Number} x pointer's x coordinate&#13;
     * @param {Number} y pointer's y coordinate&#13;
     * @param {String} by Either 'x' or 'y' - specifies dimension constraint by which to scale an object.&#13;
     *                    When not provided, an object is scaled by both dimensions equally&#13;
     * @return {Boolean} true if the scaling occurred&#13;
     */&#13;
    _scaleObject: function (x, y, by) {&#13;
      var t = this._currentTransform,&#13;
          target = t.target,&#13;
          lockScalingX = target.get('lockScalingX'),&#13;
          lockScalingY = target.get('lockScalingY'),&#13;
          lockScalingFlip = target.get('lockScalingFlip');&#13;
&#13;
      if (lockScalingX &amp;&amp; lockScalingY) {&#13;
        return false;&#13;
      }&#13;
&#13;
      // Get the constraint point&#13;
      var constraintPosition = target.translateToOriginPoint(target.getCenterPoint(), t.originX, t.originY),&#13;
          localMouse = target.toLocalPoint(new fabric.Point(x, y), t.originX, t.originY),&#13;
          dim = target._getTransformedDimensions(), scaled = false;&#13;
&#13;
      this._setLocalMouse(localMouse, t);&#13;
&#13;
      // Actually scale the object&#13;
      scaled = this._setObjectScale(localMouse, t, lockScalingX, lockScalingY, by, lockScalingFlip, dim);&#13;
&#13;
      // Make sure the constraints apply&#13;
      target.setPositionByOrigin(constraintPosition, t.originX, t.originY);&#13;
      return scaled;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @return {Boolean} true if the scaling occurred&#13;
     */&#13;
    _setObjectScale: function(localMouse, transform, lockScalingX, lockScalingY, by, lockScalingFlip, _dim) {&#13;
      var target = transform.target, forbidScalingX = false, forbidScalingY = false, scaled = false,&#13;
          changeX, changeY, scaleX, scaleY;&#13;
&#13;
      scaleX = localMouse.x * target.scaleX / _dim.x;&#13;
      scaleY = localMouse.y * target.scaleY / _dim.y;&#13;
      changeX = target.scaleX !== scaleX;&#13;
      changeY = target.scaleY !== scaleY;&#13;
&#13;
      if (lockScalingFlip &amp;&amp; scaleX &lt;= 0 &amp;&amp; scaleX &lt; target.scaleX) {&#13;
        forbidScalingX = true;&#13;
        localMouse.x = 0;&#13;
      }&#13;
&#13;
      if (lockScalingFlip &amp;&amp; scaleY &lt;= 0 &amp;&amp; scaleY &lt; target.scaleY) {&#13;
        forbidScalingY = true;&#13;
        localMouse.y = 0;&#13;
      }&#13;
&#13;
      if (by === 'equally' &amp;&amp; !lockScalingX &amp;&amp; !lockScalingY) {&#13;
        scaled = this._scaleObjectEqually(localMouse, target, transform, _dim);&#13;
      }&#13;
      else if (!by) {&#13;
        forbidScalingX || lockScalingX || (target.set('scaleX', scaleX) &amp;&amp; (scaled = scaled || changeX));&#13;
        forbidScalingY || lockScalingY || (target.set('scaleY', scaleY) &amp;&amp; (scaled = scaled || changeY));&#13;
      }&#13;
      else if (by === 'x' &amp;&amp; !target.get('lockUniScaling')) {&#13;
        forbidScalingX || lockScalingX || (target.set('scaleX', scaleX) &amp;&amp; (scaled = scaled || changeX));&#13;
      }&#13;
      else if (by === 'y' &amp;&amp; !target.get('lockUniScaling')) {&#13;
        forbidScalingY || lockScalingY || (target.set('scaleY', scaleY) &amp;&amp; (scaled = scaled || changeY));&#13;
      }&#13;
      transform.newScaleX = scaleX;&#13;
      transform.newScaleY = scaleY;&#13;
      forbidScalingX || forbidScalingY || this._flipObject(transform, by);&#13;
      return scaled;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @return {Boolean} true if the scaling occurred&#13;
     */&#13;
    _scaleObjectEqually: function(localMouse, target, transform, _dim) {&#13;
&#13;
      var dist = localMouse.y + localMouse.x,&#13;
          lastDist = _dim.y * transform.original.scaleY / target.scaleY +&#13;
                     _dim.x * transform.original.scaleX / target.scaleX,&#13;
          scaled, signX = localMouse.x &lt; 0 ? -1 : 1,&#13;
          signY = localMouse.y &lt; 0 ? -1 : 1;&#13;
&#13;
      // We use transform.scaleX/Y instead of target.scaleX/Y&#13;
      // because the object may have a min scale and we'll loose the proportions&#13;
      transform.newScaleX = signX * Math.abs(transform.original.scaleX * dist / lastDist);&#13;
      transform.newScaleY = signY * Math.abs(transform.original.scaleY * dist / lastDist);&#13;
      scaled = transform.newScaleX !== target.scaleX || transform.newScaleY !== target.scaleY;&#13;
      target.set('scaleX', transform.newScaleX);&#13;
      target.set('scaleY', transform.newScaleY);&#13;
      return scaled;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _flipObject: function(transform, by) {&#13;
      if (transform.newScaleX &lt; 0 &amp;&amp; by !== 'y') {&#13;
        if (transform.originX === 'left') {&#13;
          transform.originX = 'right';&#13;
        }&#13;
        else if (transform.originX === 'right') {&#13;
          transform.originX = 'left';&#13;
        }&#13;
      }&#13;
&#13;
      if (transform.newScaleY &lt; 0 &amp;&amp; by !== 'x') {&#13;
        if (transform.originY === 'top') {&#13;
          transform.originY = 'bottom';&#13;
        }&#13;
        else if (transform.originY === 'bottom') {&#13;
          transform.originY = 'top';&#13;
        }&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _setLocalMouse: function(localMouse, t) {&#13;
      var target = t.target, zoom = this.getZoom(),&#13;
          padding = target.padding / zoom;&#13;
&#13;
      if (t.originX === 'right') {&#13;
        localMouse.x *= -1;&#13;
      }&#13;
      else if (t.originX === 'center') {&#13;
        localMouse.x *= t.mouseXSign * 2;&#13;
        if (localMouse.x &lt; 0) {&#13;
          t.mouseXSign = -t.mouseXSign;&#13;
        }&#13;
      }&#13;
&#13;
      if (t.originY === 'bottom') {&#13;
        localMouse.y *= -1;&#13;
      }&#13;
      else if (t.originY === 'center') {&#13;
        localMouse.y *= t.mouseYSign * 2;&#13;
        if (localMouse.y &lt; 0) {&#13;
          t.mouseYSign = -t.mouseYSign;&#13;
        }&#13;
      }&#13;
&#13;
      // adjust the mouse coordinates when dealing with padding&#13;
      if (abs(localMouse.x) &gt; padding) {&#13;
        if (localMouse.x &lt; 0) {&#13;
          localMouse.x += padding;&#13;
        }&#13;
        else {&#13;
          localMouse.x -= padding;&#13;
        }&#13;
      }&#13;
      else { // mouse is within the padding, set to 0&#13;
        localMouse.x = 0;&#13;
      }&#13;
&#13;
      if (abs(localMouse.y) &gt; padding) {&#13;
        if (localMouse.y &lt; 0) {&#13;
          localMouse.y += padding;&#13;
        }&#13;
        else {&#13;
          localMouse.y -= padding;&#13;
        }&#13;
      }&#13;
      else {&#13;
        localMouse.y = 0;&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Rotates object by invoking its rotate method&#13;
     * @private&#13;
     * @param {Number} x pointer's x coordinate&#13;
     * @param {Number} y pointer's y coordinate&#13;
     * @return {Boolean} true if the rotation occurred&#13;
     */&#13;
    _rotateObject: function (x, y) {&#13;
&#13;
      var t = this._currentTransform;&#13;
&#13;
      if (t.target.get('lockRotation')) {&#13;
        return false;&#13;
      }&#13;
&#13;
      var lastAngle = atan2(t.ey - t.top, t.ex - t.left),&#13;
          curAngle = atan2(y - t.top, x - t.left),&#13;
          angle = radiansToDegrees(curAngle - lastAngle + t.theta),&#13;
          hasRotated = true;&#13;
&#13;
      if (t.target.snapAngle &gt; 0) {&#13;
        var snapAngle  = t.target.snapAngle,&#13;
            snapThreshold  = t.target.snapThreshold || snapAngle,&#13;
            rightAngleLocked = Math.ceil(angle / snapAngle) * snapAngle,&#13;
            leftAngleLocked = Math.floor(angle / snapAngle) * snapAngle;&#13;
&#13;
        if (Math.abs(angle - leftAngleLocked) &lt; snapThreshold) {&#13;
          angle = leftAngleLocked;&#13;
        }&#13;
        else if (Math.abs(angle - rightAngleLocked) &lt; snapThreshold) {&#13;
          angle = rightAngleLocked;&#13;
        }&#13;
      }&#13;
&#13;
      // normalize angle to positive value&#13;
      if (angle &lt; 0) {&#13;
        angle = 360 + angle;&#13;
      }&#13;
      angle %= 360;&#13;
&#13;
      if (t.target.angle === angle) {&#13;
        hasRotated = false;&#13;
      }&#13;
      else {&#13;
        t.target.angle = angle;&#13;
      }&#13;
&#13;
      return hasRotated;&#13;
    },&#13;
&#13;
    /**&#13;
     * Set the cursor type of the canvas element&#13;
     * @param {String} value Cursor type of the canvas element.&#13;
     * @see http://www.w3.org/TR/css3-ui/#cursor&#13;
     */&#13;
    setCursor: function (value) {&#13;
      this.upperCanvasEl.style.cursor = value;&#13;
    },&#13;
&#13;
    /**&#13;
     * @param {fabric.Object} target to reset transform&#13;
     * @private&#13;
     */&#13;
    _resetObjectTransform: function (target) {&#13;
      target.scaleX = 1;&#13;
      target.scaleY = 1;&#13;
      target.skewX = 0;&#13;
      target.skewY = 0;&#13;
      target.rotate(0);&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {CanvasRenderingContext2D} ctx to draw the selection on&#13;
     */&#13;
    _drawSelection: function (ctx) {&#13;
      var groupSelector = this._groupSelector,&#13;
          left = groupSelector.left,&#13;
          top = groupSelector.top,&#13;
          aleft = abs(left),&#13;
          atop = abs(top);&#13;
&#13;
      if (this.selectionColor) {&#13;
        ctx.fillStyle = this.selectionColor;&#13;
&#13;
        ctx.fillRect(&#13;
          groupSelector.ex - ((left &gt; 0) ? 0 : -left),&#13;
          groupSelector.ey - ((top &gt; 0) ? 0 : -top),&#13;
          aleft,&#13;
          atop&#13;
        );&#13;
      }&#13;
&#13;
      if (!this.selectionLineWidth || !this.selectionBorderColor) {&#13;
        return;&#13;
      }&#13;
      ctx.lineWidth = this.selectionLineWidth;&#13;
      ctx.strokeStyle = this.selectionBorderColor;&#13;
&#13;
      // selection border&#13;
      if (this.selectionDashArray.length &gt; 1 &amp;&amp; !supportLineDash) {&#13;
&#13;
        var px = groupSelector.ex + STROKE_OFFSET - ((left &gt; 0) ? 0 : aleft),&#13;
            py = groupSelector.ey + STROKE_OFFSET - ((top &gt; 0) ? 0 : atop);&#13;
&#13;
        ctx.beginPath();&#13;
&#13;
        fabric.util.drawDashedLine(ctx, px, py, px + aleft, py, this.selectionDashArray);&#13;
        fabric.util.drawDashedLine(ctx, px, py + atop - 1, px + aleft, py + atop - 1, this.selectionDashArray);&#13;
        fabric.util.drawDashedLine(ctx, px, py, px, py + atop, this.selectionDashArray);&#13;
        fabric.util.drawDashedLine(ctx, px + aleft - 1, py, px + aleft - 1, py + atop, this.selectionDashArray);&#13;
&#13;
        ctx.closePath();&#13;
        ctx.stroke();&#13;
      }&#13;
      else {&#13;
        fabric.Object.prototype._setLineDash.call(this, ctx, this.selectionDashArray);&#13;
        ctx.strokeRect(&#13;
          groupSelector.ex + STROKE_OFFSET - ((left &gt; 0) ? 0 : aleft),&#13;
          groupSelector.ey + STROKE_OFFSET - ((top &gt; 0) ? 0 : atop),&#13;
          aleft,&#13;
          atop&#13;
        );&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Method that determines what object we are clicking on&#13;
     * the skipGroup parameter is for internal use, is needed for shift+click action&#13;
     * @param {Event} e mouse event&#13;
     * @param {Boolean} skipGroup when true, activeGroup is skipped and only objects are traversed through&#13;
     */&#13;
    findTarget: function (e, skipGroup) {&#13;
      if (this.skipTargetFind) {&#13;
        return;&#13;
      }&#13;
&#13;
      var ignoreZoom = true,&#13;
          pointer = this.getPointer(e, ignoreZoom),&#13;
          activeObject = this._activeObject,&#13;
          aObjects = this.getActiveObjects(),&#13;
          activeTarget, activeTargetSubs;&#13;
&#13;
      // first check current group (if one exists)&#13;
      // active group does not check sub targets like normal groups.&#13;
      // if active group just exits.&#13;
      this.targets = [];&#13;
&#13;
      if (aObjects.length &gt; 1 &amp;&amp; !skipGroup &amp;&amp; activeObject === this._searchPossibleTargets([activeObject], pointer)) {&#13;
        return activeObject;&#13;
      }&#13;
      // if we hit the corner of an activeObject, let's return that.&#13;
      if (aObjects.length === 1 &amp;&amp; activeObject._findTargetCorner(pointer)) {&#13;
        return activeObject;&#13;
      }&#13;
      if (aObjects.length === 1 &amp;&amp;&#13;
        activeObject === this._searchPossibleTargets([activeObject], pointer)) {&#13;
        if (!this.preserveObjectStacking) {&#13;
          return activeObject;&#13;
        }&#13;
        else {&#13;
          activeTarget = activeObject;&#13;
          activeTargetSubs = this.targets;&#13;
          this.targets = [];&#13;
        }&#13;
      }&#13;
      var target = this._searchPossibleTargets(this._objects, pointer);&#13;
      if (e[this.altSelectionKey] &amp;&amp; target &amp;&amp; activeTarget &amp;&amp; target !== activeTarget) {&#13;
        target = activeTarget;&#13;
        this.targets = activeTargetSubs;&#13;
      }&#13;
      return target;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _checkTarget: function(pointer, obj) {&#13;
      if (obj &amp;&amp;&#13;
          obj.visible &amp;&amp;&#13;
          obj.evented &amp;&amp;&#13;
          this.containsPoint(null, obj, pointer)){&#13;
        if ((this.perPixelTargetFind || obj.perPixelTargetFind) &amp;&amp; !obj.isEditing) {&#13;
          var isTransparent = this.isTargetTransparent(obj, pointer.x, pointer.y);&#13;
          if (!isTransparent) {&#13;
            return true;&#13;
          }&#13;
        }&#13;
        else {&#13;
          return true;&#13;
        }&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _searchPossibleTargets: function(objects, pointer) {&#13;
&#13;
      // Cache all targets where their bounding box contains point.&#13;
      var target, i = objects.length, normalizedPointer, subTarget;&#13;
      // Do not check for currently grouped objects, since we check the parent group itself.&#13;
      // until we call this function specifically to search inside the activeGroup&#13;
      while (i--) {&#13;
        if (this._checkTarget(pointer, objects[i])) {&#13;
          target = objects[i];&#13;
          if (target.type === 'group' &amp;&amp; target.subTargetCheck) {&#13;
            normalizedPointer = this._normalizePointer(target, pointer);&#13;
            subTarget = this._searchPossibleTargets(target._objects, normalizedPointer);&#13;
            subTarget &amp;&amp; this.targets.push(subTarget);&#13;
          }&#13;
          break;&#13;
        }&#13;
      }&#13;
      return target;&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns pointer coordinates without the effect of the viewport&#13;
     * @param {Object} pointer with "x" and "y" number values&#13;
     * @return {Object} object with "x" and "y" number values&#13;
     */&#13;
    restorePointerVpt: function(pointer) {&#13;
      return fabric.util.transformPoint(&#13;
        pointer,&#13;
        fabric.util.invertTransform(this.viewportTransform)&#13;
      );&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns pointer coordinates relative to canvas.&#13;
     * Can return coordinates with or without viewportTransform.&#13;
     * ignoreZoom false gives back coordinates that represent&#13;
     * the point clicked on canvas element.&#13;
     * ignoreZoom true gives back coordinates after being processed&#13;
     * by the viewportTransform ( sort of coordinates of what is displayed&#13;
     * on the canvas where you are clicking.&#13;
     * To interact with your shapes top and left you want to use ignoreZoom true&#13;
     * most of the time, while ignoreZoom false will give you coordinates&#13;
     * compatible with the object.oCoords system.&#13;
     * of the time.&#13;
     * @param {Event} e&#13;
     * @param {Boolean} ignoreZoom&#13;
     * @return {Object} object with "x" and "y" number values&#13;
     */&#13;
    getPointer: function (e, ignoreZoom, upperCanvasEl) {&#13;
      if (!upperCanvasEl) {&#13;
        upperCanvasEl = this.upperCanvasEl;&#13;
      }&#13;
      var pointer = getPointer(e),&#13;
          bounds = upperCanvasEl.getBoundingClientRect(),&#13;
          boundsWidth = bounds.width || 0,&#13;
          boundsHeight = bounds.height || 0,&#13;
          cssScale;&#13;
&#13;
      if (!boundsWidth || !boundsHeight ) {&#13;
        if ('top' in bounds &amp;&amp; 'bottom' in bounds) {&#13;
          boundsHeight = Math.abs( bounds.top - bounds.bottom );&#13;
        }&#13;
        if ('right' in bounds &amp;&amp; 'left' in bounds) {&#13;
          boundsWidth = Math.abs( bounds.right - bounds.left );&#13;
        }&#13;
      }&#13;
&#13;
      this.calcOffset();&#13;
&#13;
      pointer.x = pointer.x - this._offset.left;&#13;
      pointer.y = pointer.y - this._offset.top;&#13;
      if (!ignoreZoom) {&#13;
        pointer = this.restorePointerVpt(pointer);&#13;
      }&#13;
&#13;
      if (boundsWidth === 0 || boundsHeight === 0) {&#13;
        // If bounds are not available (i.e. not visible), do not apply scale.&#13;
        cssScale = { width: 1, height: 1 };&#13;
      }&#13;
      else {&#13;
        cssScale = {&#13;
          width: upperCanvasEl.width / boundsWidth,&#13;
          height: upperCanvasEl.height / boundsHeight&#13;
        };&#13;
      }&#13;
&#13;
      return {&#13;
        x: pointer.x * cssScale.width,&#13;
        y: pointer.y * cssScale.height&#13;
      };&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @throws {CANVAS_INIT_ERROR} If canvas can not be initialized&#13;
     */&#13;
    _createUpperCanvas: function () {&#13;
      var lowerCanvasClass = this.lowerCanvasEl.className.replace(/\s*lower-canvas\s*/, '');&#13;
&#13;
      // there is no need to create a new upperCanvas element if we have already one.&#13;
      if (this.upperCanvasEl) {&#13;
        this.upperCanvasEl.className = '';&#13;
      }&#13;
      else {&#13;
        this.upperCanvasEl = this._createCanvasElement();&#13;
      }&#13;
      fabric.util.addClass(this.upperCanvasEl, 'upper-canvas ' + lowerCanvasClass);&#13;
&#13;
      this.wrapperEl.appendChild(this.upperCanvasEl);&#13;
&#13;
      this._copyCanvasStyle(this.lowerCanvasEl, this.upperCanvasEl);&#13;
      this._applyCanvasStyle(this.upperCanvasEl);&#13;
      this.contextTop = this.upperCanvasEl.getContext('2d');&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _createCacheCanvas: function () {&#13;
      this.cacheCanvasEl = this._createCanvasElement();&#13;
      this.cacheCanvasEl.setAttribute('width', this.width);&#13;
      this.cacheCanvasEl.setAttribute('height', this.height);&#13;
      this.contextCache = this.cacheCanvasEl.getContext('2d');&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _initWrapperElement: function () {&#13;
      this.wrapperEl = fabric.util.wrapElement(this.lowerCanvasEl, 'div', {&#13;
        'class': this.containerClass&#13;
      });&#13;
      fabric.util.setStyle(this.wrapperEl, {&#13;
        width: this.width + 'px',&#13;
        height: this.height + 'px',&#13;
        position: 'relative'&#13;
      });&#13;
      fabric.util.makeElementUnselectable(this.wrapperEl);&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {HTMLElement} element canvas element to apply styles on&#13;
     */&#13;
    _applyCanvasStyle: function (element) {&#13;
      var width = this.width || element.width,&#13;
          height = this.height || element.height;&#13;
&#13;
      fabric.util.setStyle(element, {&#13;
        position: 'absolute',&#13;
        width: width + 'px',&#13;
        height: height + 'px',&#13;
        left: 0,&#13;
        top: 0,&#13;
        'touch-action': 'none'&#13;
      });&#13;
      element.width = width;&#13;
      element.height = height;&#13;
      fabric.util.makeElementUnselectable(element);&#13;
    },&#13;
&#13;
    /**&#13;
     * Copy the entire inline style from one element (fromEl) to another (toEl)&#13;
     * @private&#13;
     * @param {Element} fromEl Element style is copied from&#13;
     * @param {Element} toEl Element copied style is applied to&#13;
     */&#13;
    _copyCanvasStyle: function (fromEl, toEl) {&#13;
      toEl.style.cssText = fromEl.style.cssText;&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns context of canvas where object selection is drawn&#13;
     * @return {CanvasRenderingContext2D}&#13;
     */&#13;
    getSelectionContext: function() {&#13;
      return this.contextTop;&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns &amp;lt;canvas&gt; element on which object selection is drawn&#13;
     * @return {HTMLCanvasElement}&#13;
     */&#13;
    getSelectionElement: function () {&#13;
      return this.upperCanvasEl;&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns currently active object&#13;
     * @return {fabric.Object} active object&#13;
     */&#13;
    getActiveObject: function () {&#13;
      return this._activeObject;&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns an array with the current selected objects&#13;
     * @return {fabric.Object} active object&#13;
     */&#13;
    getActiveObjects: function () {&#13;
      var active = this._activeObject;&#13;
      if (active) {&#13;
        if (active.type === 'activeSelection' &amp;&amp; active._objects) {&#13;
          return active._objects.slice(0);&#13;
        }&#13;
        else {&#13;
          return [active];&#13;
        }&#13;
      }&#13;
      return [];&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {fabric.Object} obj Object that was removed&#13;
     */&#13;
    _onObjectRemoved: function(obj) {&#13;
      // removing active object should fire "selection:cleared" events&#13;
      if (obj === this._activeObject) {&#13;
        this.fire('before:selection:cleared', { target: obj });&#13;
        this._discardActiveObject();&#13;
        this.fire('selection:cleared', { target: obj });&#13;
        obj.fire('deselected');&#13;
      }&#13;
      if (this._hoveredTarget === obj) {&#13;
        this._hoveredTarget = null;&#13;
      }&#13;
      this.callSuper('_onObjectRemoved', obj);&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * Compares the old activeObject with the current one and fires correct events&#13;
     * @param {fabric.Object} obj old activeObject&#13;
     */&#13;
    _fireSelectionEvents: function(oldObjects, e) {&#13;
      var somethingChanged = false, objects = this.getActiveObjects(),&#13;
          added = [], removed = [], opt = { e: e };&#13;
      oldObjects.forEach(function(oldObject) {&#13;
        if (objects.indexOf(oldObject) === -1) {&#13;
          somethingChanged = true;&#13;
          oldObject.fire('deselected', opt);&#13;
          removed.push(oldObject);&#13;
        }&#13;
      });&#13;
      objects.forEach(function(object) {&#13;
        if (oldObjects.indexOf(object) === -1) {&#13;
          somethingChanged = true;&#13;
          object.fire('selected', opt);&#13;
          added.push(object);&#13;
        }&#13;
      });&#13;
      if (oldObjects.length &gt; 0 &amp;&amp; objects.length &gt; 0) {&#13;
        opt.selected = added;&#13;
        opt.deselected = removed;&#13;
        // added for backward compatibility&#13;
        opt.updated = added[0] || removed[0];&#13;
        opt.target = this._activeObject;&#13;
        somethingChanged &amp;&amp; this.fire('selection:updated', opt);&#13;
      }&#13;
      else if (objects.length &gt; 0) {&#13;
        // deprecated event&#13;
        if (objects.length === 1) {&#13;
          opt.target = added[0];&#13;
          this.fire('object:selected', opt);&#13;
        }&#13;
        opt.selected = added;&#13;
        // added for backward compatibility&#13;
        opt.target = this._activeObject;&#13;
        this.fire('selection:created', opt);&#13;
      }&#13;
      else if (oldObjects.length &gt; 0) {&#13;
        opt.deselected = removed;&#13;
        this.fire('selection:cleared', opt);&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Sets given object as the only active object on canvas&#13;
     * @param {fabric.Object} object Object to set as an active one&#13;
     * @param {Event} [e] Event (passed along when firing "object:selected")&#13;
     * @return {fabric.Canvas} thisArg&#13;
     * @chainable&#13;
     */&#13;
    setActiveObject: function (object, e) {&#13;
      var currentActives = this.getActiveObjects();&#13;
      this._setActiveObject(object, e);&#13;
      this._fireSelectionEvents(currentActives, e);&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Object} object to set as active&#13;
     * @param {Event} [e] Event (passed along when firing "object:selected")&#13;
     * @return {Boolean} true if the selection happened&#13;
     */&#13;
    _setActiveObject: function(object, e) {&#13;
      if (this._activeObject === object) {&#13;
        return false;&#13;
      }&#13;
      if (!this._discardActiveObject(e, object)) {&#13;
        return false;&#13;
      }&#13;
      if (object.onSelect({ e: e })) {&#13;
        return false;&#13;
      }&#13;
      this._activeObject = object;&#13;
      return true;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _discardActiveObject: function(e, object) {&#13;
      var obj = this._activeObject;&#13;
      if (obj) {&#13;
        // onDeselect return TRUE to cancel selection;&#13;
        if (obj.onDeselect({ e: e, object: object })) {&#13;
          return false;&#13;
        }&#13;
        this._activeObject = null;&#13;
      }&#13;
      return true;&#13;
    },&#13;
&#13;
    /**&#13;
     * Discards currently active object and fire events. If the function is called by fabric&#13;
     * as a consequence of a mouse event, the event is passed as a parameter and&#13;
     * sent to the fire function for the custom events. When used as a method the&#13;
     * e param does not have any application.&#13;
     * @param {event} e&#13;
     * @return {fabric.Canvas} thisArg&#13;
     * @chainable&#13;
     */&#13;
    discardActiveObject: function (e) {&#13;
      var currentActives = this.getActiveObjects();&#13;
      if (currentActives.length) {&#13;
        this.fire('before:selection:cleared', { target: currentActives[0], e: e });&#13;
      }&#13;
      this._discardActiveObject(e);&#13;
      this._fireSelectionEvents(currentActives, e);&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Clears a canvas element and removes all event listeners&#13;
     * @return {fabric.Canvas} thisArg&#13;
     * @chainable&#13;
     */&#13;
    dispose: function () {&#13;
      var wrapper = this.wrapperEl;&#13;
      this.removeListeners();&#13;
      wrapper.removeChild(this.upperCanvasEl);&#13;
      wrapper.removeChild(this.lowerCanvasEl);&#13;
      delete this.upperCanvasEl;&#13;
      if (wrapper.parentNode) {&#13;
        wrapper.parentNode.replaceChild(this.lowerCanvasEl, this.wrapperEl);&#13;
      }&#13;
      delete this.wrapperEl;&#13;
      fabric.StaticCanvas.prototype.dispose.call(this);&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Clears all contexts (background, main, top) of an instance&#13;
     * @return {fabric.Canvas} thisArg&#13;
     * @chainable&#13;
     */&#13;
    clear: function () {&#13;
      // this.discardActiveGroup();&#13;
      this.discardActiveObject();&#13;
      this.clearContext(this.contextTop);&#13;
      return this.callSuper('clear');&#13;
    },&#13;
&#13;
    /**&#13;
     * Draws objects' controls (borders/controls)&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render controls on&#13;
     */&#13;
    drawControls: function(ctx) {&#13;
      var activeObject = this._activeObject;&#13;
&#13;
      if (activeObject) {&#13;
        activeObject._renderControls(ctx);&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _toObject: function(instance, methodName, propertiesToInclude) {&#13;
      //If the object is part of the current selection group, it should&#13;
      //be transformed appropriately&#13;
      //i.e. it should be serialised as it would appear if the selection group&#13;
      //were to be destroyed.&#13;
      var originalProperties = this._realizeGroupTransformOnObject(instance),&#13;
          object = this.callSuper('_toObject', instance, methodName, propertiesToInclude);&#13;
      //Undo the damage we did by changing all of its properties&#13;
      this._unwindGroupTransformOnObject(instance, originalProperties);&#13;
      return object;&#13;
    },&#13;
&#13;
    /**&#13;
     * Realises an object's group transformation on it&#13;
     * @private&#13;
     * @param {fabric.Object} [instance] the object to transform (gets mutated)&#13;
     * @returns the original values of instance which were changed&#13;
     */&#13;
    _realizeGroupTransformOnObject: function(instance) {&#13;
      if (instance.group &amp;&amp; instance.group.type === 'activeSelection' &amp;&amp; this._activeObject === instance.group) {&#13;
        var layoutProps = ['angle', 'flipX', 'flipY', 'left', 'scaleX', 'scaleY', 'skewX', 'skewY', 'top'];&#13;
        //Copy all the positionally relevant properties across now&#13;
        var originalValues = {};&#13;
        layoutProps.forEach(function(prop) {&#13;
          originalValues[prop] = instance[prop];&#13;
        });&#13;
        this._activeObject.realizeTransform(instance);&#13;
        return originalValues;&#13;
      }&#13;
      else {&#13;
        return null;&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Restores the changed properties of instance&#13;
     * @private&#13;
     * @param {fabric.Object} [instance] the object to un-transform (gets mutated)&#13;
     * @param {Object} [originalValues] the original values of instance, as returned by _realizeGroupTransformOnObject&#13;
     */&#13;
    _unwindGroupTransformOnObject: function(instance, originalValues) {&#13;
      if (originalValues) {&#13;
        instance.set(originalValues);&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _setSVGObject: function(markup, instance, reviver) {&#13;
      //If the object is in a selection group, simulate what would happen to that&#13;
      //object when the group is deselected&#13;
      var originalProperties = this._realizeGroupTransformOnObject(instance);&#13;
      this.callSuper('_setSVGObject', markup, instance, reviver);&#13;
      this._unwindGroupTransformOnObject(instance, originalProperties);&#13;
    },&#13;
  });&#13;
&#13;
  // copying static properties manually to work around Opera's bug,&#13;
  // where "prototype" property is enumerable and overrides existing prototype&#13;
  for (var prop in fabric.StaticCanvas) {&#13;
    if (prop !== 'prototype') {&#13;
      fabric.Canvas[prop] = fabric.StaticCanvas[prop];&#13;
    }&#13;
  }&#13;
&#13;
  if (fabric.isTouchSupported) {&#13;
    /** @ignore */&#13;
    fabric.Canvas.prototype._setCursorFromEvent = function() { };&#13;
  }&#13;
})();&#13;
&#13;
&#13;
(function() {&#13;
&#13;
  var cursorOffset = {&#13;
        mt: 0, // n&#13;
        tr: 1, // ne&#13;
        mr: 2, // e&#13;
        br: 3, // se&#13;
        mb: 4, // s&#13;
        bl: 5, // sw&#13;
        ml: 6, // w&#13;
        tl: 7 // nw&#13;
      },&#13;
      addListener = fabric.util.addListener,&#13;
      removeListener = fabric.util.removeListener,&#13;
      RIGHT_CLICK = 3, MIDDLE_CLICK = 2, LEFT_CLICK = 1;&#13;
&#13;
  function checkClick(e, value) {&#13;
    return 'which' in e ? e.which === value : e.button === value - 1;&#13;
  }&#13;
&#13;
  fabric.util.object.extend(fabric.Canvas.prototype, /** @lends fabric.Canvas.prototype */ {&#13;
&#13;
    /**&#13;
     * Map of cursor style values for each of the object controls&#13;
     * @private&#13;
     */&#13;
    cursorMap: [&#13;
      'n-resize',&#13;
      'ne-resize',&#13;
      'e-resize',&#13;
      'se-resize',&#13;
      's-resize',&#13;
      'sw-resize',&#13;
      'w-resize',&#13;
      'nw-resize'&#13;
    ],&#13;
&#13;
    /**&#13;
     * Adds mouse listeners to canvas&#13;
     * @private&#13;
     */&#13;
    _initEventListeners: function () {&#13;
      // in case we initialized the class twice. This should not happen normally&#13;
      // but in some kind of applications where the canvas element may be changed&#13;
      // this is a workaround to having double listeners.&#13;
      this.removeListeners();&#13;
      this._bindEvents();&#13;
&#13;
      addListener(fabric.window, 'resize', this._onResize);&#13;
&#13;
      // mouse events&#13;
      addListener(this.upperCanvasEl, 'mousedown', this._onMouseDown);&#13;
      addListener(this.upperCanvasEl, 'dblclick', this._onDoubleClick);&#13;
      addListener(this.upperCanvasEl, 'mousemove', this._onMouseMove);&#13;
      addListener(this.upperCanvasEl, 'mouseout', this._onMouseOut);&#13;
      addListener(this.upperCanvasEl, 'mouseenter', this._onMouseEnter);&#13;
      addListener(this.upperCanvasEl, 'wheel', this._onMouseWheel);&#13;
      addListener(this.upperCanvasEl, 'contextmenu', this._onContextMenu);&#13;
&#13;
      // touch events&#13;
      addListener(this.upperCanvasEl, 'touchstart', this._onMouseDown, { passive: false });&#13;
      addListener(this.upperCanvasEl, 'touchmove', this._onMouseMove, { passive: false });&#13;
&#13;
      if (typeof eventjs !== 'undefined' &amp;&amp; 'add' in eventjs) {&#13;
        eventjs.add(this.upperCanvasEl, 'gesture', this._onGesture);&#13;
        eventjs.add(this.upperCanvasEl, 'drag', this._onDrag);&#13;
        eventjs.add(this.upperCanvasEl, 'orientation', this._onOrientationChange);&#13;
        eventjs.add(this.upperCanvasEl, 'shake', this._onShake);&#13;
        eventjs.add(this.upperCanvasEl, 'longpress', this._onLongPress);&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _bindEvents: function() {&#13;
      if (this.eventsBinded) {&#13;
        // for any reason we pass here twice we do not want to bind events twice.&#13;
        return;&#13;
      }&#13;
      this._onMouseDown = this._onMouseDown.bind(this);&#13;
      this._onMouseMove = this._onMouseMove.bind(this);&#13;
      this._onMouseUp = this._onMouseUp.bind(this);&#13;
      this._onResize = this._onResize.bind(this);&#13;
      this._onGesture = this._onGesture.bind(this);&#13;
      this._onDrag = this._onDrag.bind(this);&#13;
      this._onShake = this._onShake.bind(this);&#13;
      this._onLongPress = this._onLongPress.bind(this);&#13;
      this._onOrientationChange = this._onOrientationChange.bind(this);&#13;
      this._onMouseWheel = this._onMouseWheel.bind(this);&#13;
      this._onMouseOut = this._onMouseOut.bind(this);&#13;
      this._onMouseEnter = this._onMouseEnter.bind(this);&#13;
      this._onContextMenu = this._onContextMenu.bind(this);&#13;
      this._onDoubleClick = this._onDoubleClick.bind(this);&#13;
      this.eventsBinded = true;&#13;
    },&#13;
&#13;
    /**&#13;
     * Removes all event listeners&#13;
     */&#13;
    removeListeners: function() {&#13;
      removeListener(fabric.window, 'resize', this._onResize);&#13;
&#13;
      removeListener(this.upperCanvasEl, 'mousedown', this._onMouseDown);&#13;
      removeListener(this.upperCanvasEl, 'mousemove', this._onMouseMove);&#13;
      removeListener(this.upperCanvasEl, 'mouseout', this._onMouseOut);&#13;
      removeListener(this.upperCanvasEl, 'mouseenter', this._onMouseEnter);&#13;
      removeListener(this.upperCanvasEl, 'wheel', this._onMouseWheel);&#13;
      removeListener(this.upperCanvasEl, 'contextmenu', this._onContextMenu);&#13;
      removeListener(this.upperCanvasEl, 'doubleclick', this._onDoubleClick);&#13;
      removeListener(this.upperCanvasEl, 'touchstart', this._onMouseDown);&#13;
      removeListener(this.upperCanvasEl, 'touchmove', this._onMouseMove);&#13;
&#13;
      if (typeof eventjs !== 'undefined' &amp;&amp; 'remove' in eventjs) {&#13;
        eventjs.remove(this.upperCanvasEl, 'gesture', this._onGesture);&#13;
        eventjs.remove(this.upperCanvasEl, 'drag', this._onDrag);&#13;
        eventjs.remove(this.upperCanvasEl, 'orientation', this._onOrientationChange);&#13;
        eventjs.remove(this.upperCanvasEl, 'shake', this._onShake);&#13;
        eventjs.remove(this.upperCanvasEl, 'longpress', this._onLongPress);&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Event} [e] Event object fired on Event.js gesture&#13;
     * @param {Event} [self] Inner Event object&#13;
     */&#13;
    _onGesture: function(e, self) {&#13;
      this.__onTransformGesture &amp;&amp; this.__onTransformGesture(e, self);&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Event} [e] Event object fired on Event.js drag&#13;
     * @param {Event} [self] Inner Event object&#13;
     */&#13;
    _onDrag: function(e, self) {&#13;
      this.__onDrag &amp;&amp; this.__onDrag(e, self);&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Event} [e] Event object fired on wheel event&#13;
     */&#13;
    _onMouseWheel: function(e) {&#13;
      this.__onMouseWheel(e);&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Event} e Event object fired on mousedown&#13;
     */&#13;
    _onMouseOut: function(e) {&#13;
      var target = this._hoveredTarget;&#13;
      this.fire('mouse:out', { target: target, e: e });&#13;
      this._hoveredTarget = null;&#13;
      target &amp;&amp; target.fire('mouseout', { e: e });&#13;
      if (this._iTextInstances) {&#13;
        this._iTextInstances.forEach(function(obj) {&#13;
          if (obj.isEditing) {&#13;
            obj.hiddenTextarea.focus();&#13;
          }&#13;
        });&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Event} e Event object fired on mouseenter&#13;
     */&#13;
    _onMouseEnter: function(e) {&#13;
      if (!this.findTarget(e)) {&#13;
        this.fire('mouse:over', { target: null, e: e });&#13;
        this._hoveredTarget = null;&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Event} [e] Event object fired on Event.js orientation change&#13;
     * @param {Event} [self] Inner Event object&#13;
     */&#13;
    _onOrientationChange: function(e, self) {&#13;
      this.__onOrientationChange &amp;&amp; this.__onOrientationChange(e, self);&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Event} [e] Event object fired on Event.js shake&#13;
     * @param {Event} [self] Inner Event object&#13;
     */&#13;
    _onShake: function(e, self) {&#13;
      this.__onShake &amp;&amp; this.__onShake(e, self);&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Event} [e] Event object fired on Event.js shake&#13;
     * @param {Event} [self] Inner Event object&#13;
     */&#13;
    _onLongPress: function(e, self) {&#13;
      this.__onLongPress &amp;&amp; this.__onLongPress(e, self);&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Event} e Event object fired on mousedown&#13;
     */&#13;
    _onContextMenu: function (e) {&#13;
      if (this.stopContextMenu) {&#13;
        e.stopPropagation();&#13;
        e.preventDefault();&#13;
      }&#13;
      return false;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Event} e Event object fired on mousedown&#13;
     */&#13;
    _onDoubleClick: function (e) {&#13;
      this._handleEvent(e, 'dblclick');&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Event} e Event object fired on mousedown&#13;
     */&#13;
    _onMouseDown: function (e) {&#13;
      this.__onMouseDown(e);&#13;
      addListener(fabric.document, 'touchend', this._onMouseUp, { passive: false });&#13;
      addListener(fabric.document, 'touchmove', this._onMouseMove, { passive: false });&#13;
&#13;
      removeListener(this.upperCanvasEl, 'mousemove', this._onMouseMove);&#13;
      removeListener(this.upperCanvasEl, 'touchmove', this._onMouseMove);&#13;
&#13;
      if (e.type === 'touchstart') {&#13;
        // Unbind mousedown to prevent double triggers from touch devices&#13;
        removeListener(this.upperCanvasEl, 'mousedown', this._onMouseDown);&#13;
      }&#13;
      else {&#13;
        addListener(fabric.document, 'mouseup', this._onMouseUp);&#13;
        addListener(fabric.document, 'mousemove', this._onMouseMove);&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Event} e Event object fired on mouseup&#13;
     */&#13;
    _onMouseUp: function (e) {&#13;
      this.__onMouseUp(e);&#13;
&#13;
      removeListener(fabric.document, 'mouseup', this._onMouseUp);&#13;
      removeListener(fabric.document, 'touchend', this._onMouseUp);&#13;
&#13;
      removeListener(fabric.document, 'mousemove', this._onMouseMove);&#13;
      removeListener(fabric.document, 'touchmove', this._onMouseMove);&#13;
&#13;
      addListener(this.upperCanvasEl, 'mousemove', this._onMouseMove);&#13;
      addListener(this.upperCanvasEl, 'touchmove', this._onMouseMove, { passive: false });&#13;
&#13;
      if (e.type === 'touchend') {&#13;
        // Wait 400ms before rebinding mousedown to prevent double triggers&#13;
        // from touch devices&#13;
        var _this = this;&#13;
        setTimeout(function() {&#13;
          addListener(_this.upperCanvasEl, 'mousedown', _this._onMouseDown);&#13;
        }, 400);&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Event} e Event object fired on mousemove&#13;
     */&#13;
    _onMouseMove: function (e) {&#13;
      !this.allowTouchScrolling &amp;&amp; e.preventDefault &amp;&amp; e.preventDefault();&#13;
      this.__onMouseMove(e);&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _onResize: function () {&#13;
      this.calcOffset();&#13;
    },&#13;
&#13;
    /**&#13;
     * Decides whether the canvas should be redrawn in mouseup and mousedown events.&#13;
     * @private&#13;
     * @param {Object} target&#13;
     * @param {Object} pointer&#13;
     */&#13;
    _shouldRender: function(target, pointer) {&#13;
      var activeObject = this._activeObject;&#13;
&#13;
      if (activeObject &amp;&amp; activeObject.isEditing &amp;&amp; target === activeObject) {&#13;
        // if we mouse up/down over a editing textbox a cursor change,&#13;
        // there is no need to re render&#13;
        return false;&#13;
      }&#13;
      return !!(&#13;
        (target &amp;&amp; (&#13;
          target.isMoving ||&#13;
          target !== activeObject))&#13;
        ||&#13;
        (!target &amp;&amp; !!activeObject)&#13;
        ||&#13;
        (!target &amp;&amp; !activeObject &amp;&amp; !this._groupSelector)&#13;
        ||&#13;
        (pointer &amp;&amp;&#13;
          this._previousPointer &amp;&amp;&#13;
          this.selection &amp;&amp; (&#13;
            pointer.x !== this._previousPointer.x ||&#13;
          pointer.y !== this._previousPointer.y))&#13;
      );&#13;
    },&#13;
&#13;
    /**&#13;
     * Method that defines the actions when mouse is released on canvas.&#13;
     * The method resets the currentTransform parameters, store the image corner&#13;
     * position in the image object and render the canvas on top.&#13;
     * @private&#13;
     * @param {Event} e Event object fired on mouseup&#13;
     */&#13;
    __onMouseUp: function (e) {&#13;
&#13;
      var target, searchTarget = true, transform = this._currentTransform,&#13;
          groupSelector = this._groupSelector,&#13;
          isClick = (!groupSelector || (groupSelector.left === 0 &amp;&amp; groupSelector.top === 0));&#13;
      // if right/middle click just fire events and return&#13;
      // target undefined will make the _handleEvent search the target&#13;
      if (checkClick(e, RIGHT_CLICK)) {&#13;
        if (this.fireRightClick) {&#13;
          this._handleEvent(e, 'up', target, RIGHT_CLICK, isClick);&#13;
        }&#13;
        return;&#13;
      }&#13;
&#13;
      if (checkClick(e, MIDDLE_CLICK)) {&#13;
        if (this.fireMiddleClick) {&#13;
          this._handleEvent(e, 'up', target, MIDDLE_CLICK, isClick);&#13;
        }&#13;
        return;&#13;
      }&#13;
&#13;
      if (this.isDrawingMode &amp;&amp; this._isCurrentlyDrawing) {&#13;
        this._onMouseUpInDrawingMode(e);&#13;
        return;&#13;
      }&#13;
&#13;
      if (transform) {&#13;
        this._finalizeCurrentTransform(e);&#13;
        searchTarget = !transform.actionPerformed;&#13;
      }&#13;
&#13;
      target = searchTarget ? this.findTarget(e, true) : transform.target;&#13;
&#13;
      var shouldRender = this._shouldRender(target, this.getPointer(e));&#13;
&#13;
      if (target || !isClick) {&#13;
        this._maybeGroupObjects(e);&#13;
      }&#13;
      else {&#13;
        // those are done by default on mouse up&#13;
        // by _maybeGroupObjects, we are skipping it in case of no target find&#13;
        this._groupSelector = null;&#13;
        this._currentTransform = null;&#13;
      }&#13;
&#13;
      if (target) {&#13;
        target.isMoving = false;&#13;
      }&#13;
      this._setCursorFromEvent(e, target);&#13;
      this._handleEvent(e, 'up', target ? target : null, LEFT_CLICK, isClick);&#13;
      target &amp;&amp; (target.__corner = 0);&#13;
      shouldRender &amp;&amp; this.requestRenderAll();&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * Handle event firing for target and subtargets&#13;
     * @param {Event} e event from mouse&#13;
     * @param {String} eventType event to fire (up, down or move)&#13;
     * @param {fabric.Object} targetObj receiving event&#13;
     * @param {Number} [button] button used in the event 1 = left, 2 = middle, 3 = right&#13;
     * @param {Boolean} isClick for left button only, indicates that the mouse up happened without move.&#13;
     */&#13;
    _handleEvent: function(e, eventType, targetObj, button, isClick) {&#13;
      var target = typeof targetObj === 'undefined' ? this.findTarget(e) : targetObj,&#13;
          targets = this.targets || [],&#13;
          options = {&#13;
            e: e,&#13;
            target: target,&#13;
            subTargets: targets,&#13;
            button: button || LEFT_CLICK,&#13;
            isClick: isClick || false&#13;
          };&#13;
      this.fire('mouse:' + eventType, options);&#13;
      target &amp;&amp; target.fire('mouse' + eventType, options);&#13;
      for (var i = 0; i &lt; targets.length; i++) {&#13;
        targets[i].fire('mouse' + eventType, options);&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Event} e send the mouse event that generate the finalize down, so it can be used in the event&#13;
     */&#13;
    _finalizeCurrentTransform: function(e) {&#13;
&#13;
      var transform = this._currentTransform,&#13;
          target = transform.target;&#13;
&#13;
      if (target._scaling) {&#13;
        target._scaling = false;&#13;
      }&#13;
&#13;
      target.setCoords();&#13;
      this._restoreOriginXY(target);&#13;
&#13;
      if (transform.actionPerformed || (this.stateful &amp;&amp; target.hasStateChanged())) {&#13;
        this.fire('object:modified', { target: target, e: e });&#13;
        target.fire('modified', { e: e });&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Object} target Object to restore&#13;
     */&#13;
    _restoreOriginXY: function(target) {&#13;
      if (this._previousOriginX &amp;&amp; this._previousOriginY) {&#13;
&#13;
        var originPoint = target.translateToOriginPoint(&#13;
          target.getCenterPoint(),&#13;
          this._previousOriginX,&#13;
          this._previousOriginY);&#13;
&#13;
        target.originX = this._previousOriginX;&#13;
        target.originY = this._previousOriginY;&#13;
&#13;
        target.left = originPoint.x;&#13;
        target.top = originPoint.y;&#13;
&#13;
        this._previousOriginX = null;&#13;
        this._previousOriginY = null;&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Event} e Event object fired on mousedown&#13;
     */&#13;
    _onMouseDownInDrawingMode: function(e) {&#13;
      this._isCurrentlyDrawing = true;&#13;
      this.discardActiveObject(e).requestRenderAll();&#13;
      if (this.clipTo) {&#13;
        fabric.util.clipContext(this, this.contextTop);&#13;
      }&#13;
      var pointer = this.getPointer(e);&#13;
      this.freeDrawingBrush.onMouseDown(pointer);&#13;
      this._handleEvent(e, 'down');&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Event} e Event object fired on mousemove&#13;
     */&#13;
    _onMouseMoveInDrawingMode: function(e) {&#13;
      if (this._isCurrentlyDrawing) {&#13;
        var pointer = this.getPointer(e);&#13;
        this.freeDrawingBrush.onMouseMove(pointer);&#13;
      }&#13;
      this.setCursor(this.freeDrawingCursor);&#13;
      this._handleEvent(e, 'move');&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Event} e Event object fired on mouseup&#13;
     */&#13;
    _onMouseUpInDrawingMode: function(e) {&#13;
      this._isCurrentlyDrawing = false;&#13;
      if (this.clipTo) {&#13;
        this.contextTop.restore();&#13;
      }&#13;
      this.freeDrawingBrush.onMouseUp();&#13;
      this._handleEvent(e, 'up');&#13;
    },&#13;
&#13;
    /**&#13;
     * Method that defines the actions when mouse is clicked on canvas.&#13;
     * The method inits the currentTransform parameters and renders all the&#13;
     * canvas so the current image can be placed on the top canvas and the rest&#13;
     * in on the container one.&#13;
     * @private&#13;
     * @param {Event} e Event object fired on mousedown&#13;
     */&#13;
    __onMouseDown: function (e) {&#13;
&#13;
      var target = this.findTarget(e) || null;&#13;
&#13;
      // if right click just fire events&#13;
      if (checkClick(e, RIGHT_CLICK)) {&#13;
        if (this.fireRightClick) {&#13;
          this._handleEvent(e, 'down', target, RIGHT_CLICK);&#13;
        }&#13;
        return;&#13;
      }&#13;
&#13;
      if (checkClick(e, MIDDLE_CLICK)) {&#13;
        if (this.fireMiddleClick) {&#13;
          this._handleEvent(e, 'down', target, MIDDLE_CLICK);&#13;
        }&#13;
        return;&#13;
      }&#13;
&#13;
      if (this.isDrawingMode) {&#13;
        this._onMouseDownInDrawingMode(e);&#13;
        return;&#13;
      }&#13;
&#13;
      // ignore if some object is being transformed at this moment&#13;
      if (this._currentTransform) {&#13;
        return;&#13;
      }&#13;
&#13;
      // save pointer for check in __onMouseUp event&#13;
      var pointer = this.getPointer(e, true);&#13;
      this._previousPointer = pointer;&#13;
      var shouldRender = this._shouldRender(target, pointer),&#13;
          shouldGroup = this._shouldGroup(e, target);&#13;
      if (this._shouldClearSelection(e, target)) {&#13;
        this.discardActiveObject(e);&#13;
      }&#13;
      else if (shouldGroup) {&#13;
        this._handleGrouping(e, target);&#13;
        target = this._activeObject;&#13;
      }&#13;
&#13;
      if (this.selection &amp;&amp; (!target ||&#13;
        (!target.selectable &amp;&amp; !target.isEditing &amp;&amp; target !== this._activeObject))) {&#13;
        this._groupSelector = {&#13;
          ex: pointer.x,&#13;
          ey: pointer.y,&#13;
          top: 0,&#13;
          left: 0&#13;
        };&#13;
      }&#13;
&#13;
      if (target) {&#13;
        if (target.selectable) {&#13;
          this.setActiveObject(target, e);&#13;
        }&#13;
        if (target === this._activeObject &amp;&amp; (target.__corner || !shouldGroup)) {&#13;
          this._beforeTransform(e, target);&#13;
          this._setupCurrentTransform(e, target);&#13;
        }&#13;
      }&#13;
      this._handleEvent(e, 'down', target);&#13;
      // we must renderAll so that we update the visuals&#13;
      shouldRender &amp;&amp; this.requestRenderAll();&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _beforeTransform: function(e, target) {&#13;
      this.stateful &amp;&amp; target.saveState();&#13;
&#13;
      // determine if it's a drag or rotate case&#13;
      if (target._findTargetCorner(this.getPointer(e))) {&#13;
        this.onBeforeScaleRotate(target);&#13;
      }&#13;
&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Object} target Object for that origin is set to center&#13;
     */&#13;
    _setOriginToCenter: function(target) {&#13;
      this._previousOriginX = this._currentTransform.target.originX;&#13;
      this._previousOriginY = this._currentTransform.target.originY;&#13;
&#13;
      var center = target.getCenterPoint();&#13;
&#13;
      target.originX = 'center';&#13;
      target.originY = 'center';&#13;
&#13;
      target.left = center.x;&#13;
      target.top = center.y;&#13;
&#13;
      this._currentTransform.left = target.left;&#13;
      this._currentTransform.top = target.top;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Object} target Object for that center is set to origin&#13;
     */&#13;
    _setCenterToOrigin: function(target) {&#13;
      var originPoint = target.translateToOriginPoint(&#13;
        target.getCenterPoint(),&#13;
        this._previousOriginX,&#13;
        this._previousOriginY);&#13;
&#13;
      target.originX = this._previousOriginX;&#13;
      target.originY = this._previousOriginY;&#13;
&#13;
      target.left = originPoint.x;&#13;
      target.top = originPoint.y;&#13;
&#13;
      this._previousOriginX = null;&#13;
      this._previousOriginY = null;&#13;
    },&#13;
&#13;
    /**&#13;
     * Method that defines the actions when mouse is hovering the canvas.&#13;
     * The currentTransform parameter will definde whether the user is rotating/scaling/translating&#13;
     * an image or neither of them (only hovering). A group selection is also possible and would cancel&#13;
     * all any other type of action.&#13;
     * In case of an image transformation only the top canvas will be rendered.&#13;
     * @private&#13;
     * @param {Event} e Event object fired on mousemove&#13;
     */&#13;
    __onMouseMove: function (e) {&#13;
&#13;
      var target, pointer;&#13;
&#13;
      if (this.isDrawingMode) {&#13;
        this._onMouseMoveInDrawingMode(e);&#13;
        return;&#13;
      }&#13;
      if (typeof e.touches !== 'undefined' &amp;&amp; e.touches.length &gt; 1) {&#13;
        return;&#13;
      }&#13;
&#13;
      var groupSelector = this._groupSelector;&#13;
&#13;
      // We initially clicked in an empty area, so we draw a box for multiple selection&#13;
      if (groupSelector) {&#13;
        pointer = this.getPointer(e, true);&#13;
&#13;
        groupSelector.left = pointer.x - groupSelector.ex;&#13;
        groupSelector.top = pointer.y - groupSelector.ey;&#13;
&#13;
        this.renderTop();&#13;
      }&#13;
      else if (!this._currentTransform) {&#13;
        target = this.findTarget(e) || null;&#13;
        this._setCursorFromEvent(e, target);&#13;
        this._fireOverOutEvents(target, e);&#13;
      }&#13;
      else {&#13;
        this._transformObject(e);&#13;
      }&#13;
      this._handleEvent(e, 'move', this._currentTransform ? null : target);&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _fireOverOutEvents: function(target, e) {&#13;
      var overOpt, outOpt, hoveredTarget = this._hoveredTarget;&#13;
      if (hoveredTarget !== target) {&#13;
        overOpt = { e: e, target: target, previousTarget: this._hoveredTarget };&#13;
        outOpt = { e: e, target: this._hoveredTarget, nextTarget: target };&#13;
        this._hoveredTarget = target;&#13;
      }&#13;
      if (target) {&#13;
        if (hoveredTarget !== target) {&#13;
          if (hoveredTarget) {&#13;
            this.fire('mouse:out', outOpt);&#13;
            hoveredTarget.fire('mouseout', outOpt);&#13;
          }&#13;
          this.fire('mouse:over', overOpt);&#13;
          target.fire('mouseover', overOpt);&#13;
        }&#13;
      }&#13;
      else if (hoveredTarget) {&#13;
        this.fire('mouse:out', outOpt);&#13;
        hoveredTarget.fire('mouseout', outOpt);&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Method that defines actions when an Event Mouse Wheel&#13;
     * @param {Event} e Event object fired on mouseup&#13;
     */&#13;
    __onMouseWheel: function(e) {&#13;
      this._handleEvent(e, 'wheel');&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Event} e Event fired on mousemove&#13;
     */&#13;
    _transformObject: function(e) {&#13;
      var pointer = this.getPointer(e),&#13;
          transform = this._currentTransform;&#13;
&#13;
      transform.reset = false;&#13;
      transform.target.isMoving = true;&#13;
      transform.shiftKey = e.shiftKey;&#13;
      transform.altKey = e[this.centeredKey];&#13;
&#13;
      this._beforeScaleTransform(e, transform);&#13;
      this._performTransformAction(e, transform, pointer);&#13;
&#13;
      transform.actionPerformed &amp;&amp; this.requestRenderAll();&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _performTransformAction: function(e, transform, pointer) {&#13;
      var x = pointer.x,&#13;
          y = pointer.y,&#13;
          target = transform.target,&#13;
          action = transform.action,&#13;
          actionPerformed = false;&#13;
&#13;
      if (action === 'rotate') {&#13;
        (actionPerformed = this._rotateObject(x, y)) &amp;&amp; this._fire('rotating', target, e);&#13;
      }&#13;
      else if (action === 'scale') {&#13;
        (actionPerformed = this._onScale(e, transform, x, y)) &amp;&amp; this._fire('scaling', target, e);&#13;
      }&#13;
      else if (action === 'scaleX') {&#13;
        (actionPerformed = this._scaleObject(x, y, 'x')) &amp;&amp; this._fire('scaling', target, e);&#13;
      }&#13;
      else if (action === 'scaleY') {&#13;
        (actionPerformed = this._scaleObject(x, y, 'y')) &amp;&amp; this._fire('scaling', target, e);&#13;
      }&#13;
      else if (action === 'skewX') {&#13;
        (actionPerformed = this._skewObject(x, y, 'x')) &amp;&amp; this._fire('skewing', target, e);&#13;
      }&#13;
      else if (action === 'skewY') {&#13;
        (actionPerformed = this._skewObject(x, y, 'y')) &amp;&amp; this._fire('skewing', target, e);&#13;
      }&#13;
      else {&#13;
        actionPerformed = this._translateObject(x, y);&#13;
        if (actionPerformed) {&#13;
          this._fire('moving', target, e);&#13;
          this.setCursor(target.moveCursor || this.moveCursor);&#13;
        }&#13;
      }&#13;
      transform.actionPerformed = transform.actionPerformed || actionPerformed;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _fire: function(eventName, target, e) {&#13;
      this.fire('object:' + eventName, { target: target, e: e });&#13;
      target.fire(eventName, { e: e });&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _beforeScaleTransform: function(e, transform) {&#13;
      if (transform.action === 'scale' || transform.action === 'scaleX' || transform.action === 'scaleY') {&#13;
        var centerTransform = this._shouldCenterTransform(transform.target);&#13;
&#13;
        // Switch from a normal resize to center-based&#13;
        if ((centerTransform &amp;&amp; (transform.originX !== 'center' || transform.originY !== 'center')) ||&#13;
           // Switch from center-based resize to normal one&#13;
           (!centerTransform &amp;&amp; transform.originX === 'center' &amp;&amp; transform.originY === 'center')&#13;
        ) {&#13;
          this._resetCurrentTransform();&#13;
          transform.reset = true;&#13;
        }&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Event} e Event object&#13;
     * @param {Object} transform current tranform&#13;
     * @param {Number} x mouse position x from origin&#13;
     * @param {Number} y mouse poistion y from origin&#13;
     * @return {Boolean} true if the scaling occurred&#13;
     */&#13;
    _onScale: function(e, transform, x, y) {&#13;
      if (this._isUniscalePossible(e, transform.target)) {&#13;
        transform.currentAction = 'scale';&#13;
        return this._scaleObject(x, y);&#13;
      }&#13;
      else {&#13;
        // Switch from a normal resize to proportional&#13;
        if (!transform.reset &amp;&amp; transform.currentAction === 'scale') {&#13;
          this._resetCurrentTransform();&#13;
        }&#13;
&#13;
        transform.currentAction = 'scaleEqually';&#13;
        return this._scaleObject(x, y, 'equally');&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Event} e Event object&#13;
     * @param {fabric.Object} target current target&#13;
     * @return {Boolean} true if unproportional scaling is possible&#13;
     */&#13;
    _isUniscalePossible: function(e, target) {&#13;
      return (e[this.uniScaleKey] || this.uniScaleTransform) &amp;&amp; !target.get('lockUniScaling');&#13;
    },&#13;
&#13;
    /**&#13;
     * Sets the cursor depending on where the canvas is being hovered.&#13;
     * Note: very buggy in Opera&#13;
     * @param {Event} e Event object&#13;
     * @param {Object} target Object that the mouse is hovering, if so.&#13;
     */&#13;
    _setCursorFromEvent: function (e, target) {&#13;
      if (!target) {&#13;
        this.setCursor(this.defaultCursor);&#13;
        return false;&#13;
      }&#13;
&#13;
      var hoverCursor = target.hoverCursor || this.hoverCursor,&#13;
          activeSelection = this._activeObject &amp;&amp; this._activeObject.type === 'activeSelection' ?&#13;
            this._activeObject : null,&#13;
          // only show proper corner when group selection is not active&#13;
          corner = (!activeSelection || !activeSelection.contains(target))&#13;
                    &amp;&amp; target._findTargetCorner(this.getPointer(e, true));&#13;
&#13;
      if (!corner) {&#13;
        this.setCursor(hoverCursor);&#13;
      }&#13;
      else {&#13;
        this.setCursor(this.getCornerCursor(corner, target, e));&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    getCornerCursor: function(corner, target, e) {&#13;
      if (this.actionIsDisabled(corner, target, e)) {&#13;
        return this.notAllowedCursor;&#13;
      }&#13;
      else if (corner in cursorOffset) {&#13;
        return this._getRotatedCornerCursor(corner, target, e);&#13;
      }&#13;
      else if (corner === 'mtr' &amp;&amp; target.hasRotatingPoint) {&#13;
        return this.rotationCursor;&#13;
      }&#13;
      else {&#13;
        return this.defaultCursor;&#13;
      }&#13;
    },&#13;
&#13;
    actionIsDisabled: function(corner, target, e) {&#13;
      if (corner === 'mt' || corner === 'mb') {&#13;
        return e[this.altActionKey] ? target.lockSkewingX : target.lockScalingY;&#13;
      }&#13;
      else if (corner === 'ml' || corner === 'mr') {&#13;
        return e[this.altActionKey] ? target.lockSkewingY : target.lockScalingX;&#13;
      }&#13;
      else if (corner === 'mtr') {&#13;
        return target.lockRotation;&#13;
      }&#13;
      else {&#13;
        return this._isUniscalePossible(e, target) ?&#13;
          target.lockScalingX &amp;&amp; target.lockScalingY : target.lockScalingX || target.lockScalingY;&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _getRotatedCornerCursor: function(corner, target, e) {&#13;
      var n = Math.round((target.angle % 360) / 45);&#13;
&#13;
      if (n &lt; 0) {&#13;
        n += 8; // full circle ahead&#13;
      }&#13;
      n += cursorOffset[corner];&#13;
      if (e[this.altActionKey] &amp;&amp; cursorOffset[corner] % 2 === 0) {&#13;
        //if we are holding shift and we are on a mx corner...&#13;
        n += 2;&#13;
      }&#13;
      // normalize n to be from 0 to 7&#13;
      n %= 8;&#13;
&#13;
      return this.cursorMap[n];&#13;
    }&#13;
  });&#13;
})();&#13;
&#13;
&#13;
(function() {&#13;
&#13;
  var min = Math.min,&#13;
      max = Math.max;&#13;
&#13;
  fabric.util.object.extend(fabric.Canvas.prototype, /** @lends fabric.Canvas.prototype */ {&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Event} e Event object&#13;
     * @param {fabric.Object} target&#13;
     * @return {Boolean}&#13;
     */&#13;
    _shouldGroup: function(e, target) {&#13;
      var activeObject = this._activeObject;&#13;
&#13;
      return activeObject &amp;&amp; this._isSelectionKeyPressed(e) &amp;&amp; target &amp;&amp; target.selectable &amp;&amp; this.selection &amp;&amp;&#13;
            (activeObject !== target || activeObject.type === 'activeSelection');&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Event} e Event object&#13;
     * @param {fabric.Object} target&#13;
     */&#13;
    _handleGrouping: function (e, target) {&#13;
      var activeObject = this._activeObject;&#13;
      if (activeObject.__corner) {&#13;
        return;&#13;
      }&#13;
      if (target === activeObject) {&#13;
        // if it's a group, find target again, using activeGroup objects&#13;
        target = this.findTarget(e, true);&#13;
        // if even object is not found or we are on activeObjectCorner, bail out&#13;
        if (!target) {&#13;
          return;&#13;
        }&#13;
      }&#13;
      if (activeObject &amp;&amp; activeObject.type === 'activeSelection') {&#13;
        this._updateActiveSelection(target, e);&#13;
      }&#13;
      else {&#13;
        this._createActiveSelection(target, e);&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _updateActiveSelection: function(target, e) {&#13;
      var activeSelection = this._activeObject,&#13;
          currentActiveObjects = activeSelection._objects.slice(0);&#13;
      if (activeSelection.contains(target)) {&#13;
        activeSelection.removeWithUpdate(target);&#13;
        this._hoveredTarget = target;&#13;
        if (activeSelection.size() === 1) {&#13;
          // activate last remaining object&#13;
          this._setActiveObject(activeSelection.item(0), e);&#13;
        }&#13;
      }&#13;
      else {&#13;
        activeSelection.addWithUpdate(target);&#13;
        this._hoveredTarget = activeSelection;&#13;
      }&#13;
      this._fireSelectionEvents(currentActiveObjects, e);&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _createActiveSelection: function(target, e) {&#13;
      var currentActives = this.getActiveObjects(), group = this._createGroup(target);&#13;
      this._hoveredTarget = group;&#13;
      this._setActiveObject(group, e);&#13;
      this._fireSelectionEvents(currentActives, e);&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Object} target&#13;
     */&#13;
    _createGroup: function(target) {&#13;
      var objects = this.getObjects(),&#13;
          isActiveLower = objects.indexOf(this._activeObject) &lt; objects.indexOf(target),&#13;
          groupObjects = isActiveLower&#13;
            ? [this._activeObject, target]&#13;
            : [target, this._activeObject];&#13;
      this._activeObject.isEditing &amp;&amp; this._activeObject.exitEditing();&#13;
      return new fabric.ActiveSelection(groupObjects, {&#13;
        canvas: this&#13;
      });&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Event} e mouse event&#13;
     */&#13;
    _groupSelectedObjects: function (e) {&#13;
&#13;
      var group = this._collectObjects(),&#13;
          aGroup;&#13;
&#13;
      // do not create group for 1 element only&#13;
      if (group.length === 1) {&#13;
        this.setActiveObject(group[0], e);&#13;
      }&#13;
      else if (group.length &gt; 1) {&#13;
        aGroup = new fabric.ActiveSelection(group.reverse(), {&#13;
          canvas: this&#13;
        });&#13;
        this.setActiveObject(aGroup, e);&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _collectObjects: function() {&#13;
      var group = [],&#13;
          currentObject,&#13;
          x1 = this._groupSelector.ex,&#13;
          y1 = this._groupSelector.ey,&#13;
          x2 = x1 + this._groupSelector.left,&#13;
          y2 = y1 + this._groupSelector.top,&#13;
          selectionX1Y1 = new fabric.Point(min(x1, x2), min(y1, y2)),&#13;
          selectionX2Y2 = new fabric.Point(max(x1, x2), max(y1, y2)),&#13;
          allowIntersect = !this.selectionFullyContained,&#13;
          isClick = x1 === x2 &amp;&amp; y1 === y2;&#13;
      // we iterate reverse order to collect top first in case of click.&#13;
      for (var i = this._objects.length; i--; ) {&#13;
        currentObject = this._objects[i];&#13;
&#13;
        if (!currentObject || !currentObject.selectable || !currentObject.visible) {&#13;
          continue;&#13;
        }&#13;
&#13;
        if ((allowIntersect &amp;&amp; currentObject.intersectsWithRect(selectionX1Y1, selectionX2Y2)) ||&#13;
            currentObject.isContainedWithinRect(selectionX1Y1, selectionX2Y2) ||&#13;
            (allowIntersect &amp;&amp; currentObject.containsPoint(selectionX1Y1)) ||&#13;
            (allowIntersect &amp;&amp; currentObject.containsPoint(selectionX2Y2))&#13;
        ) {&#13;
          group.push(currentObject);&#13;
&#13;
          // only add one object if it's a click&#13;
          if (isClick) {&#13;
            break;&#13;
          }&#13;
        }&#13;
      }&#13;
&#13;
      return group;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _maybeGroupObjects: function(e) {&#13;
      if (this.selection &amp;&amp; this._groupSelector) {&#13;
        this._groupSelectedObjects(e);&#13;
      }&#13;
      this.setCursor(this.defaultCursor);&#13;
      // clear selection and current transformation&#13;
      this._groupSelector = null;&#13;
      this._currentTransform = null;&#13;
    }&#13;
  });&#13;
&#13;
})();&#13;
&#13;
&#13;
(function () {&#13;
&#13;
  var supportQuality = fabric.StaticCanvas.supports('toDataURLWithQuality');&#13;
&#13;
  fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {&#13;
&#13;
    /**&#13;
     * Exports canvas element to a dataurl image. Note that when multiplier is used, cropping is scaled appropriately&#13;
     * @param {Object} [options] Options object&#13;
     * @param {String} [options.format=png] The format of the output image. Either "jpeg" or "png"&#13;
     * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.&#13;
     * @param {Number} [options.multiplier=1] Multiplier to scale by&#13;
     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14&#13;
     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14&#13;
     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14&#13;
     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14&#13;
     * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format&#13;
     * @see {@link http://jsfiddle.net/fabricjs/NfZVb/|jsFiddle demo}&#13;
     * @example &lt;caption&gt;Generate jpeg dataURL with lower quality&lt;/caption&gt;&#13;
     * var dataURL = canvas.toDataURL({&#13;
     *   format: 'jpeg',&#13;
     *   quality: 0.8&#13;
     * });&#13;
     * @example &lt;caption&gt;Generate cropped png dataURL (clipping of canvas)&lt;/caption&gt;&#13;
     * var dataURL = canvas.toDataURL({&#13;
     *   format: 'png',&#13;
     *   left: 100,&#13;
     *   top: 100,&#13;
     *   width: 200,&#13;
     *   height: 200&#13;
     * });&#13;
     * @example &lt;caption&gt;Generate double scaled png dataURL&lt;/caption&gt;&#13;
     * var dataURL = canvas.toDataURL({&#13;
     *   format: 'png',&#13;
     *   multiplier: 2&#13;
     * });&#13;
     */&#13;
    toDataURL: function (options) {&#13;
      options || (options = { });&#13;
&#13;
      var format = options.format || 'png',&#13;
          quality = options.quality || 1,&#13;
          multiplier = options.multiplier || 1,&#13;
          cropping = {&#13;
            left: options.left || 0,&#13;
            top: options.top || 0,&#13;
            width: options.width || 0,&#13;
            height: options.height || 0,&#13;
          };&#13;
      return this.__toDataURLWithMultiplier(format, quality, cropping, multiplier);&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    __toDataURLWithMultiplier: function(format, quality, cropping, multiplier) {&#13;
&#13;
      var origWidth = this.width,&#13;
          origHeight = this.height,&#13;
          scaledWidth = (cropping.width || this.width) * multiplier,&#13;
          scaledHeight = (cropping.height || this.height) * multiplier,&#13;
          zoom = this.getZoom(),&#13;
          newZoom = zoom * multiplier,&#13;
          vp = this.viewportTransform,&#13;
          translateX = (vp[4] - cropping.left) * multiplier,&#13;
          translateY = (vp[5] - cropping.top) * multiplier,&#13;
          newVp = [newZoom, 0, 0, newZoom, translateX, translateY],&#13;
          originalInteractive = this.interactive,&#13;
          originalSkipOffScreen = this.skipOffscreen,&#13;
          needsResize = origWidth !== scaledWidth || origHeight !== scaledHeight;&#13;
&#13;
      this.viewportTransform = newVp;&#13;
      this.skipOffscreen = false;&#13;
      // setting interactive to false avoid exporting controls&#13;
      this.interactive = false;&#13;
      if (needsResize) {&#13;
        this.setDimensions({ width: scaledWidth, height: scaledHeight }, { backstoreOnly: true });&#13;
      }&#13;
      // call a renderAll to force sync update. This will cancel the scheduled requestRenderAll&#13;
      // from setDimensions&#13;
      this.renderAll();&#13;
      var data = this.__toDataURL(format, quality, cropping);&#13;
      this.interactive = originalInteractive;&#13;
      this.skipOffscreen = originalSkipOffScreen;&#13;
      this.viewportTransform = vp;&#13;
      //setDimensions with no option object is taking care of:&#13;
      //this.width, this.height, this.requestRenderAll()&#13;
      if (needsResize) {&#13;
        this.setDimensions({ width: origWidth, height: origHeight }, { backstoreOnly: true });&#13;
      }&#13;
      this.renderAll();&#13;
      return data;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    __toDataURL: function(format, quality) {&#13;
&#13;
      var canvasEl = this.contextContainer.canvas;&#13;
      // to avoid common confusion https://github.com/kangax/fabric.js/issues/806&#13;
      if (format === 'jpg') {&#13;
        format = 'jpeg';&#13;
      }&#13;
&#13;
      var data = supportQuality&#13;
        ? canvasEl.toDataURL('image/' + format, quality)&#13;
        : canvasEl.toDataURL('image/' + format);&#13;
&#13;
      return data;&#13;
    },&#13;
  });&#13;
&#13;
})();&#13;
&#13;
&#13;
fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {&#13;
&#13;
  /**&#13;
   * Populates canvas with data from the specified dataless JSON.&#13;
   * JSON format must conform to the one of {@link fabric.Canvas#toDatalessJSON}&#13;
   * @deprecated since 1.2.2&#13;
   * @param {String|Object} json JSON string or object&#13;
   * @param {Function} callback Callback, invoked when json is parsed&#13;
   *                            and corresponding objects (e.g: {@link fabric.Image})&#13;
   *                            are initialized&#13;
   * @param {Function} [reviver] Method for further parsing of JSON elements, called after each fabric object created.&#13;
   * @return {fabric.Canvas} instance&#13;
   * @chainable&#13;
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#deserialization}&#13;
   */&#13;
  loadFromDatalessJSON: function (json, callback, reviver) {&#13;
    return this.loadFromJSON(json, callback, reviver);&#13;
  },&#13;
&#13;
  /**&#13;
   * Populates canvas with data from the specified JSON.&#13;
   * JSON format must conform to the one of {@link fabric.Canvas#toJSON}&#13;
   * @param {String|Object} json JSON string or object&#13;
   * @param {Function} callback Callback, invoked when json is parsed&#13;
   *                            and corresponding objects (e.g: {@link fabric.Image})&#13;
   *                            are initialized&#13;
   * @param {Function} [reviver] Method for further parsing of JSON elements, called after each fabric object created.&#13;
   * @return {fabric.Canvas} instance&#13;
   * @chainable&#13;
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#deserialization}&#13;
   * @see {@link http://jsfiddle.net/fabricjs/fmgXt/|jsFiddle demo}&#13;
   * @example &lt;caption&gt;loadFromJSON&lt;/caption&gt;&#13;
   * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas));&#13;
   * @example &lt;caption&gt;loadFromJSON with reviver&lt;/caption&gt;&#13;
   * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas), function(o, object) {&#13;
   *   // `o` = json object&#13;
   *   // `object` = fabric.Object instance&#13;
   *   // ... do some stuff ...&#13;
   * });&#13;
   */&#13;
  loadFromJSON: function (json, callback, reviver) {&#13;
    if (!json) {&#13;
      return;&#13;
    }&#13;
&#13;
    // serialize if it wasn't already&#13;
    var serialized = (typeof json === 'string')&#13;
      ? JSON.parse(json)&#13;
      : fabric.util.object.clone(json);&#13;
&#13;
    var _this = this,&#13;
        renderOnAddRemove = this.renderOnAddRemove;&#13;
    this.renderOnAddRemove = false;&#13;
&#13;
    this._enlivenObjects(serialized.objects, function (enlivenedObjects) {&#13;
      _this.clear();&#13;
      _this._setBgOverlay(serialized, function () {&#13;
        enlivenedObjects.forEach(function(obj, index) {&#13;
          // we splice the array just in case some custom classes restored from JSON&#13;
          // will add more object to canvas at canvas init.&#13;
          _this.insertAt(obj, index);&#13;
        });&#13;
        _this.renderOnAddRemove = renderOnAddRemove;&#13;
        // remove parts i cannot set as options&#13;
        delete serialized.objects;&#13;
        delete serialized.backgroundImage;&#13;
        delete serialized.overlayImage;&#13;
        delete serialized.background;&#13;
        delete serialized.overlay;&#13;
        // this._initOptions does too many things to just&#13;
        // call it. Normally loading an Object from JSON&#13;
        // create the Object instance. Here the Canvas is&#13;
        // already an instance and we are just loading things over it&#13;
        _this._setOptions(serialized);&#13;
        _this.renderAll();&#13;
        callback &amp;&amp; callback();&#13;
      });&#13;
    }, reviver);&#13;
    return this;&#13;
  },&#13;
&#13;
  /**&#13;
   * @private&#13;
   * @param {Object} serialized Object with background and overlay information&#13;
   * @param {Function} callback Invoked after all background and overlay images/patterns loaded&#13;
   */&#13;
  _setBgOverlay: function(serialized, callback) {&#13;
    var loaded = {&#13;
      backgroundColor: false,&#13;
      overlayColor: false,&#13;
      backgroundImage: false,&#13;
      overlayImage: false&#13;
    };&#13;
&#13;
    if (!serialized.backgroundImage &amp;&amp; !serialized.overlayImage &amp;&amp; !serialized.background &amp;&amp; !serialized.overlay) {&#13;
      callback &amp;&amp; callback();&#13;
      return;&#13;
    }&#13;
&#13;
    var cbIfLoaded = function () {&#13;
      if (loaded.backgroundImage &amp;&amp; loaded.overlayImage &amp;&amp; loaded.backgroundColor &amp;&amp; loaded.overlayColor) {&#13;
        callback &amp;&amp; callback();&#13;
      }&#13;
    };&#13;
&#13;
    this.__setBgOverlay('backgroundImage', serialized.backgroundImage, loaded, cbIfLoaded);&#13;
    this.__setBgOverlay('overlayImage', serialized.overlayImage, loaded, cbIfLoaded);&#13;
    this.__setBgOverlay('backgroundColor', serialized.background, loaded, cbIfLoaded);&#13;
    this.__setBgOverlay('overlayColor', serialized.overlay, loaded, cbIfLoaded);&#13;
  },&#13;
&#13;
  /**&#13;
   * @private&#13;
   * @param {String} property Property to set (backgroundImage, overlayImage, backgroundColor, overlayColor)&#13;
   * @param {(Object|String)} value Value to set&#13;
   * @param {Object} loaded Set loaded property to true if property is set&#13;
   * @param {Object} callback Callback function to invoke after property is set&#13;
   */&#13;
  __setBgOverlay: function(property, value, loaded, callback) {&#13;
    var _this = this;&#13;
&#13;
    if (!value) {&#13;
      loaded[property] = true;&#13;
      callback &amp;&amp; callback();&#13;
      return;&#13;
    }&#13;
&#13;
    if (property === 'backgroundImage' || property === 'overlayImage') {&#13;
      fabric.util.enlivenObjects([value], function(enlivedObject){&#13;
        _this[property] = enlivedObject[0];&#13;
        loaded[property] = true;&#13;
        callback &amp;&amp; callback();&#13;
      });&#13;
    }&#13;
    else {&#13;
      this['set' + fabric.util.string.capitalize(property, true)](value, function() {&#13;
        loaded[property] = true;&#13;
        callback &amp;&amp; callback();&#13;
      });&#13;
    }&#13;
  },&#13;
&#13;
  /**&#13;
   * @private&#13;
   * @param {Array} objects&#13;
   * @param {Function} callback&#13;
   * @param {Function} [reviver]&#13;
   */&#13;
  _enlivenObjects: function (objects, callback, reviver) {&#13;
    if (!objects || objects.length === 0) {&#13;
      callback &amp;&amp; callback([]);&#13;
      return;&#13;
    }&#13;
&#13;
    fabric.util.enlivenObjects(objects, function(enlivenedObjects) {&#13;
      callback &amp;&amp; callback(enlivenedObjects);&#13;
    }, null, reviver);&#13;
  },&#13;
&#13;
  /**&#13;
   * @private&#13;
   * @param {String} format&#13;
   * @param {Function} callback&#13;
   */&#13;
  _toDataURL: function (format, callback) {&#13;
    this.clone(function (clone) {&#13;
      callback(clone.toDataURL(format));&#13;
    });&#13;
  },&#13;
&#13;
  /**&#13;
   * @private&#13;
   * @param {String} format&#13;
   * @param {Number} multiplier&#13;
   * @param {Function} callback&#13;
   */&#13;
  _toDataURLWithMultiplier: function (format, multiplier, callback) {&#13;
    this.clone(function (clone) {&#13;
      callback(clone.toDataURLWithMultiplier(format, multiplier));&#13;
    });&#13;
  },&#13;
&#13;
  /**&#13;
   * Clones canvas instance&#13;
   * @param {Object} [callback] Receives cloned instance as a first argument&#13;
   * @param {Array} [properties] Array of properties to include in the cloned canvas and children&#13;
   */&#13;
  clone: function (callback, properties) {&#13;
    var data = JSON.stringify(this.toJSON(properties));&#13;
    this.cloneWithoutData(function(clone) {&#13;
      clone.loadFromJSON(data, function() {&#13;
        callback &amp;&amp; callback(clone);&#13;
      });&#13;
    });&#13;
  },&#13;
&#13;
  /**&#13;
   * Clones canvas instance without cloning existing data.&#13;
   * This essentially copies canvas dimensions, clipping properties, etc.&#13;
   * but leaves data empty (so that you can populate it with your own)&#13;
   * @param {Object} [callback] Receives cloned instance as a first argument&#13;
   */&#13;
  cloneWithoutData: function(callback) {&#13;
    var el = fabric.document.createElement('canvas');&#13;
&#13;
    el.width = this.width;&#13;
    el.height = this.height;&#13;
&#13;
    var clone = new fabric.Canvas(el);&#13;
    clone.clipTo = this.clipTo;&#13;
    if (this.backgroundImage) {&#13;
      clone.setBackgroundImage(this.backgroundImage.src, function() {&#13;
        clone.renderAll();&#13;
        callback &amp;&amp; callback(clone);&#13;
      });&#13;
      clone.backgroundImageOpacity = this.backgroundImageOpacity;&#13;
      clone.backgroundImageStretch = this.backgroundImageStretch;&#13;
    }&#13;
    else {&#13;
      callback &amp;&amp; callback(clone);&#13;
    }&#13;
  }&#13;
});&#13;
&#13;
&#13;
(function(global) {&#13;
&#13;
  'use strict';&#13;
&#13;
  var fabric = global.fabric || (global.fabric = { }),&#13;
      extend = fabric.util.object.extend,&#13;
      clone = fabric.util.object.clone,&#13;
      toFixed = fabric.util.toFixed,&#13;
      capitalize = fabric.util.string.capitalize,&#13;
      degreesToRadians = fabric.util.degreesToRadians,&#13;
      supportsLineDash = fabric.StaticCanvas.supports('setLineDash'),&#13;
      objectCaching = !fabric.isLikelyNode,&#13;
      ALIASING_LIMIT = 2;&#13;
&#13;
  if (fabric.Object) {&#13;
    return;&#13;
  }&#13;
&#13;
  /**&#13;
   * Root object class from which all 2d shape classes inherit from&#13;
   * @class fabric.Object&#13;
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#objects}&#13;
   * @see {@link fabric.Object#initialize} for constructor definition&#13;
   *&#13;
   * @fires added&#13;
   * @fires removed&#13;
   *&#13;
   * @fires selected&#13;
   * @fires deselected&#13;
   * @fires modified&#13;
   * @fires rotating&#13;
   * @fires scaling&#13;
   * @fires moving&#13;
   * @fires skewing&#13;
   *&#13;
   * @fires mousedown&#13;
   * @fires mouseup&#13;
   * @fires mouseover&#13;
   * @fires mouseout&#13;
   * @fires mousewheel&#13;
   * @fires mousedblclick&#13;
   */&#13;
  fabric.Object = fabric.util.createClass(fabric.CommonMethods, /** @lends fabric.Object.prototype */ {&#13;
&#13;
    /**&#13;
     * Type of an object (rect, circle, path, etc.).&#13;
     * Note that this property is meant to be read-only and not meant to be modified.&#13;
     * If you modify, certain parts of Fabric (such as JSON loading) won't work correctly.&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    type:                     'object',&#13;
&#13;
    /**&#13;
     * Horizontal origin of transformation of an object (one of "left", "right", "center")&#13;
     * See http://jsfiddle.net/1ow02gea/244/ on how originX/originY affect objects in groups&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    originX:                  'left',&#13;
&#13;
    /**&#13;
     * Vertical origin of transformation of an object (one of "top", "bottom", "center")&#13;
     * See http://jsfiddle.net/1ow02gea/244/ on how originX/originY affect objects in groups&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    originY:                  'top',&#13;
&#13;
    /**&#13;
     * Top position of an object. Note that by default it's relative to object top. You can change this by setting originY={top/center/bottom}&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    top:                      0,&#13;
&#13;
    /**&#13;
     * Left position of an object. Note that by default it's relative to object left. You can change this by setting originX={left/center/right}&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    left:                     0,&#13;
&#13;
    /**&#13;
     * Object width&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    width:                    0,&#13;
&#13;
    /**&#13;
     * Object height&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    height:                   0,&#13;
&#13;
    /**&#13;
     * Object scale factor (horizontal)&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    scaleX:                   1,&#13;
&#13;
    /**&#13;
     * Object scale factor (vertical)&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    scaleY:                   1,&#13;
&#13;
    /**&#13;
     * When true, an object is rendered as flipped horizontally&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    flipX:                    false,&#13;
&#13;
    /**&#13;
     * When true, an object is rendered as flipped vertically&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    flipY:                    false,&#13;
&#13;
    /**&#13;
     * Opacity of an object&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    opacity:                  1,&#13;
&#13;
    /**&#13;
     * Angle of rotation of an object (in degrees)&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    angle:                    0,&#13;
&#13;
    /**&#13;
     * Angle of skew on x axes of an object (in degrees)&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    skewX:                    0,&#13;
&#13;
    /**&#13;
     * Angle of skew on y axes of an object (in degrees)&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    skewY:                    0,&#13;
&#13;
    /**&#13;
     * Size of object's controlling corners (in pixels)&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    cornerSize:               13,&#13;
&#13;
    /**&#13;
     * When true, object's controlling corners are rendered as transparent inside (i.e. stroke instead of fill)&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    transparentCorners:       true,&#13;
&#13;
    /**&#13;
     * Default cursor value used when hovering over this object on canvas&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    hoverCursor:              null,&#13;
&#13;
    /**&#13;
     * Default cursor value used when moving this object on canvas&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    moveCursor:               null,&#13;
&#13;
    /**&#13;
     * Padding between object and its controlling borders (in pixels)&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    padding:                  0,&#13;
&#13;
    /**&#13;
     * Color of controlling borders of an object (when it's active)&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    borderColor:              'rgba(102,153,255,0.75)',&#13;
&#13;
    /**&#13;
     * Array specifying dash pattern of an object's borders (hasBorder must be true)&#13;
     * @since 1.6.2&#13;
     * @type Array&#13;
     */&#13;
    borderDashArray:          null,&#13;
&#13;
    /**&#13;
     * Color of controlling corners of an object (when it's active)&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    cornerColor:              'rgba(102,153,255,0.5)',&#13;
&#13;
    /**&#13;
     * Color of controlling corners of an object (when it's active and transparentCorners false)&#13;
     * @since 1.6.2&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    cornerStrokeColor:        null,&#13;
&#13;
    /**&#13;
     * Specify style of control, 'rect' or 'circle'&#13;
     * @since 1.6.2&#13;
     * @type String&#13;
     */&#13;
    cornerStyle:          'rect',&#13;
&#13;
    /**&#13;
     * Array specifying dash pattern of an object's control (hasBorder must be true)&#13;
     * @since 1.6.2&#13;
     * @type Array&#13;
     */&#13;
    cornerDashArray:          null,&#13;
&#13;
    /**&#13;
     * When true, this object will use center point as the origin of transformation&#13;
     * when being scaled via the controls.&#13;
     * &lt;b&gt;Backwards incompatibility note:&lt;/b&gt; This property replaces "centerTransform" (Boolean).&#13;
     * @since 1.3.4&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    centeredScaling:          false,&#13;
&#13;
    /**&#13;
     * When true, this object will use center point as the origin of transformation&#13;
     * when being rotated via the controls.&#13;
     * &lt;b&gt;Backwards incompatibility note:&lt;/b&gt; This property replaces "centerTransform" (Boolean).&#13;
     * @since 1.3.4&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    centeredRotation:         true,&#13;
&#13;
    /**&#13;
     * Color of object's fill&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    fill:                     'rgb(0,0,0)',&#13;
&#13;
    /**&#13;
     * Fill rule used to fill an object&#13;
     * accepted values are nonzero, evenodd&#13;
     * &lt;b&gt;Backwards incompatibility note:&lt;/b&gt; This property was used for setting globalCompositeOperation until v1.4.12 (use `fabric.Object#globalCompositeOperation` instead)&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    fillRule:                 'nonzero',&#13;
&#13;
    /**&#13;
     * Composite rule used for canvas globalCompositeOperation&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    globalCompositeOperation: 'source-over',&#13;
&#13;
    /**&#13;
     * Background color of an object.&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    backgroundColor:          '',&#13;
&#13;
    /**&#13;
     * Selection Background color of an object. colored layer behind the object when it is active.&#13;
     * does not mix good with globalCompositeOperation methods.&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    selectionBackgroundColor:          '',&#13;
&#13;
    /**&#13;
     * When defined, an object is rendered via stroke and this property specifies its color&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    stroke:                   null,&#13;
&#13;
    /**&#13;
     * Width of a stroke used to render this object&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    strokeWidth:              1,&#13;
&#13;
    /**&#13;
     * Array specifying dash pattern of an object's stroke (stroke must be defined)&#13;
     * @type Array&#13;
     */&#13;
    strokeDashArray:          null,&#13;
&#13;
    /**&#13;
     * Line endings style of an object's stroke (one of "butt", "round", "square")&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    strokeLineCap:            'butt',&#13;
&#13;
    /**&#13;
     * Corner style of an object's stroke (one of "bevil", "round", "miter")&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    strokeLineJoin:           'miter',&#13;
&#13;
    /**&#13;
     * Maximum miter length (used for strokeLineJoin = "miter") of an object's stroke&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    strokeMiterLimit:         10,&#13;
&#13;
    /**&#13;
     * Shadow object representing shadow of this shape&#13;
     * @type fabric.Shadow&#13;
     * @default&#13;
     */&#13;
    shadow:                   null,&#13;
&#13;
    /**&#13;
     * Opacity of object's controlling borders when object is active and moving&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    borderOpacityWhenMoving:  0.4,&#13;
&#13;
    /**&#13;
     * Scale factor of object's controlling borders&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    borderScaleFactor:        1,&#13;
&#13;
    /**&#13;
     * Transform matrix (similar to SVG's transform matrix)&#13;
     * @type Array&#13;
     */&#13;
    transformMatrix:          null,&#13;
&#13;
    /**&#13;
     * Minimum allowed scale value of an object&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    minScaleLimit:            0,&#13;
&#13;
    /**&#13;
     * When set to `false`, an object can not be selected for modification (using either point-click-based or group-based selection).&#13;
     * But events still fire on it.&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    selectable:               true,&#13;
&#13;
    /**&#13;
     * When set to `false`, an object can not be a target of events. All events propagate through it. Introduced in v1.3.4&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    evented:                  true,&#13;
&#13;
    /**&#13;
     * When set to `false`, an object is not rendered on canvas&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    visible:                  true,&#13;
&#13;
    /**&#13;
     * When set to `false`, object's controls are not displayed and can not be used to manipulate object&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    hasControls:              true,&#13;
&#13;
    /**&#13;
     * When set to `false`, object's controlling borders are not rendered&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    hasBorders:               true,&#13;
&#13;
    /**&#13;
     * When set to `false`, object's controlling rotating point will not be visible or selectable&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    hasRotatingPoint:         true,&#13;
&#13;
    /**&#13;
     * Offset for object's controlling rotating point (when enabled via `hasRotatingPoint`)&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    rotatingPointOffset:      40,&#13;
&#13;
    /**&#13;
     * When set to `true`, objects are "found" on canvas on per-pixel basis rather than according to bounding box&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    perPixelTargetFind:       false,&#13;
&#13;
    /**&#13;
     * When `false`, default object's values are not included in its serialization&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    includeDefaultValues:     true,&#13;
&#13;
    /**&#13;
     * Function that determines clipping of an object (context is passed as a first argument)&#13;
     * Note that context origin is at the object's center point (not left/top corner)&#13;
     * @deprecated since 2.0.0&#13;
     * @type Function&#13;
     */&#13;
    clipTo:                   null,&#13;
&#13;
    /**&#13;
     * When `true`, object horizontal movement is locked&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    lockMovementX:            false,&#13;
&#13;
    /**&#13;
     * When `true`, object vertical movement is locked&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    lockMovementY:            false,&#13;
&#13;
    /**&#13;
     * When `true`, object rotation is locked&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    lockRotation:             false,&#13;
&#13;
    /**&#13;
     * When `true`, object horizontal scaling is locked&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    lockScalingX:             false,&#13;
&#13;
    /**&#13;
     * When `true`, object vertical scaling is locked&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    lockScalingY:             false,&#13;
&#13;
    /**&#13;
     * When `true`, object non-uniform scaling is locked&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    lockUniScaling:           false,&#13;
&#13;
    /**&#13;
     * When `true`, object horizontal skewing is locked&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    lockSkewingX:             false,&#13;
&#13;
    /**&#13;
     * When `true`, object vertical skewing is locked&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    lockSkewingY:             false,&#13;
&#13;
    /**&#13;
     * When `true`, object cannot be flipped by scaling into negative values&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    lockScalingFlip:          false,&#13;
&#13;
    /**&#13;
     * When `true`, object is not exported in SVG or OBJECT/JSON&#13;
     * since 1.6.3&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    excludeFromExport:        false,&#13;
&#13;
    /**&#13;
     * When `true`, object is cached on an additional canvas.&#13;
     * default to true&#13;
     * since 1.7.0&#13;
     * @type Boolean&#13;
     * @default true&#13;
     */&#13;
    objectCaching:            objectCaching,&#13;
&#13;
    /**&#13;
     * When `true`, object properties are checked for cache invalidation. In some particular&#13;
     * situation you may want this to be disabled ( spray brush, very big, groups)&#13;
     * or if your application does not allow you to modify properties for groups child you want&#13;
     * to disable it for groups.&#13;
     * default to false&#13;
     * since 1.7.0&#13;
     * @type Boolean&#13;
     * @default false&#13;
     */&#13;
    statefullCache:            false,&#13;
&#13;
    /**&#13;
     * When `true`, cache does not get updated during scaling. The picture will get blocky if scaled&#13;
     * too much and will be redrawn with correct details at the end of scaling.&#13;
     * this setting is performance and application dependant.&#13;
     * default to true&#13;
     * since 1.7.0&#13;
     * @type Boolean&#13;
     * @default true&#13;
     */&#13;
    noScaleCache:              true,&#13;
&#13;
    /**&#13;
     * When set to `true`, object's cache will be rerendered next render call.&#13;
     * since 1.7.0&#13;
     * @type Boolean&#13;
     * @default true&#13;
     */&#13;
    dirty:                true,&#13;
&#13;
    /**&#13;
     * keeps the value of the last hovered coner during mouse move.&#13;
     * 0 is no corner, or 'mt', 'ml', 'mtr' etc..&#13;
     * It should be private, but there is no harm in using it as&#13;
     * a read-only property.&#13;
     * @type number|string|any&#13;
     * @default 0&#13;
     */&#13;
    __corner: 0,&#13;
&#13;
    /**&#13;
     * Determins if the fill or the stroke is drawn first (one of "fill" or "stroke")&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    paintFirst:           'fill',&#13;
&#13;
    /**&#13;
     * List of properties to consider when checking if state&#13;
     * of an object is changed (fabric.Object#hasStateChanged)&#13;
     * as well as for history (undo/redo) purposes&#13;
     * @type Array&#13;
     */&#13;
    stateProperties: (&#13;
      'top left width height scaleX scaleY flipX flipY originX originY transformMatrix ' +&#13;
      'stroke strokeWidth strokeDashArray strokeLineCap strokeLineJoin strokeMiterLimit ' +&#13;
      'angle opacity fill globalCompositeOperation shadow clipTo visible backgroundColor ' +&#13;
      'skewX skewY fillRule paintFirst'&#13;
    ).split(' '),&#13;
&#13;
    /**&#13;
     * List of properties to consider when checking if cache needs refresh&#13;
     * @type Array&#13;
     */&#13;
    cacheProperties: (&#13;
      'fill stroke strokeWidth strokeDashArray width height paintFirst' +&#13;
      ' strokeLineCap strokeLineJoin strokeMiterLimit backgroundColor'&#13;
    ).split(' '),&#13;
&#13;
    /**&#13;
     * Constructor&#13;
     * @param {Object} [options] Options object&#13;
     */&#13;
    initialize: function(options) {&#13;
      if (options) {&#13;
        this.setOptions(options);&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Create a the canvas used to keep the cached copy of the object&#13;
     * @private&#13;
     */&#13;
    _createCacheCanvas: function() {&#13;
      this._cacheProperties = {};&#13;
      this._cacheCanvas = fabric.document.createElement('canvas');&#13;
      this._cacheContext = this._cacheCanvas.getContext('2d');&#13;
      this._updateCacheCanvas();&#13;
    },&#13;
&#13;
    /**&#13;
     * Limit the cache dimensions so that X * Y do not cross fabric.perfLimitSizeTotal&#13;
     * and each side do not cross fabric.cacheSideLimit&#13;
     * those numbers are configurable so that you can get as much detail as you want&#13;
     * making bargain with performances.&#13;
     * @param {Object} dims&#13;
     * @param {Object} dims.width width of canvas&#13;
     * @param {Object} dims.height height of canvas&#13;
     * @param {Object} dims.zoomX zoomX zoom value to unscale the canvas before drawing cache&#13;
     * @param {Object} dims.zoomY zoomY zoom value to unscale the canvas before drawing cache&#13;
     * @return {Object}.width width of canvas&#13;
     * @return {Object}.height height of canvas&#13;
     * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache&#13;
     * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache&#13;
     */&#13;
    _limitCacheSize: function(dims) {&#13;
      var perfLimitSizeTotal = fabric.perfLimitSizeTotal,&#13;
          width = dims.width, height = dims.height,&#13;
          max = fabric.maxCacheSideLimit, min = fabric.minCacheSideLimit;&#13;
      if (width &lt;= max &amp;&amp; height &lt;= max &amp;&amp; width * height &lt;= perfLimitSizeTotal) {&#13;
        if (width &lt; min) {&#13;
          dims.width = min;&#13;
        }&#13;
        if (height &lt; min) {&#13;
          dims.height = min;&#13;
        }&#13;
        return dims;&#13;
      }&#13;
      var ar = width / height, limitedDims = fabric.util.limitDimsByArea(ar, perfLimitSizeTotal),&#13;
          capValue = fabric.util.capValue,&#13;
          x = capValue(min, limitedDims.x, max),&#13;
          y = capValue(min, limitedDims.y, max);&#13;
      if (width &gt; x) {&#13;
        dims.zoomX /= width / x;&#13;
        dims.width = x;&#13;
        dims.capped = true;&#13;
      }&#13;
      if (height &gt; y) {&#13;
        dims.zoomY /= height / y;&#13;
        dims.height = y;&#13;
        dims.capped = true;&#13;
      }&#13;
      return dims;&#13;
    },&#13;
&#13;
    /**&#13;
     * Return the dimension and the zoom level needed to create a cache canvas&#13;
     * big enough to host the object to be cached.&#13;
     * @private&#13;
     * @param {Object} dim.x width of object to be cached&#13;
     * @param {Object} dim.y height of object to be cached&#13;
     * @return {Object}.width width of canvas&#13;
     * @return {Object}.height height of canvas&#13;
     * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache&#13;
     * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache&#13;
     */&#13;
    _getCacheCanvasDimensions: function() {&#13;
      var zoom = this.canvas &amp;&amp; this.canvas.getZoom() || 1,&#13;
          objectScale = this.getObjectScaling(),&#13;
          retina = this.canvas &amp;&amp; this.canvas._isRetinaScaling() ? fabric.devicePixelRatio : 1,&#13;
          dim = this._getNonTransformedDimensions(),&#13;
          zoomX = objectScale.scaleX * zoom * retina,&#13;
          zoomY = objectScale.scaleY * zoom * retina,&#13;
          width = dim.x * zoomX,&#13;
          height = dim.y * zoomY;&#13;
      return {&#13;
        // for sure this ALIASING_LIMIT is slightly crating problem&#13;
        // in situation in wich the cache canvas gets an upper limit&#13;
        width: width + ALIASING_LIMIT,&#13;
        height: height + ALIASING_LIMIT,&#13;
        zoomX: zoomX,&#13;
        zoomY: zoomY,&#13;
        x: dim.x,&#13;
        y: dim.y&#13;
      };&#13;
    },&#13;
&#13;
    /**&#13;
     * Update width and height of the canvas for cache&#13;
     * returns true or false if canvas needed resize.&#13;
     * @private&#13;
     * @return {Boolean} true if the canvas has been resized&#13;
     */&#13;
    _updateCacheCanvas: function() {&#13;
      if (this.noScaleCache &amp;&amp; this.canvas &amp;&amp; this.canvas._currentTransform) {&#13;
        var target = this.canvas._currentTransform.target,&#13;
            action = this.canvas._currentTransform.action;&#13;
        if (this === target &amp;&amp; action.slice &amp;&amp; action.slice(0, 5) === 'scale') {&#13;
          return false;&#13;
        }&#13;
      }&#13;
      var canvas = this._cacheCanvas,&#13;
          dims = this._limitCacheSize(this._getCacheCanvasDimensions()),&#13;
          minCacheSize = fabric.minCacheSideLimit,&#13;
          width = dims.width, height = dims.height, drawingWidth, drawingHeight,&#13;
          zoomX = dims.zoomX, zoomY = dims.zoomY,&#13;
          dimensionsChanged = width !== this.cacheWidth || height !== this.cacheHeight,&#13;
          zoomChanged = this.zoomX !== zoomX || this.zoomY !== zoomY,&#13;
          shouldRedraw = dimensionsChanged || zoomChanged,&#13;
          additionalWidth = 0, additionalHeight = 0, shouldResizeCanvas = false;&#13;
      if (dimensionsChanged) {&#13;
        var canvasWidth = this._cacheCanvas.width,&#13;
            canvasHeight = this._cacheCanvas.height,&#13;
            sizeGrowing = width &gt; canvasWidth || height &gt; canvasHeight,&#13;
            sizeShrinking = (width &lt; canvasWidth * 0.9 || height &lt; canvasHeight * 0.9) &amp;&amp;&#13;
              canvasWidth &gt; minCacheSize &amp;&amp; canvasHeight &gt; minCacheSize;&#13;
        shouldResizeCanvas = sizeGrowing || sizeShrinking;&#13;
        if (sizeGrowing &amp;&amp; !dims.capped &amp;&amp; (width &gt; minCacheSize || height &gt; minCacheSize)) {&#13;
          additionalWidth = width * 0.1;&#13;
          additionalHeight = height * 0.1;&#13;
        }&#13;
      }&#13;
      if (shouldRedraw) {&#13;
        if (shouldResizeCanvas) {&#13;
          canvas.width = Math.ceil(width + additionalWidth);&#13;
          canvas.height = Math.ceil(height + additionalHeight);&#13;
        }&#13;
        else {&#13;
          this._cacheContext.setTransform(1, 0, 0, 1, 0, 0);&#13;
          this._cacheContext.clearRect(0, 0, canvas.width, canvas.height);&#13;
        }&#13;
        drawingWidth = dims.x * zoomX / 2;&#13;
        drawingHeight = dims.y * zoomY / 2;&#13;
        this.cacheTranslationX = Math.round(canvas.width / 2 - drawingWidth) + drawingWidth;&#13;
        this.cacheTranslationY = Math.round(canvas.height / 2 - drawingHeight) + drawingHeight;&#13;
        this.cacheWidth = width;&#13;
        this.cacheHeight = height;&#13;
        this._cacheContext.translate(this.cacheTranslationX, this.cacheTranslationY);&#13;
        this._cacheContext.scale(zoomX, zoomY);&#13;
        this.zoomX = zoomX;&#13;
        this.zoomY = zoomY;&#13;
        return true;&#13;
      }&#13;
      return false;&#13;
    },&#13;
&#13;
    /**&#13;
     * Sets object's properties from options&#13;
     * @param {Object} [options] Options object&#13;
     */&#13;
    setOptions: function(options) {&#13;
      this._setOptions(options);&#13;
      this._initGradient(options.fill, 'fill');&#13;
      this._initGradient(options.stroke, 'stroke');&#13;
      this._initClipping(options);&#13;
      this._initPattern(options.fill, 'fill');&#13;
      this._initPattern(options.stroke, 'stroke');&#13;
    },&#13;
&#13;
    /**&#13;
     * Transforms context when rendering an object&#13;
     * @param {CanvasRenderingContext2D} ctx Context&#13;
     */&#13;
    transform: function(ctx) {&#13;
      var m;&#13;
      if (this.group &amp;&amp; !this.group._transformDone) {&#13;
        m = this.calcTransformMatrix();&#13;
      }&#13;
      else {&#13;
        m = this.calcOwnMatrix();&#13;
      }&#13;
      ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns an object representation of an instance&#13;
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output&#13;
     * @return {Object} Object representation of an instance&#13;
     */&#13;
    toObject: function(propertiesToInclude) {&#13;
      var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,&#13;
&#13;
          object = {&#13;
            type:                     this.type,&#13;
            version:                  fabric.version,&#13;
            originX:                  this.originX,&#13;
            originY:                  this.originY,&#13;
            left:                     toFixed(this.left, NUM_FRACTION_DIGITS),&#13;
            top:                      toFixed(this.top, NUM_FRACTION_DIGITS),&#13;
            width:                    toFixed(this.width, NUM_FRACTION_DIGITS),&#13;
            height:                   toFixed(this.height, NUM_FRACTION_DIGITS),&#13;
            fill:                     (this.fill &amp;&amp; this.fill.toObject) ? this.fill.toObject() : this.fill,&#13;
            stroke:                   (this.stroke &amp;&amp; this.stroke.toObject) ? this.stroke.toObject() : this.stroke,&#13;
            strokeWidth:              toFixed(this.strokeWidth, NUM_FRACTION_DIGITS),&#13;
            strokeDashArray:          this.strokeDashArray ? this.strokeDashArray.concat() : this.strokeDashArray,&#13;
            strokeLineCap:            this.strokeLineCap,&#13;
            strokeLineJoin:           this.strokeLineJoin,&#13;
            strokeMiterLimit:         toFixed(this.strokeMiterLimit, NUM_FRACTION_DIGITS),&#13;
            scaleX:                   toFixed(this.scaleX, NUM_FRACTION_DIGITS),&#13;
            scaleY:                   toFixed(this.scaleY, NUM_FRACTION_DIGITS),&#13;
            angle:                    toFixed(this.angle, NUM_FRACTION_DIGITS),&#13;
            flipX:                    this.flipX,&#13;
            flipY:                    this.flipY,&#13;
            opacity:                  toFixed(this.opacity, NUM_FRACTION_DIGITS),&#13;
            shadow:                   (this.shadow &amp;&amp; this.shadow.toObject) ? this.shadow.toObject() : this.shadow,&#13;
            visible:                  this.visible,&#13;
            clipTo:                   this.clipTo &amp;&amp; String(this.clipTo),&#13;
            backgroundColor:          this.backgroundColor,&#13;
            fillRule:                 this.fillRule,&#13;
            paintFirst:               this.paintFirst,&#13;
            globalCompositeOperation: this.globalCompositeOperation,&#13;
            transformMatrix:          this.transformMatrix ? this.transformMatrix.concat() : null,&#13;
            skewX:                    toFixed(this.skewX, NUM_FRACTION_DIGITS),&#13;
            skewY:                    toFixed(this.skewY, NUM_FRACTION_DIGITS)&#13;
          };&#13;
&#13;
      fabric.util.populateWithProperties(this, object, propertiesToInclude);&#13;
      if (!this.includeDefaultValues) {&#13;
        object = this._removeDefaultValues(object);&#13;
      }&#13;
&#13;
      return object;&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns (dataless) object representation of an instance&#13;
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output&#13;
     * @return {Object} Object representation of an instance&#13;
     */&#13;
    toDatalessObject: function(propertiesToInclude) {&#13;
      // will be overwritten by subclasses&#13;
      return this.toObject(propertiesToInclude);&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Object} object&#13;
     */&#13;
    _removeDefaultValues: function(object) {&#13;
      var prototype = fabric.util.getKlass(object.type).prototype,&#13;
          stateProperties = prototype.stateProperties;&#13;
      stateProperties.forEach(function(prop) {&#13;
        if (object[prop] === prototype[prop]) {&#13;
          delete object[prop];&#13;
        }&#13;
        var isArray = Object.prototype.toString.call(object[prop]) === '[object Array]' &amp;&amp;&#13;
                      Object.prototype.toString.call(prototype[prop]) === '[object Array]';&#13;
&#13;
        // basically a check for [] === []&#13;
        if (isArray &amp;&amp; object[prop].length === 0 &amp;&amp; prototype[prop].length === 0) {&#13;
          delete object[prop];&#13;
        }&#13;
      });&#13;
&#13;
      return object;&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns a string representation of an instance&#13;
     * @return {String}&#13;
     */&#13;
    toString: function() {&#13;
      return '#&lt;fabric.' + capitalize(this.type) + '&gt;';&#13;
    },&#13;
&#13;
    /**&#13;
     * Return the object scale factor counting also the group scaling&#13;
     * @return {Object} object with scaleX and scaleY properties&#13;
     */&#13;
    getObjectScaling: function() {&#13;
      var scaleX = this.scaleX, scaleY = this.scaleY;&#13;
      if (this.group) {&#13;
        var scaling = this.group.getObjectScaling();&#13;
        scaleX *= scaling.scaleX;&#13;
        scaleY *= scaling.scaleY;&#13;
      }&#13;
      return { scaleX: scaleX, scaleY: scaleY };&#13;
    },&#13;
&#13;
    /**&#13;
     * Return the object opacity counting also the group property&#13;
     * @return {Number}&#13;
     */&#13;
    getObjectOpacity: function() {&#13;
      var opacity = this.opacity;&#13;
      if (this.group) {&#13;
        opacity *= this.group.getObjectOpacity();&#13;
      }&#13;
      return opacity;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {String} key&#13;
     * @param {*} value&#13;
     * @return {fabric.Object} thisArg&#13;
     */&#13;
    _set: function(key, value) {&#13;
      var shouldConstrainValue = (key === 'scaleX' || key === 'scaleY'),&#13;
          isChanged = this[key] !== value, groupNeedsUpdate = false;&#13;
&#13;
      if (shouldConstrainValue) {&#13;
        value = this._constrainScale(value);&#13;
      }&#13;
      if (key === 'scaleX' &amp;&amp; value &lt; 0) {&#13;
        this.flipX = !this.flipX;&#13;
        value *= -1;&#13;
      }&#13;
      else if (key === 'scaleY' &amp;&amp; value &lt; 0) {&#13;
        this.flipY = !this.flipY;&#13;
        value *= -1;&#13;
      }&#13;
      else if (key === 'shadow' &amp;&amp; value &amp;&amp; !(value instanceof fabric.Shadow)) {&#13;
        value = new fabric.Shadow(value);&#13;
      }&#13;
      else if (key === 'dirty' &amp;&amp; this.group) {&#13;
        this.group.set('dirty', value);&#13;
      }&#13;
&#13;
      this[key] = value;&#13;
&#13;
      if (isChanged) {&#13;
        groupNeedsUpdate = this.group &amp;&amp; this.group.isOnACache();&#13;
        if (this.cacheProperties.indexOf(key) &gt; -1) {&#13;
          this.dirty = true;&#13;
          groupNeedsUpdate &amp;&amp; this.group.set('dirty', true);&#13;
        }&#13;
        else if (groupNeedsUpdate &amp;&amp; this.stateProperties.indexOf(key) &gt; -1) {&#13;
          this.group.set('dirty', true);&#13;
        }&#13;
      }&#13;
&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * This callback function is called by the parent group of an object every&#13;
     * time a non-delegated property changes on the group. It is passed the key&#13;
     * and value as parameters. Not adding in this function's signature to avoid&#13;
     * Travis build error about unused variables.&#13;
     */&#13;
    setOnGroup: function() {&#13;
      // implemented by sub-classes, as needed.&#13;
    },&#13;
&#13;
    /**&#13;
     * Retrieves viewportTransform from Object's canvas if possible&#13;
     * @method getViewportTransform&#13;
     * @memberOf fabric.Object.prototype&#13;
     * @return {Boolean}&#13;
     */&#13;
    getViewportTransform: function() {&#13;
      if (this.canvas &amp;&amp; this.canvas.viewportTransform) {&#13;
        return this.canvas.viewportTransform;&#13;
      }&#13;
      return fabric.iMatrix.concat();&#13;
    },&#13;
&#13;
    /*&#13;
     * @private&#13;
     * return if the object would be visible in rendering&#13;
     * @memberOf fabric.Object.prototype&#13;
     * @return {Boolean}&#13;
     */&#13;
    isNotVisible: function() {&#13;
      return this.opacity === 0 || (this.width === 0 &amp;&amp; this.height === 0) || !this.visible;&#13;
    },&#13;
&#13;
    /**&#13;
     * Renders an object on a specified context&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     */&#13;
    render: function(ctx) {&#13;
      // do not render if width/height are zeros or object is not visible&#13;
      if (this.isNotVisible()) {&#13;
        return;&#13;
      }&#13;
      if (this.canvas &amp;&amp; this.canvas.skipOffscreen &amp;&amp; !this.group &amp;&amp; !this.isOnScreen()) {&#13;
        return;&#13;
      }&#13;
      ctx.save();&#13;
      this._setupCompositeOperation(ctx);&#13;
      this.drawSelectionBackground(ctx);&#13;
      this.transform(ctx);&#13;
      this._setOpacity(ctx);&#13;
      this._setShadow(ctx, this);&#13;
      if (this.transformMatrix) {&#13;
        ctx.transform.apply(ctx, this.transformMatrix);&#13;
      }&#13;
      this.clipTo &amp;&amp; fabric.util.clipContext(this, ctx);&#13;
      if (this.shouldCache()) {&#13;
        if (!this._cacheCanvas) {&#13;
          this._createCacheCanvas();&#13;
        }&#13;
        if (this.isCacheDirty()) {&#13;
          this.statefullCache &amp;&amp; this.saveState({ propertySet: 'cacheProperties' });&#13;
          this.drawObject(this._cacheContext);&#13;
          this.dirty = false;&#13;
        }&#13;
        this.drawCacheOnCanvas(ctx);&#13;
      }&#13;
      else {&#13;
        this._removeCacheCanvas();&#13;
        this.dirty = false;&#13;
        this.drawObject(ctx);&#13;
        if (this.objectCaching &amp;&amp; this.statefullCache) {&#13;
          this.saveState({ propertySet: 'cacheProperties' });&#13;
        }&#13;
      }&#13;
      this.clipTo &amp;&amp; ctx.restore();&#13;
      ctx.restore();&#13;
    },&#13;
&#13;
    /**&#13;
     * Remove cacheCanvas and its dimensions from the objects&#13;
     */&#13;
    _removeCacheCanvas: function() {&#13;
      this._cacheCanvas = null;&#13;
      this.cacheWidth = 0;&#13;
      this.cacheHeight = 0;&#13;
    },&#13;
&#13;
    /**&#13;
     * When set to `true`, force the object to have its own cache, even if it is inside a group&#13;
     * it may be needed when your object behave in a particular way on the cache and always needs&#13;
     * its own isolated canvas to render correctly.&#13;
     * Created to be overridden&#13;
     * since 1.7.12&#13;
     * @returns false&#13;
     */&#13;
    needsItsOwnCache: function() {&#13;
      if (this.paintFirst === 'stroke' &amp;&amp; typeof this.shadow === 'object') {&#13;
        return true;&#13;
      }&#13;
      return false;&#13;
    },&#13;
&#13;
    /**&#13;
     * Decide if the object should cache or not. Create its own cache level&#13;
     * objectCaching is a global flag, wins over everything&#13;
     * needsItsOwnCache should be used when the object drawing method requires&#13;
     * a cache step. None of the fabric classes requires it.&#13;
     * Generally you do not cache objects in groups because the group outside is cached.&#13;
     * @return {Boolean}&#13;
     */&#13;
    shouldCache: function() {&#13;
      this.ownCaching = this.objectCaching &amp;&amp;&#13;
      (!this.group || this.needsItsOwnCache() || !this.group.isOnACache());&#13;
      return this.ownCaching;&#13;
    },&#13;
&#13;
    /**&#13;
     * Check if this object or a child object will cast a shadow&#13;
     * used by Group.shouldCache to know if child has a shadow recursively&#13;
     * @return {Boolean}&#13;
     */&#13;
    willDrawShadow: function() {&#13;
      return !!this.shadow &amp;&amp; (this.shadow.offsetX !== 0 || this.shadow.offsetY !== 0);&#13;
    },&#13;
&#13;
    /**&#13;
     * Execute the drawing operation for an object on a specified context&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     */&#13;
    drawObject: function(ctx) {&#13;
      this._renderBackground(ctx);&#13;
      this._setStrokeStyles(ctx, this);&#13;
      this._setFillStyles(ctx, this);&#13;
      this._render(ctx);&#13;
    },&#13;
&#13;
    /**&#13;
     * Paint the cached copy of the object on the target context.&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     */&#13;
    drawCacheOnCanvas: function(ctx) {&#13;
      ctx.scale(1 / this.zoomX, 1 / this.zoomY);&#13;
      ctx.drawImage(this._cacheCanvas, -this.cacheTranslationX, -this.cacheTranslationY);&#13;
    },&#13;
&#13;
    /**&#13;
     * Check if cache is dirty&#13;
     * @param {Boolean} skipCanvas skip canvas checks because this object is painted&#13;
     * on parent canvas.&#13;
     */&#13;
    isCacheDirty: function(skipCanvas) {&#13;
      if (this.isNotVisible()) {&#13;
        return false;&#13;
      }&#13;
      if (this._cacheCanvas &amp;&amp; !skipCanvas &amp;&amp; this._updateCacheCanvas()) {&#13;
        // in this case the context is already cleared.&#13;
        return true;&#13;
      }&#13;
      else {&#13;
        if (this.dirty || (this.statefullCache &amp;&amp; this.hasStateChanged('cacheProperties'))) {&#13;
          if (this._cacheCanvas &amp;&amp; !skipCanvas) {&#13;
            var width = this.cacheWidth / this.zoomX;&#13;
            var height = this.cacheHeight / this.zoomY;&#13;
            this._cacheContext.clearRect(-width / 2, -height / 2, width, height);&#13;
          }&#13;
          return true;&#13;
        }&#13;
      }&#13;
      return false;&#13;
    },&#13;
&#13;
    /**&#13;
     * Draws a background for the object big as its untrasformed dimensions&#13;
     * @private&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     */&#13;
    _renderBackground: function(ctx) {&#13;
      if (!this.backgroundColor) {&#13;
        return;&#13;
      }&#13;
      var dim = this._getNonTransformedDimensions();&#13;
      ctx.fillStyle = this.backgroundColor;&#13;
&#13;
      ctx.fillRect(&#13;
        -dim.x / 2,&#13;
        -dim.y / 2,&#13;
        dim.x,&#13;
        dim.y&#13;
      );&#13;
      // if there is background color no other shadows&#13;
      // should be casted&#13;
      this._removeShadow(ctx);&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     */&#13;
    _setOpacity: function(ctx) {&#13;
      if (this.group &amp;&amp; !this.group._transformDone) {&#13;
        ctx.globalAlpha = this.getObjectOpacity();&#13;
      }&#13;
      else {&#13;
        ctx.globalAlpha *= this.opacity;&#13;
      }&#13;
    },&#13;
&#13;
    _setStrokeStyles: function(ctx, decl) {&#13;
      if (decl.stroke) {&#13;
        ctx.lineWidth = decl.strokeWidth;&#13;
        ctx.lineCap = decl.strokeLineCap;&#13;
        ctx.lineJoin = decl.strokeLineJoin;&#13;
        ctx.miterLimit = decl.strokeMiterLimit;&#13;
        ctx.strokeStyle = decl.stroke.toLive&#13;
          ? decl.stroke.toLive(ctx, this)&#13;
          : decl.stroke;&#13;
      }&#13;
    },&#13;
&#13;
    _setFillStyles: function(ctx, decl) {&#13;
      if (decl.fill) {&#13;
        ctx.fillStyle = decl.fill.toLive&#13;
          ? decl.fill.toLive(ctx, this)&#13;
          : decl.fill;&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * Sets line dash&#13;
     * @param {CanvasRenderingContext2D} ctx Context to set the dash line on&#13;
     * @param {Array} dashArray array representing dashes&#13;
     * @param {Function} alternative function to call if browaser does not support lineDash&#13;
     */&#13;
    _setLineDash: function(ctx, dashArray, alternative) {&#13;
      if (!dashArray) {&#13;
        return;&#13;
      }&#13;
      // Spec requires the concatenation of two copies the dash list when the number of elements is odd&#13;
      if (1 &amp; dashArray.length) {&#13;
        dashArray.push.apply(dashArray, dashArray);&#13;
      }&#13;
      if (supportsLineDash) {&#13;
        ctx.setLineDash(dashArray);&#13;
      }&#13;
      else {&#13;
        alternative &amp;&amp; alternative(ctx);&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Renders controls and borders for the object&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     * @param {Object} [styleOverride] properties to override the object style&#13;
     */&#13;
    _renderControls: function(ctx, styleOverride) {&#13;
      var vpt = this.getViewportTransform(),&#13;
          matrix = this.calcTransformMatrix(),&#13;
          options, drawBorders, drawControls;&#13;
      styleOverride = styleOverride || { };&#13;
      drawBorders = typeof styleOverride.hasBorders !== 'undefined' ? styleOverride.hasBorders : this.hasBorders;&#13;
      drawControls = typeof styleOverride.hasControls !== 'undefined' ? styleOverride.hasControls : this.hasControls;&#13;
      matrix = fabric.util.multiplyTransformMatrices(vpt, matrix);&#13;
      options = fabric.util.qrDecompose(matrix);&#13;
      ctx.save();&#13;
      ctx.translate(options.translateX, options.translateY);&#13;
      ctx.lineWidth = 1 * this.borderScaleFactor;&#13;
      if (!this.group) {&#13;
        ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;&#13;
      }&#13;
      if (styleOverride.forActiveSelection) {&#13;
        ctx.rotate(degreesToRadians(options.angle));&#13;
        drawBorders &amp;&amp; this.drawBordersInGroup(ctx, options, styleOverride);&#13;
      }&#13;
      else {&#13;
        ctx.rotate(degreesToRadians(this.angle));&#13;
        drawBorders &amp;&amp; this.drawBorders(ctx, styleOverride);&#13;
      }&#13;
      drawControls &amp;&amp; this.drawControls(ctx, styleOverride);&#13;
      ctx.restore();&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     */&#13;
    _setShadow: function(ctx) {&#13;
      if (!this.shadow) {&#13;
        return;&#13;
      }&#13;
&#13;
      var multX = (this.canvas &amp;&amp; this.canvas.viewportTransform[0]) || 1,&#13;
          multY = (this.canvas &amp;&amp; this.canvas.viewportTransform[3]) || 1,&#13;
          scaling = this.getObjectScaling();&#13;
      if (this.canvas &amp;&amp; this.canvas._isRetinaScaling()) {&#13;
        multX *= fabric.devicePixelRatio;&#13;
        multY *= fabric.devicePixelRatio;&#13;
      }&#13;
      ctx.shadowColor = this.shadow.color;&#13;
      ctx.shadowBlur = this.shadow.blur * fabric.browserShadowBlurConstant *&#13;
        (multX + multY) * (scaling.scaleX + scaling.scaleY) / 4;&#13;
      ctx.shadowOffsetX = this.shadow.offsetX * multX * scaling.scaleX;&#13;
      ctx.shadowOffsetY = this.shadow.offsetY * multY * scaling.scaleY;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     */&#13;
    _removeShadow: function(ctx) {&#13;
      if (!this.shadow) {&#13;
        return;&#13;
      }&#13;
&#13;
      ctx.shadowColor = '';&#13;
      ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     * @param {Object} filler fabric.Pattern or fabric.Gradient&#13;
     */&#13;
    _applyPatternGradientTransform: function(ctx, filler) {&#13;
      if (!filler || !filler.toLive) {&#13;
        return { offsetX: 0, offsetY: 0 };&#13;
      }&#13;
      var t = filler.gradientTransform || filler.patternTransform;&#13;
      var offsetX = -this.width / 2 + filler.offsetX || 0,&#13;
          offsetY = -this.height / 2 + filler.offsetY || 0;&#13;
      ctx.translate(offsetX, offsetY);&#13;
      if (t) {&#13;
        ctx.transform(t[0], t[1], t[2], t[3], t[4], t[5]);&#13;
      }&#13;
      return { offsetX: offsetX, offsetY: offsetY };&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     */&#13;
    _renderPaintInOrder: function(ctx) {&#13;
      if (this.paintFirst === 'stroke') {&#13;
        this._renderStroke(ctx);&#13;
        this._renderFill(ctx);&#13;
      }&#13;
      else {&#13;
        this._renderFill(ctx);&#13;
        this._renderStroke(ctx);&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     */&#13;
    _renderFill: function(ctx) {&#13;
      if (!this.fill) {&#13;
        return;&#13;
      }&#13;
&#13;
      ctx.save();&#13;
      this._applyPatternGradientTransform(ctx, this.fill);&#13;
      if (this.fillRule === 'evenodd') {&#13;
        ctx.fill('evenodd');&#13;
      }&#13;
      else {&#13;
        ctx.fill();&#13;
      }&#13;
      ctx.restore();&#13;
    },&#13;
&#13;
    _renderStroke: function(ctx) {&#13;
      if (!this.stroke || this.strokeWidth === 0) {&#13;
        return;&#13;
      }&#13;
&#13;
      if (this.shadow &amp;&amp; !this.shadow.affectStroke) {&#13;
        this._removeShadow(ctx);&#13;
      }&#13;
&#13;
      ctx.save();&#13;
      this._setLineDash(ctx, this.strokeDashArray, this._renderDashedStroke);&#13;
      this._applyPatternGradientTransform(ctx, this.stroke);&#13;
      ctx.stroke();&#13;
      ctx.restore();&#13;
    },&#13;
&#13;
    /**&#13;
     * This function is an helper for svg import. it returns the center of the object in the svg&#13;
     * untransformed coordinates&#13;
     * @private&#13;
     * @return {Object} center point from element coordinates&#13;
     */&#13;
    _findCenterFromElement: function() {&#13;
      return { x: this.left + this.width / 2, y: this.top + this.height / 2 };&#13;
    },&#13;
&#13;
    /**&#13;
     * This function is an helper for svg import. it decoompose the transformMatrix&#13;
     * and assign properties to object.&#13;
     * untransformed coordinates&#13;
     * @private&#13;
     * @chainable&#13;
     */&#13;
    _assignTransformMatrixProps: function() {&#13;
      if (this.transformMatrix) {&#13;
        var options = fabric.util.qrDecompose(this.transformMatrix);&#13;
        this.flipX = false;&#13;
        this.flipY = false;&#13;
        this.set('scaleX', options.scaleX);&#13;
        this.set('scaleY', options.scaleY);&#13;
        this.angle = options.angle;&#13;
        this.skewX = options.skewX;&#13;
        this.skewY = 0;&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * This function is an helper for svg import. it removes the transform matrix&#13;
     * and set to object properties that fabricjs can handle&#13;
     * @private&#13;
     * @param {Object} preserveAspectRatioOptions&#13;
     * @return {thisArg}&#13;
     */&#13;
    _removeTransformMatrix: function(preserveAspectRatioOptions) {&#13;
      var center = this._findCenterFromElement();&#13;
      if (this.transformMatrix) {&#13;
        this._assignTransformMatrixProps();&#13;
        center = fabric.util.transformPoint(center, this.transformMatrix);&#13;
      }&#13;
      this.transformMatrix = null;&#13;
      if (preserveAspectRatioOptions) {&#13;
        this.scaleX *= preserveAspectRatioOptions.scaleX;&#13;
        this.scaleY *= preserveAspectRatioOptions.scaleY;&#13;
        this.cropX = preserveAspectRatioOptions.cropX;&#13;
        this.cropY = preserveAspectRatioOptions.cropY;&#13;
        center.x += preserveAspectRatioOptions.offsetLeft;&#13;
        center.y += preserveAspectRatioOptions.offsetTop;&#13;
        this.width = preserveAspectRatioOptions.width;&#13;
        this.height = preserveAspectRatioOptions.height;&#13;
      }&#13;
      this.setPositionByOrigin(center, 'center', 'center');&#13;
    },&#13;
&#13;
    /**&#13;
     * Clones an instance, using a callback method will work for every object.&#13;
     * @param {Function} callback Callback is invoked with a clone as a first argument&#13;
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output&#13;
     */&#13;
    clone: function(callback, propertiesToInclude) {&#13;
      var objectForm = this.toObject(propertiesToInclude);&#13;
      if (this.constructor.fromObject) {&#13;
        this.constructor.fromObject(objectForm, callback);&#13;
      }&#13;
      else {&#13;
        fabric.Object._fromObject('Object', objectForm, callback);&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Creates an instance of fabric.Image out of an object&#13;
     * @param {Function} callback callback, invoked with an instance as a first argument&#13;
     * @param {Object} [options] for clone as image, passed to toDataURL&#13;
     * @param {Boolean} [options.enableRetinaScaling] enable retina scaling for the cloned image&#13;
     * @return {fabric.Object} thisArg&#13;
     */&#13;
    cloneAsImage: function(callback, options) {&#13;
      var dataUrl = this.toDataURL(options);&#13;
      fabric.util.loadImage(dataUrl, function(img) {&#13;
        if (callback) {&#13;
          callback(new fabric.Image(img));&#13;
        }&#13;
      });&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Converts an object into a data-url-like string&#13;
     * @param {Object} options Options object&#13;
     * @param {String} [options.format=png] The format of the output image. Either "jpeg" or "png"&#13;
     * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.&#13;
     * @param {Number} [options.multiplier=1] Multiplier to scale by&#13;
     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14&#13;
     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14&#13;
     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14&#13;
     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14&#13;
     * @param {Boolean} [options.enableRetina] Enable retina scaling for clone image. Introduce in 1.6.4&#13;
     * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format&#13;
     */&#13;
    toDataURL: function(options) {&#13;
      options || (options = { });&#13;
&#13;
      var el = fabric.util.createCanvasElement(),&#13;
          boundingRect = this.getBoundingRect();&#13;
&#13;
      el.width = boundingRect.width;&#13;
      el.height = boundingRect.height;&#13;
      fabric.util.wrapElement(el, 'div');&#13;
      var canvas = new fabric.StaticCanvas(el, { enableRetinaScaling: options.enableRetinaScaling });&#13;
      // to avoid common confusion https://github.com/kangax/fabric.js/issues/806&#13;
      if (options.format === 'jpg') {&#13;
        options.format = 'jpeg';&#13;
      }&#13;
&#13;
      if (options.format === 'jpeg') {&#13;
        canvas.backgroundColor = '#fff';&#13;
      }&#13;
&#13;
      var origParams = {&#13;
        left: this.left,&#13;
        top: this.top&#13;
      };&#13;
&#13;
      this.setPositionByOrigin(new fabric.Point(canvas.width / 2, canvas.height / 2), 'center', 'center');&#13;
&#13;
      var originalCanvas = this.canvas;&#13;
      canvas.add(this);&#13;
      var data = canvas.toDataURL(options);&#13;
&#13;
      this.set(origParams).setCoords();&#13;
      this.canvas = originalCanvas;&#13;
&#13;
      canvas.dispose();&#13;
      canvas = null;&#13;
&#13;
      return data;&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns true if specified type is identical to the type of an instance&#13;
     * @param {String} type Type to check against&#13;
     * @return {Boolean}&#13;
     */&#13;
    isType: function(type) {&#13;
      return this.type === type;&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns complexity of an instance&#13;
     * @return {Number} complexity of this instance (is 1 unless subclassed)&#13;
     */&#13;
    complexity: function() {&#13;
      return 1;&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns a JSON representation of an instance&#13;
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output&#13;
     * @return {Object} JSON&#13;
     */&#13;
    toJSON: function(propertiesToInclude) {&#13;
      // delegate, not alias&#13;
      return this.toObject(propertiesToInclude);&#13;
    },&#13;
&#13;
    /**&#13;
     * Sets gradient (fill or stroke) of an object&#13;
     * &lt;b&gt;Backwards incompatibility note:&lt;/b&gt; This method was named "setGradientFill" until v1.1.0&#13;
     * @param {String} property Property name 'stroke' or 'fill'&#13;
     * @param {Object} [options] Options object&#13;
     * @param {String} [options.type] Type of gradient 'radial' or 'linear'&#13;
     * @param {Number} [options.x1=0] x-coordinate of start point&#13;
     * @param {Number} [options.y1=0] y-coordinate of start point&#13;
     * @param {Number} [options.x2=0] x-coordinate of end point&#13;
     * @param {Number} [options.y2=0] y-coordinate of end point&#13;
     * @param {Number} [options.r1=0] Radius of start point (only for radial gradients)&#13;
     * @param {Number} [options.r2=0] Radius of end point (only for radial gradients)&#13;
     * @param {Object} [options.colorStops] Color stops object eg. {0: 'ff0000', 1: '000000'}&#13;
     * @param {Object} [options.gradientTransform] transforMatrix for gradient&#13;
     * @return {fabric.Object} thisArg&#13;
     * @chainable&#13;
     * @see {@link http://jsfiddle.net/fabricjs/58y8b/|jsFiddle demo}&#13;
     * @example &lt;caption&gt;Set linear gradient&lt;/caption&gt;&#13;
     * object.setGradient('fill', {&#13;
     *   type: 'linear',&#13;
     *   x1: -object.width / 2,&#13;
     *   y1: 0,&#13;
     *   x2: object.width / 2,&#13;
     *   y2: 0,&#13;
     *   colorStops: {&#13;
     *     0: 'red',&#13;
     *     0.5: '#005555',&#13;
     *     1: 'rgba(0,0,255,0.5)'&#13;
     *   }&#13;
     * });&#13;
     * canvas.renderAll();&#13;
     * @example &lt;caption&gt;Set radial gradient&lt;/caption&gt;&#13;
     * object.setGradient('fill', {&#13;
     *   type: 'radial',&#13;
     *   x1: 0,&#13;
     *   y1: 0,&#13;
     *   x2: 0,&#13;
     *   y2: 0,&#13;
     *   r1: object.width / 2,&#13;
     *   r2: 10,&#13;
     *   colorStops: {&#13;
     *     0: 'red',&#13;
     *     0.5: '#005555',&#13;
     *     1: 'rgba(0,0,255,0.5)'&#13;
     *   }&#13;
     * });&#13;
     * canvas.renderAll();&#13;
     */&#13;
    setGradient: function(property, options) {&#13;
      options || (options = { });&#13;
&#13;
      var gradient = { colorStops: [] };&#13;
&#13;
      gradient.type = options.type || (options.r1 || options.r2 ? 'radial' : 'linear');&#13;
      gradient.coords = {&#13;
        x1: options.x1,&#13;
        y1: options.y1,&#13;
        x2: options.x2,&#13;
        y2: options.y2&#13;
      };&#13;
&#13;
      if (options.r1 || options.r2) {&#13;
        gradient.coords.r1 = options.r1;&#13;
        gradient.coords.r2 = options.r2;&#13;
      }&#13;
&#13;
      gradient.gradientTransform = options.gradientTransform;&#13;
      fabric.Gradient.prototype.addColorStop.call(gradient, options.colorStops);&#13;
&#13;
      return this.set(property, fabric.Gradient.forObject(this, gradient));&#13;
    },&#13;
&#13;
    /**&#13;
     * Sets pattern fill of an object&#13;
     * @param {Object} options Options object&#13;
     * @param {(String|HTMLImageElement)} options.source Pattern source&#13;
     * @param {String} [options.repeat=repeat] Repeat property of a pattern (one of repeat, repeat-x, repeat-y or no-repeat)&#13;
     * @param {Number} [options.offsetX=0] Pattern horizontal offset from object's left/top corner&#13;
     * @param {Number} [options.offsetY=0] Pattern vertical offset from object's left/top corner&#13;
     * @return {fabric.Object} thisArg&#13;
     * @chainable&#13;
     * @see {@link http://jsfiddle.net/fabricjs/QT3pa/|jsFiddle demo}&#13;
     * @example &lt;caption&gt;Set pattern&lt;/caption&gt;&#13;
     * fabric.util.loadImage('http://fabricjs.com/assets/escheresque_ste.png', function(img) {&#13;
     *   object.setPatternFill({&#13;
     *     source: img,&#13;
     *     repeat: 'repeat'&#13;
     *   });&#13;
     *   canvas.renderAll();&#13;
     * });&#13;
     */&#13;
    setPatternFill: function(options) {&#13;
      return this.set('fill', new fabric.Pattern(options));&#13;
    },&#13;
&#13;
    /**&#13;
     * Sets {@link fabric.Object#shadow|shadow} of an object&#13;
     * @param {Object|String} [options] Options object or string (e.g. "2px 2px 10px rgba(0,0,0,0.2)")&#13;
     * @param {String} [options.color=rgb(0,0,0)] Shadow color&#13;
     * @param {Number} [options.blur=0] Shadow blur&#13;
     * @param {Number} [options.offsetX=0] Shadow horizontal offset&#13;
     * @param {Number} [options.offsetY=0] Shadow vertical offset&#13;
     * @return {fabric.Object} thisArg&#13;
     * @chainable&#13;
     * @see {@link http://jsfiddle.net/fabricjs/7gvJG/|jsFiddle demo}&#13;
     * @example &lt;caption&gt;Set shadow with string notation&lt;/caption&gt;&#13;
     * object.setShadow('2px 2px 10px rgba(0,0,0,0.2)');&#13;
     * canvas.renderAll();&#13;
     * @example &lt;caption&gt;Set shadow with object notation&lt;/caption&gt;&#13;
     * object.setShadow({&#13;
     *   color: 'red',&#13;
     *   blur: 10,&#13;
     *   offsetX: 20,&#13;
     *   offsetY: 20&#13;
     * });&#13;
     * canvas.renderAll();&#13;
     */&#13;
    setShadow: function(options) {&#13;
      return this.set('shadow', options ? new fabric.Shadow(options) : null);&#13;
    },&#13;
&#13;
    /**&#13;
     * Sets "color" of an instance (alias of `set('fill', &amp;hellip;)`)&#13;
     * @param {String} color Color value&#13;
     * @return {fabric.Object} thisArg&#13;
     * @chainable&#13;
     */&#13;
    setColor: function(color) {&#13;
      this.set('fill', color);&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Sets "angle" of an instance with centered rotation&#13;
     * @param {Number} angle Angle value (in degrees)&#13;
     * @return {fabric.Object} thisArg&#13;
     * @chainable&#13;
     */&#13;
    rotate: function(angle) {&#13;
      var shouldCenterOrigin = (this.originX !== 'center' || this.originY !== 'center') &amp;&amp; this.centeredRotation;&#13;
&#13;
      if (shouldCenterOrigin) {&#13;
        this._setOriginToCenter();&#13;
      }&#13;
&#13;
      this.set('angle', angle);&#13;
&#13;
      if (shouldCenterOrigin) {&#13;
        this._resetOrigin();&#13;
      }&#13;
&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Centers object horizontally on canvas to which it was added last.&#13;
     * You might need to call `setCoords` on an object after centering, to update controls area.&#13;
     * @return {fabric.Object} thisArg&#13;
     * @chainable&#13;
     */&#13;
    centerH: function () {&#13;
      this.canvas &amp;&amp; this.canvas.centerObjectH(this);&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Centers object horizontally on current viewport of canvas to which it was added last.&#13;
     * You might need to call `setCoords` on an object after centering, to update controls area.&#13;
     * @return {fabric.Object} thisArg&#13;
     * @chainable&#13;
     */&#13;
    viewportCenterH: function () {&#13;
      this.canvas &amp;&amp; this.canvas.viewportCenterObjectH(this);&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Centers object vertically on canvas to which it was added last.&#13;
     * You might need to call `setCoords` on an object after centering, to update controls area.&#13;
     * @return {fabric.Object} thisArg&#13;
     * @chainable&#13;
     */&#13;
    centerV: function () {&#13;
      this.canvas &amp;&amp; this.canvas.centerObjectV(this);&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Centers object vertically on current viewport of canvas to which it was added last.&#13;
     * You might need to call `setCoords` on an object after centering, to update controls area.&#13;
     * @return {fabric.Object} thisArg&#13;
     * @chainable&#13;
     */&#13;
    viewportCenterV: function () {&#13;
      this.canvas &amp;&amp; this.canvas.viewportCenterObjectV(this);&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Centers object vertically and horizontally on canvas to which is was added last&#13;
     * You might need to call `setCoords` on an object after centering, to update controls area.&#13;
     * @return {fabric.Object} thisArg&#13;
     * @chainable&#13;
     */&#13;
    center: function () {&#13;
      this.canvas &amp;&amp; this.canvas.centerObject(this);&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Centers object on current viewport of canvas to which it was added last.&#13;
     * You might need to call `setCoords` on an object after centering, to update controls area.&#13;
     * @return {fabric.Object} thisArg&#13;
     * @chainable&#13;
     */&#13;
    viewportCenter: function () {&#13;
      this.canvas &amp;&amp; this.canvas.viewportCenterObject(this);&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns coordinates of a pointer relative to an object&#13;
     * @param {Event} e Event to operate upon&#13;
     * @param {Object} [pointer] Pointer to operate upon (instead of event)&#13;
     * @return {Object} Coordinates of a pointer (x, y)&#13;
     */&#13;
    getLocalPointer: function(e, pointer) {&#13;
      pointer = pointer || this.canvas.getPointer(e);&#13;
      var pClicked = new fabric.Point(pointer.x, pointer.y),&#13;
          objectLeftTop = this._getLeftTopCoords();&#13;
      if (this.angle) {&#13;
        pClicked = fabric.util.rotatePoint(&#13;
          pClicked, objectLeftTop, degreesToRadians(-this.angle));&#13;
      }&#13;
      return {&#13;
        x: pClicked.x - objectLeftTop.x,&#13;
        y: pClicked.y - objectLeftTop.y&#13;
      };&#13;
    },&#13;
&#13;
    /**&#13;
     * Sets canvas globalCompositeOperation for specific object&#13;
     * custom composition operation for the particular object can be specifed using globalCompositeOperation property&#13;
     * @param {CanvasRenderingContext2D} ctx Rendering canvas context&#13;
     */&#13;
    _setupCompositeOperation: function (ctx) {&#13;
      if (this.globalCompositeOperation) {&#13;
        ctx.globalCompositeOperation = this.globalCompositeOperation;&#13;
      }&#13;
    }&#13;
  });&#13;
&#13;
  fabric.util.createAccessors &amp;&amp; fabric.util.createAccessors(fabric.Object);&#13;
&#13;
  extend(fabric.Object.prototype, fabric.Observable);&#13;
&#13;
  /**&#13;
   * Defines the number of fraction digits to use when serializing object values.&#13;
   * You can use it to increase/decrease precision of such values like left, top, scaleX, scaleY, etc.&#13;
   * @static&#13;
   * @memberOf fabric.Object&#13;
   * @constant&#13;
   * @type Number&#13;
   */&#13;
  fabric.Object.NUM_FRACTION_DIGITS = 2;&#13;
&#13;
  fabric.Object._fromObject = function(className, object, callback, extraParam) {&#13;
    var klass = fabric[className];&#13;
    object = clone(object, true);&#13;
    fabric.util.enlivenPatterns([object.fill, object.stroke], function(patterns) {&#13;
      if (typeof patterns[0] !== 'undefined') {&#13;
        object.fill = patterns[0];&#13;
      }&#13;
      if (typeof patterns[1] !== 'undefined') {&#13;
        object.stroke = patterns[1];&#13;
      }&#13;
      var instance = extraParam ? new klass(object[extraParam], object) : new klass(object);&#13;
      callback &amp;&amp; callback(instance);&#13;
    });&#13;
  };&#13;
&#13;
  /**&#13;
   * Unique id used internally when creating SVG elements&#13;
   * @static&#13;
   * @memberOf fabric.Object&#13;
   * @type Number&#13;
   */&#13;
  fabric.Object.__uid = 0;&#13;
&#13;
})(typeof exports !== 'undefined' ? exports : this);&#13;
&#13;
&#13;
(function() {&#13;
&#13;
  var degreesToRadians = fabric.util.degreesToRadians,&#13;
      originXOffset = {&#13;
        left: -0.5,&#13;
        center: 0,&#13;
        right: 0.5&#13;
      },&#13;
      originYOffset = {&#13;
        top: -0.5,&#13;
        center: 0,&#13;
        bottom: 0.5&#13;
      };&#13;
&#13;
  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {&#13;
&#13;
    /**&#13;
     * Translates the coordinates from a set of origin to another (based on the object's dimensions)&#13;
     * @param {fabric.Point} point The point which corresponds to the originX and originY params&#13;
     * @param {String} fromOriginX Horizontal origin: 'left', 'center' or 'right'&#13;
     * @param {String} fromOriginY Vertical origin: 'top', 'center' or 'bottom'&#13;
     * @param {String} toOriginX Horizontal origin: 'left', 'center' or 'right'&#13;
     * @param {String} toOriginY Vertical origin: 'top', 'center' or 'bottom'&#13;
     * @return {fabric.Point}&#13;
     */&#13;
    translateToGivenOrigin: function(point, fromOriginX, fromOriginY, toOriginX, toOriginY) {&#13;
      var x = point.x,&#13;
          y = point.y,&#13;
          offsetX, offsetY, dim;&#13;
&#13;
      if (typeof fromOriginX === 'string') {&#13;
        fromOriginX = originXOffset[fromOriginX];&#13;
      }&#13;
      else {&#13;
        fromOriginX -= 0.5;&#13;
      }&#13;
&#13;
      if (typeof toOriginX === 'string') {&#13;
        toOriginX = originXOffset[toOriginX];&#13;
      }&#13;
      else {&#13;
        toOriginX -= 0.5;&#13;
      }&#13;
&#13;
      offsetX = toOriginX - fromOriginX;&#13;
&#13;
      if (typeof fromOriginY === 'string') {&#13;
        fromOriginY = originYOffset[fromOriginY];&#13;
      }&#13;
      else {&#13;
        fromOriginY -= 0.5;&#13;
      }&#13;
&#13;
      if (typeof toOriginY === 'string') {&#13;
        toOriginY = originYOffset[toOriginY];&#13;
      }&#13;
      else {&#13;
        toOriginY -= 0.5;&#13;
      }&#13;
&#13;
      offsetY = toOriginY - fromOriginY;&#13;
&#13;
      if (offsetX || offsetY) {&#13;
        dim = this._getTransformedDimensions();&#13;
        x = point.x + offsetX * dim.x;&#13;
        y = point.y + offsetY * dim.y;&#13;
      }&#13;
&#13;
      return new fabric.Point(x, y);&#13;
    },&#13;
&#13;
    /**&#13;
     * Translates the coordinates from origin to center coordinates (based on the object's dimensions)&#13;
     * @param {fabric.Point} point The point which corresponds to the originX and originY params&#13;
     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'&#13;
     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'&#13;
     * @return {fabric.Point}&#13;
     */&#13;
    translateToCenterPoint: function(point, originX, originY) {&#13;
      var p = this.translateToGivenOrigin(point, originX, originY, 'center', 'center');&#13;
      if (this.angle) {&#13;
        return fabric.util.rotatePoint(p, point, degreesToRadians(this.angle));&#13;
      }&#13;
      return p;&#13;
    },&#13;
&#13;
    /**&#13;
     * Translates the coordinates from center to origin coordinates (based on the object's dimensions)&#13;
     * @param {fabric.Point} center The point which corresponds to center of the object&#13;
     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'&#13;
     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'&#13;
     * @return {fabric.Point}&#13;
     */&#13;
    translateToOriginPoint: function(center, originX, originY) {&#13;
      var p = this.translateToGivenOrigin(center, 'center', 'center', originX, originY);&#13;
      if (this.angle) {&#13;
        return fabric.util.rotatePoint(p, center, degreesToRadians(this.angle));&#13;
      }&#13;
      return p;&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns the real center coordinates of the object&#13;
     * @return {fabric.Point}&#13;
     */&#13;
    getCenterPoint: function() {&#13;
      var leftTop = new fabric.Point(this.left, this.top);&#13;
      return this.translateToCenterPoint(leftTop, this.originX, this.originY);&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns the coordinates of the object based on center coordinates&#13;
     * @param {fabric.Point} point The point which corresponds to the originX and originY params&#13;
     * @return {fabric.Point}&#13;
     */&#13;
    // getOriginPoint: function(center) {&#13;
    //   return this.translateToOriginPoint(center, this.originX, this.originY);&#13;
    // },&#13;
&#13;
    /**&#13;
     * Returns the coordinates of the object as if it has a different origin&#13;
     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'&#13;
     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'&#13;
     * @return {fabric.Point}&#13;
     */&#13;
    getPointByOrigin: function(originX, originY) {&#13;
      var center = this.getCenterPoint();&#13;
      return this.translateToOriginPoint(center, originX, originY);&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns the point in local coordinates&#13;
     * @param {fabric.Point} point The point relative to the global coordinate system&#13;
     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'&#13;
     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'&#13;
     * @return {fabric.Point}&#13;
     */&#13;
    toLocalPoint: function(point, originX, originY) {&#13;
      var center = this.getCenterPoint(),&#13;
          p, p2;&#13;
&#13;
      if (typeof originX !== 'undefined' &amp;&amp; typeof originY !== 'undefined' ) {&#13;
        p = this.translateToGivenOrigin(center, 'center', 'center', originX, originY);&#13;
      }&#13;
      else {&#13;
        p = new fabric.Point(this.left, this.top);&#13;
      }&#13;
&#13;
      p2 = new fabric.Point(point.x, point.y);&#13;
      if (this.angle) {&#13;
        p2 = fabric.util.rotatePoint(p2, center, -degreesToRadians(this.angle));&#13;
      }&#13;
      return p2.subtractEquals(p);&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns the point in global coordinates&#13;
     * @param {fabric.Point} The point relative to the local coordinate system&#13;
     * @return {fabric.Point}&#13;
     */&#13;
    // toGlobalPoint: function(point) {&#13;
    //   return fabric.util.rotatePoint(point, this.getCenterPoint(), degreesToRadians(this.angle)).addEquals(new fabric.Point(this.left, this.top));&#13;
    // },&#13;
&#13;
    /**&#13;
     * Sets the position of the object taking into consideration the object's origin&#13;
     * @param {fabric.Point} pos The new position of the object&#13;
     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'&#13;
     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'&#13;
     * @return {void}&#13;
     */&#13;
    setPositionByOrigin: function(pos, originX, originY) {&#13;
      var center = this.translateToCenterPoint(pos, originX, originY),&#13;
          position = this.translateToOriginPoint(center, this.originX, this.originY);&#13;
      this.set('left', position.x);&#13;
      this.set('top', position.y);&#13;
    },&#13;
&#13;
    /**&#13;
     * @param {String} to One of 'left', 'center', 'right'&#13;
     */&#13;
    adjustPosition: function(to) {&#13;
      var angle = degreesToRadians(this.angle),&#13;
          hypotFull = this.getScaledWidth(),&#13;
          xFull = Math.cos(angle) * hypotFull,&#13;
          yFull = Math.sin(angle) * hypotFull,&#13;
          offsetFrom, offsetTo;&#13;
&#13;
      //TODO: this function does not consider mixed situation like top, center.&#13;
      if (typeof this.originX === 'string') {&#13;
        offsetFrom = originXOffset[this.originX];&#13;
      }&#13;
      else {&#13;
        offsetFrom = this.originX - 0.5;&#13;
      }&#13;
      if (typeof to === 'string') {&#13;
        offsetTo = originXOffset[to];&#13;
      }&#13;
      else {&#13;
        offsetTo = to - 0.5;&#13;
      }&#13;
      this.left += xFull * (offsetTo - offsetFrom);&#13;
      this.top += yFull * (offsetTo - offsetFrom);&#13;
      this.setCoords();&#13;
      this.originX = to;&#13;
    },&#13;
&#13;
    /**&#13;
     * Sets the origin/position of the object to it's center point&#13;
     * @private&#13;
     * @return {void}&#13;
     */&#13;
    _setOriginToCenter: function() {&#13;
      this._originalOriginX = this.originX;&#13;
      this._originalOriginY = this.originY;&#13;
&#13;
      var center = this.getCenterPoint();&#13;
&#13;
      this.originX = 'center';&#13;
      this.originY = 'center';&#13;
&#13;
      this.left = center.x;&#13;
      this.top = center.y;&#13;
    },&#13;
&#13;
    /**&#13;
     * Resets the origin/position of the object to it's original origin&#13;
     * @private&#13;
     * @return {void}&#13;
     */&#13;
    _resetOrigin: function() {&#13;
      var originPoint = this.translateToOriginPoint(&#13;
        this.getCenterPoint(),&#13;
        this._originalOriginX,&#13;
        this._originalOriginY);&#13;
&#13;
      this.originX = this._originalOriginX;&#13;
      this.originY = this._originalOriginY;&#13;
&#13;
      this.left = originPoint.x;&#13;
      this.top = originPoint.y;&#13;
&#13;
      this._originalOriginX = null;&#13;
      this._originalOriginY = null;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _getLeftTopCoords: function() {&#13;
      return this.translateToOriginPoint(this.getCenterPoint(), 'left', 'top');&#13;
    },&#13;
&#13;
    /**&#13;
    * Callback; invoked right before object is about to go from active to inactive&#13;
    */&#13;
    onDeselect: function() {&#13;
      /* NOOP */&#13;
    }&#13;
  });&#13;
&#13;
})();&#13;
&#13;
&#13;
(function() {&#13;
&#13;
  function getCoords(coords) {&#13;
    return [&#13;
      new fabric.Point(coords.tl.x, coords.tl.y),&#13;
      new fabric.Point(coords.tr.x, coords.tr.y),&#13;
      new fabric.Point(coords.br.x, coords.br.y),&#13;
      new fabric.Point(coords.bl.x, coords.bl.y)&#13;
    ];&#13;
  }&#13;
&#13;
  var degreesToRadians = fabric.util.degreesToRadians,&#13;
      multiplyMatrices = fabric.util.multiplyTransformMatrices;&#13;
&#13;
  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {&#13;
&#13;
    /**&#13;
     * Describe object's corner position in canvas element coordinates.&#13;
     * properties are tl,mt,tr,ml,mr,bl,mb,br,mtr for the main controls.&#13;
     * each property is an object with x, y and corner.&#13;
     * The `corner` property contains in a similar manner the 4 points of the&#13;
     * interactive area of the corner.&#13;
     * The coordinates depends from this properties: width, height, scaleX, scaleY&#13;
     * skewX, skewY, angle, strokeWidth, viewportTransform, top, left, padding.&#13;
     * The coordinates get updated with @method setCoords.&#13;
     * You can calculate them without updating with @method calcCoords;&#13;
     * @memberOf fabric.Object.prototype&#13;
     */&#13;
    oCoords: null,&#13;
&#13;
    /**&#13;
     * Describe object's corner position in canvas object absolute coordinates&#13;
     * properties are tl,tr,bl,br and describe the four main corner.&#13;
     * each property is an object with x, y, instance of Fabric.Point.&#13;
     * The coordinates depends from this properties: width, height, scaleX, scaleY&#13;
     * skewX, skewY, angle, strokeWidth, top, left.&#13;
     * Those coordinates are usefull to understand where an object is. They get updated&#13;
     * with oCoords but they do not need to be updated when zoom or panning change.&#13;
     * The coordinates get updated with @method setCoords.&#13;
     * You can calculate them without updating with @method calcCoords(true);&#13;
     * @memberOf fabric.Object.prototype&#13;
     */&#13;
    aCoords: null,&#13;
&#13;
    /**&#13;
     * storage for object transform matrix&#13;
     */&#13;
    ownMatrixCache: null,&#13;
&#13;
    /**&#13;
     * storage for object full transform matrix&#13;
     */&#13;
    matrixCache: null,&#13;
&#13;
    /**&#13;
     * return correct set of coordinates for intersection&#13;
     */&#13;
    getCoords: function(absolute, calculate) {&#13;
      if (!this.oCoords) {&#13;
        this.setCoords();&#13;
      }&#13;
      var coords = absolute ? this.aCoords : this.oCoords;&#13;
      return getCoords(calculate ? this.calcCoords(absolute) : coords);&#13;
    },&#13;
&#13;
    /**&#13;
     * Checks if object intersects with an area formed by 2 points&#13;
     * @param {Object} pointTL top-left point of area&#13;
     * @param {Object} pointBR bottom-right point of area&#13;
     * @param {Boolean} [absolute] use coordinates without viewportTransform&#13;
     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords&#13;
     * @return {Boolean} true if object intersects with an area formed by 2 points&#13;
     */&#13;
    intersectsWithRect: function(pointTL, pointBR, absolute, calculate) {&#13;
      var coords = this.getCoords(absolute, calculate),&#13;
          intersection = fabric.Intersection.intersectPolygonRectangle(&#13;
            coords,&#13;
            pointTL,&#13;
            pointBR&#13;
          );&#13;
      return intersection.status === 'Intersection';&#13;
    },&#13;
&#13;
    /**&#13;
     * Checks if object intersects with another object&#13;
     * @param {Object} other Object to test&#13;
     * @param {Boolean} [absolute] use coordinates without viewportTransform&#13;
     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords&#13;
     * @return {Boolean} true if object intersects with another object&#13;
     */&#13;
    intersectsWithObject: function(other, absolute, calculate) {&#13;
      var intersection = fabric.Intersection.intersectPolygonPolygon(&#13;
        this.getCoords(absolute, calculate),&#13;
        other.getCoords(absolute, calculate)&#13;
      );&#13;
&#13;
      return intersection.status === 'Intersection'&#13;
        || other.isContainedWithinObject(this, absolute, calculate)&#13;
        || this.isContainedWithinObject(other, absolute, calculate);&#13;
    },&#13;
&#13;
    /**&#13;
     * Checks if object is fully contained within area of another object&#13;
     * @param {Object} other Object to test&#13;
     * @param {Boolean} [absolute] use coordinates without viewportTransform&#13;
     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords&#13;
     * @return {Boolean} true if object is fully contained within area of another object&#13;
     */&#13;
    isContainedWithinObject: function(other, absolute, calculate) {&#13;
      var points = this.getCoords(absolute, calculate),&#13;
          i = 0, lines = other._getImageLines(&#13;
            calculate ? other.calcCoords(absolute) : absolute ? other.aCoords : other.oCoords&#13;
          );&#13;
      for (; i &lt; 4; i++) {&#13;
        if (!other.containsPoint(points[i], lines)) {&#13;
          return false;&#13;
        }&#13;
      }&#13;
      return true;&#13;
    },&#13;
&#13;
    /**&#13;
     * Checks if object is fully contained within area formed by 2 points&#13;
     * @param {Object} pointTL top-left point of area&#13;
     * @param {Object} pointBR bottom-right point of area&#13;
     * @param {Boolean} [absolute] use coordinates without viewportTransform&#13;
     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords&#13;
     * @return {Boolean} true if object is fully contained within area formed by 2 points&#13;
     */&#13;
    isContainedWithinRect: function(pointTL, pointBR, absolute, calculate) {&#13;
      var boundingRect = this.getBoundingRect(absolute, calculate);&#13;
&#13;
      return (&#13;
        boundingRect.left &gt;= pointTL.x &amp;&amp;&#13;
        boundingRect.left + boundingRect.width &lt;= pointBR.x &amp;&amp;&#13;
        boundingRect.top &gt;= pointTL.y &amp;&amp;&#13;
        boundingRect.top + boundingRect.height &lt;= pointBR.y&#13;
      );&#13;
    },&#13;
&#13;
    /**&#13;
     * Checks if point is inside the object&#13;
     * @param {fabric.Point} point Point to check against&#13;
     * @param {Object} [lines] object returned from @method _getImageLines&#13;
     * @param {Boolean} [absolute] use coordinates without viewportTransform&#13;
     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords&#13;
     * @return {Boolean} true if point is inside the object&#13;
     */&#13;
    containsPoint: function(point, lines, absolute, calculate) {&#13;
      var lines = lines || this._getImageLines(&#13;
            calculate ? this.calcCoords(absolute) : absolute ? this.aCoords : this.oCoords&#13;
          ),&#13;
          xPoints = this._findCrossPoints(point, lines);&#13;
&#13;
      // if xPoints is odd then point is inside the object&#13;
      return (xPoints !== 0 &amp;&amp; xPoints % 2 === 1);&#13;
    },&#13;
&#13;
    /**&#13;
     * Checks if object is contained within the canvas with current viewportTransform&#13;
     * the check is done stopping at first point that appear on screen&#13;
     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords&#13;
     * @return {Boolean} true if object is fully contained within canvas&#13;
     */&#13;
    isOnScreen: function(calculate) {&#13;
      if (!this.canvas) {&#13;
        return false;&#13;
      }&#13;
      var pointTL = this.canvas.vptCoords.tl, pointBR = this.canvas.vptCoords.br;&#13;
      var points = this.getCoords(true, calculate), point;&#13;
      for (var i = 0; i &lt; 4; i++) {&#13;
        point = points[i];&#13;
        if (point.x &lt;= pointBR.x &amp;&amp; point.x &gt;= pointTL.x &amp;&amp; point.y &lt;= pointBR.y &amp;&amp; point.y &gt;= pointTL.y) {&#13;
          return true;&#13;
        }&#13;
      }&#13;
      // no points on screen, check intersection with absolute coordinates&#13;
      if (this.intersectsWithRect(pointTL, pointBR, true)) {&#13;
        return true;&#13;
      }&#13;
      // worst case scenario the object is so big that contains the screen&#13;
      var centerPoint = { x: (pointTL.x + pointBR.x) / 2, y: (pointTL.y + pointBR.y) / 2 };&#13;
      if (this.containsPoint(centerPoint, null, true)) {&#13;
        return true;&#13;
      }&#13;
      return false;&#13;
    },&#13;
&#13;
    /**&#13;
     * Method that returns an object with the object edges in it, given the coordinates of the corners&#13;
     * @private&#13;
     * @param {Object} oCoords Coordinates of the object corners&#13;
     */&#13;
    _getImageLines: function(oCoords) {&#13;
      return {&#13;
        topline: {&#13;
          o: oCoords.tl,&#13;
          d: oCoords.tr&#13;
        },&#13;
        rightline: {&#13;
          o: oCoords.tr,&#13;
          d: oCoords.br&#13;
        },&#13;
        bottomline: {&#13;
          o: oCoords.br,&#13;
          d: oCoords.bl&#13;
        },&#13;
        leftline: {&#13;
          o: oCoords.bl,&#13;
          d: oCoords.tl&#13;
        }&#13;
      };&#13;
    },&#13;
&#13;
    /**&#13;
     * Helper method to determine how many cross points are between the 4 object edges&#13;
     * and the horizontal line determined by a point on canvas&#13;
     * @private&#13;
     * @param {fabric.Point} point Point to check&#13;
     * @param {Object} lines Coordinates of the object being evaluated&#13;
     */&#13;
    // remove yi, not used but left code here just in case.&#13;
    _findCrossPoints: function(point, lines) {&#13;
      var b1, b2, a1, a2, xi, // yi,&#13;
          xcount = 0,&#13;
          iLine;&#13;
&#13;
      for (var lineKey in lines) {&#13;
        iLine = lines[lineKey];&#13;
        // optimisation 1: line below point. no cross&#13;
        if ((iLine.o.y &lt; point.y) &amp;&amp; (iLine.d.y &lt; point.y)) {&#13;
          continue;&#13;
        }&#13;
        // optimisation 2: line above point. no cross&#13;
        if ((iLine.o.y &gt;= point.y) &amp;&amp; (iLine.d.y &gt;= point.y)) {&#13;
          continue;&#13;
        }&#13;
        // optimisation 3: vertical line case&#13;
        if ((iLine.o.x === iLine.d.x) &amp;&amp; (iLine.o.x &gt;= point.x)) {&#13;
          xi = iLine.o.x;&#13;
          // yi = point.y;&#13;
        }&#13;
        // calculate the intersection point&#13;
        else {&#13;
          b1 = 0;&#13;
          b2 = (iLine.d.y - iLine.o.y) / (iLine.d.x - iLine.o.x);&#13;
          a1 = point.y - b1 * point.x;&#13;
          a2 = iLine.o.y - b2 * iLine.o.x;&#13;
&#13;
          xi = -(a1 - a2) / (b1 - b2);&#13;
          // yi = a1 + b1 * xi;&#13;
        }&#13;
        // dont count xi &lt; point.x cases&#13;
        if (xi &gt;= point.x) {&#13;
          xcount += 1;&#13;
        }&#13;
        // optimisation 4: specific for square images&#13;
        if (xcount === 2) {&#13;
          break;&#13;
        }&#13;
      }&#13;
      return xcount;&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns coordinates of object's bounding rectangle (left, top, width, height)&#13;
     * the box is intented as aligned to axis of canvas.&#13;
     * @param {Boolean} [absolute] use coordinates without viewportTransform&#13;
     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords&#13;
     * @return {Object} Object with left, top, width, height properties&#13;
     */&#13;
    getBoundingRect: function(absolute, calculate) {&#13;
      var coords = this.getCoords(absolute, calculate);&#13;
      return fabric.util.makeBoundingBoxFromPoints(coords);&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns width of an object bounding box counting transformations&#13;
     * @return {Number} width value&#13;
     */&#13;
    getScaledWidth: function() {&#13;
      return this._getTransformedDimensions().x;&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns height of an object bounding box counting transformations&#13;
     * @return {Number} height value&#13;
     */&#13;
    getScaledHeight: function() {&#13;
      return this._getTransformedDimensions().y;&#13;
    },&#13;
&#13;
    /**&#13;
     * Makes sure the scale is valid and modifies it if necessary&#13;
     * @private&#13;
     * @param {Number} value&#13;
     * @return {Number}&#13;
     */&#13;
    _constrainScale: function(value) {&#13;
      if (Math.abs(value) &lt; this.minScaleLimit) {&#13;
        if (value &lt; 0) {&#13;
          return -this.minScaleLimit;&#13;
        }&#13;
        else {&#13;
          return this.minScaleLimit;&#13;
        }&#13;
      }&#13;
      else if (value === 0) {&#13;
        return 0.0001;&#13;
      }&#13;
      return value;&#13;
    },&#13;
&#13;
    /**&#13;
     * Scales an object (equally by x and y)&#13;
     * @param {Number} value Scale factor&#13;
     * @return {fabric.Object} thisArg&#13;
     * @chainable&#13;
     */&#13;
    scale: function(value) {&#13;
      this._set('scaleX', value);&#13;
      this._set('scaleY', value);&#13;
      return this.setCoords();&#13;
    },&#13;
&#13;
    /**&#13;
     * Scales an object to a given width, with respect to bounding box (scaling by x/y equally)&#13;
     * @param {Number} value New width value&#13;
     * @param {Boolean} absolute ignore viewport&#13;
     * @return {fabric.Object} thisArg&#13;
     * @chainable&#13;
     */&#13;
    scaleToWidth: function(value, absolute) {&#13;
      // adjust to bounding rect factor so that rotated shapes would fit as well&#13;
      var boundingRectFactor = this.getBoundingRect(absolute).width / this.getScaledWidth();&#13;
      return this.scale(value / this.width / boundingRectFactor);&#13;
    },&#13;
&#13;
    /**&#13;
     * Scales an object to a given height, with respect to bounding box (scaling by x/y equally)&#13;
     * @param {Number} value New height value&#13;
     * @param {Boolean} absolute ignore viewport&#13;
     * @return {fabric.Object} thisArg&#13;
     * @chainable&#13;
     */&#13;
    scaleToHeight: function(value, absolute) {&#13;
      // adjust to bounding rect factor so that rotated shapes would fit as well&#13;
      var boundingRectFactor = this.getBoundingRect(absolute).height / this.getScaledHeight();&#13;
      return this.scale(value / this.height / boundingRectFactor);&#13;
    },&#13;
&#13;
    /**&#13;
     * Calculate and returns the .coords of an object.&#13;
     * @return {Object} Object with tl, tr, br, bl ....&#13;
     * @chainable&#13;
     */&#13;
    calcCoords: function(absolute) {&#13;
      var theta = degreesToRadians(this.angle),&#13;
          vpt = this.getViewportTransform(),&#13;
          dim = absolute ? this._getTransformedDimensions() : this._calculateCurrentDimensions(),&#13;
          currentWidth = dim.x, currentHeight = dim.y,&#13;
          sinTh = theta ? Math.sin(theta) : 0,&#13;
          cosTh = theta ? Math.cos(theta) : 1,&#13;
          _angle = currentWidth &gt; 0 ? Math.atan(currentHeight / currentWidth) : 0,&#13;
          _hypotenuse = (currentWidth / Math.cos(_angle)) / 2,&#13;
          offsetX = Math.cos(_angle + theta) * _hypotenuse,&#13;
          offsetY = Math.sin(_angle + theta) * _hypotenuse,&#13;
          center = this.getCenterPoint(),&#13;
          // offset added for rotate and scale actions&#13;
          coords = absolute ? center : fabric.util.transformPoint(center, vpt),&#13;
          tl  = new fabric.Point(coords.x - offsetX, coords.y - offsetY),&#13;
          tr  = new fabric.Point(tl.x + (currentWidth * cosTh), tl.y + (currentWidth * sinTh)),&#13;
          bl  = new fabric.Point(tl.x - (currentHeight * sinTh), tl.y + (currentHeight * cosTh)),&#13;
          br  = new fabric.Point(coords.x + offsetX, coords.y + offsetY);&#13;
      if (!absolute) {&#13;
        var ml  = new fabric.Point((tl.x + bl.x) / 2, (tl.y + bl.y) / 2),&#13;
            mt  = new fabric.Point((tr.x + tl.x) / 2, (tr.y + tl.y) / 2),&#13;
            mr  = new fabric.Point((br.x + tr.x) / 2, (br.y + tr.y) / 2),&#13;
            mb  = new fabric.Point((br.x + bl.x) / 2, (br.y + bl.y) / 2),&#13;
            mtr = new fabric.Point(mt.x + sinTh * this.rotatingPointOffset, mt.y - cosTh * this.rotatingPointOffset);&#13;
      }&#13;
&#13;
      // debugging&#13;
&#13;
      /* setTimeout(function() {&#13;
         canvas.contextTop.fillStyle = 'green';&#13;
         canvas.contextTop.fillRect(mb.x, mb.y, 3, 3);&#13;
         canvas.contextTop.fillRect(bl.x, bl.y, 3, 3);&#13;
         canvas.contextTop.fillRect(br.x, br.y, 3, 3);&#13;
         canvas.contextTop.fillRect(tl.x, tl.y, 3, 3);&#13;
         canvas.contextTop.fillRect(tr.x, tr.y, 3, 3);&#13;
         canvas.contextTop.fillRect(ml.x, ml.y, 3, 3);&#13;
         canvas.contextTop.fillRect(mr.x, mr.y, 3, 3);&#13;
         canvas.contextTop.fillRect(mt.x, mt.y, 3, 3);&#13;
         canvas.contextTop.fillRect(mtr.x, mtr.y, 3, 3);&#13;
       }, 50); */&#13;
&#13;
      var coords = {&#13;
        // corners&#13;
        tl: tl, tr: tr, br: br, bl: bl,&#13;
      };&#13;
      if (!absolute) {&#13;
        // middle&#13;
        coords.ml = ml;&#13;
        coords.mt = mt;&#13;
        coords.mr = mr;&#13;
        coords.mb = mb;&#13;
        // rotating point&#13;
        coords.mtr = mtr;&#13;
      }&#13;
      return coords;&#13;
    },&#13;
&#13;
    /**&#13;
     * Sets corner position coordinates based on current angle, width and height&#13;
     * See https://github.com/kangax/fabric.js/wiki/When-to-call-setCoords&#13;
     * @param {Boolean} [ignoreZoom] set oCoords with or without the viewport transform.&#13;
     * @param {Boolean} [skipAbsolute] skip calculation of aCoords, usefull in setViewportTransform&#13;
     * @return {fabric.Object} thisArg&#13;
     * @chainable&#13;
     */&#13;
    setCoords: function(ignoreZoom, skipAbsolute) {&#13;
      this.oCoords = this.calcCoords(ignoreZoom);&#13;
      if (!skipAbsolute) {&#13;
        this.aCoords = this.calcCoords(true);&#13;
      }&#13;
&#13;
      // set coordinates of the draggable boxes in the corners used to scale/rotate the image&#13;
      ignoreZoom || (this._setCornerCoords &amp;&amp; this._setCornerCoords());&#13;
&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * calculate rotation matrix of an object&#13;
     * @return {Array} rotation matrix for the object&#13;
     */&#13;
    _calcRotateMatrix: function() {&#13;
      if (this.angle) {&#13;
        var theta = degreesToRadians(this.angle), cos = Math.cos(theta), sin = Math.sin(theta);&#13;
        // trying to keep rounding error small, ugly but it works.&#13;
        if (cos === 6.123233995736766e-17 || cos === -1.8369701987210297e-16) {&#13;
          cos = 0;&#13;
        }&#13;
        return [cos, sin, -sin, cos, 0, 0];&#13;
      }&#13;
      return fabric.iMatrix.concat();&#13;
    },&#13;
&#13;
    transformMatrixKey: function(skipGroup) {&#13;
      var sep = '_', prefix = '';&#13;
      if (!skipGroup &amp;&amp; this.group) {&#13;
        prefix = this.group.transformMatrixKey(skipGroup) + sep;&#13;
      };&#13;
      return prefix + this.top + sep + this.left + sep + this.scaleX + sep + this.scaleY +&#13;
        sep + this.skewX + sep + this.skewY + sep + this.angle +&#13;
        sep + this.width + sep + this.height + sep + this.strokeWidth + this.flipX + this.flipY;&#13;
    },&#13;
&#13;
    /**&#13;
     * calculate trasform Matrix that represent current transformation from&#13;
     * object properties.&#13;
     * @param {Boolean} [skipGroup] return transformMatrix for object and not go upward with parents&#13;
     * @return {Array} matrix Transform Matrix for the object&#13;
     */&#13;
    calcTransformMatrix: function(skipGroup) {&#13;
      if (skipGroup) {&#13;
        return this.calcOwnMatrix();&#13;
      }&#13;
      var key = this.transformMatrixKey(), cache = this.matrixCache || (this.matrixCache = {});&#13;
      if (cache.key === key) {&#13;
        return cache.value;&#13;
      }&#13;
      var matrix = this.calcOwnMatrix();&#13;
      if (this.group) {&#13;
        matrix = multiplyMatrices(this.group.calcTransformMatrix(), matrix);&#13;
      }&#13;
      cache.key = key;&#13;
      cache.value = matrix;&#13;
      return matrix;&#13;
    },&#13;
&#13;
    calcOwnMatrix: function() {&#13;
      var key = this.transformMatrixKey(true), cache = this.ownMatrixCache || (this.ownMatrixCache = {});&#13;
      if (cache.key === key) {&#13;
        return cache.value;&#13;
      }&#13;
      var center = this.getCenterPoint(),&#13;
          matrix = [1, 0, 0, 1, center.x, center.y],&#13;
          rotateMatrix,&#13;
          dimensionMatrix = this._calcDimensionsTransformMatrix(this.skewX, this.skewY, true);&#13;
      if (this.angle) {&#13;
        rotateMatrix = this._calcRotateMatrix();&#13;
        matrix = multiplyMatrices(matrix, rotateMatrix);&#13;
      }&#13;
      matrix = multiplyMatrices(matrix, dimensionMatrix);&#13;
      cache.key = key;&#13;
      cache.value = matrix;&#13;
      return matrix;&#13;
    },&#13;
&#13;
    _calcDimensionsTransformMatrix: function(skewX, skewY, flipping) {&#13;
      var skewMatrix,&#13;
          scaleX = this.scaleX * (flipping &amp;&amp; this.flipX ? -1 : 1),&#13;
          scaleY = this.scaleY * (flipping &amp;&amp; this.flipY ? -1 : 1),&#13;
          scaleMatrix = [scaleX, 0, 0, scaleY, 0, 0];&#13;
      if (skewX) {&#13;
        skewMatrix = [1, 0, Math.tan(degreesToRadians(skewX)), 1];&#13;
        scaleMatrix = multiplyMatrices(scaleMatrix, skewMatrix, true);&#13;
      }&#13;
      if (skewY) {&#13;
        skewMatrix = [1, Math.tan(degreesToRadians(skewY)), 0, 1];&#13;
        scaleMatrix = multiplyMatrices(scaleMatrix, skewMatrix, true);&#13;
      }&#13;
      return scaleMatrix;&#13;
    },&#13;
&#13;
&#13;
    /*&#13;
     * Calculate object dimensions from its properties&#13;
     * @private&#13;
     * @return {Object} .x width dimension&#13;
     * @return {Object} .y height dimension&#13;
     */&#13;
    _getNonTransformedDimensions: function() {&#13;
      var strokeWidth = this.strokeWidth,&#13;
          w = this.width + strokeWidth,&#13;
          h = this.height + strokeWidth;&#13;
      return { x: w, y: h };&#13;
    },&#13;
&#13;
    /*&#13;
     * Calculate object bounding boxdimensions from its properties scale, skew.&#13;
     * @private&#13;
     * @return {Object} .x width dimension&#13;
     * @return {Object} .y height dimension&#13;
     */&#13;
    _getTransformedDimensions: function(skewX, skewY) {&#13;
      if (typeof skewX === 'undefined') {&#13;
        skewX = this.skewX;&#13;
      }&#13;
      if (typeof skewY === 'undefined') {&#13;
        skewY = this.skewY;&#13;
      }&#13;
      var dimensions = this._getNonTransformedDimensions(),&#13;
          dimX = dimensions.x / 2, dimY = dimensions.y / 2,&#13;
          points = [&#13;
            {&#13;
              x: -dimX,&#13;
              y: -dimY&#13;
            },&#13;
            {&#13;
              x: dimX,&#13;
              y: -dimY&#13;
            },&#13;
            {&#13;
              x: -dimX,&#13;
              y: dimY&#13;
            },&#13;
            {&#13;
              x: dimX,&#13;
              y: dimY&#13;
            }],&#13;
          i, transformMatrix = this._calcDimensionsTransformMatrix(skewX, skewY, false),&#13;
          bbox;&#13;
      for (i = 0; i &lt; points.length; i++) {&#13;
        points[i] = fabric.util.transformPoint(points[i], transformMatrix);&#13;
      }&#13;
      bbox = fabric.util.makeBoundingBoxFromPoints(points);&#13;
      return { x: bbox.width, y: bbox.height };&#13;
    },&#13;
&#13;
    /*&#13;
     * Calculate object dimensions for controls. include padding and canvas zoom&#13;
     * private&#13;
     */&#13;
    _calculateCurrentDimensions: function()  {&#13;
      var vpt = this.getViewportTransform(),&#13;
          dim = this._getTransformedDimensions(),&#13;
          p = fabric.util.transformPoint(dim, vpt, true);&#13;
&#13;
      return p.scalarAdd(2 * this.padding);&#13;
    },&#13;
  });&#13;
})();&#13;
&#13;
&#13;
fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {&#13;
&#13;
  /**&#13;
   * Moves an object to the bottom of the stack of drawn objects&#13;
   * @return {fabric.Object} thisArg&#13;
   * @chainable&#13;
   */&#13;
  sendToBack: function() {&#13;
    if (this.group) {&#13;
      fabric.StaticCanvas.prototype.sendToBack.call(this.group, this);&#13;
    }&#13;
    else {&#13;
      this.canvas.sendToBack(this);&#13;
    }&#13;
    return this;&#13;
  },&#13;
&#13;
  /**&#13;
   * Moves an object to the top of the stack of drawn objects&#13;
   * @return {fabric.Object} thisArg&#13;
   * @chainable&#13;
   */&#13;
  bringToFront: function() {&#13;
    if (this.group) {&#13;
      fabric.StaticCanvas.prototype.bringToFront.call(this.group, this);&#13;
    }&#13;
    else {&#13;
      this.canvas.bringToFront(this);&#13;
    }&#13;
    return this;&#13;
  },&#13;
&#13;
  /**&#13;
   * Moves an object down in stack of drawn objects&#13;
   * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object&#13;
   * @return {fabric.Object} thisArg&#13;
   * @chainable&#13;
   */&#13;
  sendBackwards: function(intersecting) {&#13;
    if (this.group) {&#13;
      fabric.StaticCanvas.prototype.sendBackwards.call(this.group, this, intersecting);&#13;
    }&#13;
    else {&#13;
      this.canvas.sendBackwards(this, intersecting);&#13;
    }&#13;
    return this;&#13;
  },&#13;
&#13;
  /**&#13;
   * Moves an object up in stack of drawn objects&#13;
   * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object&#13;
   * @return {fabric.Object} thisArg&#13;
   * @chainable&#13;
   */&#13;
  bringForward: function(intersecting) {&#13;
    if (this.group) {&#13;
      fabric.StaticCanvas.prototype.bringForward.call(this.group, this, intersecting);&#13;
    }&#13;
    else {&#13;
      this.canvas.bringForward(this, intersecting);&#13;
    }&#13;
    return this;&#13;
  },&#13;
&#13;
  /**&#13;
   * Moves an object to specified level in stack of drawn objects&#13;
   * @param {Number} index New position of object&#13;
   * @return {fabric.Object} thisArg&#13;
   * @chainable&#13;
   */&#13;
  moveTo: function(index) {&#13;
    if (this.group &amp;&amp; this.group.type !== 'activeSelection') {&#13;
      fabric.StaticCanvas.prototype.moveTo.call(this.group, this, index);&#13;
    }&#13;
    else {&#13;
      this.canvas.moveTo(this, index);&#13;
    }&#13;
    return this;&#13;
  }&#13;
});&#13;
&#13;
&#13;
/* _TO_SVG_START_ */&#13;
(function() {&#13;
  var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;&#13;
&#13;
  function getSvgColorString(prop, value) {&#13;
    if (!value) {&#13;
      return prop + ': none; ';&#13;
    }&#13;
    else if (value.toLive) {&#13;
      return prop + ': url(#SVGID_' + value.id + '); ';&#13;
    }&#13;
    else {&#13;
      var color = new fabric.Color(value),&#13;
          str = prop + ': ' + color.toRgb() + '; ',&#13;
          opacity = color.getAlpha();&#13;
      if (opacity !== 1) {&#13;
        //change the color in rgb + opacity&#13;
        str += prop + '-opacity: ' + opacity.toString() + '; ';&#13;
      }&#13;
      return str;&#13;
    }&#13;
  }&#13;
&#13;
  var toFixed = fabric.util.toFixed;&#13;
&#13;
  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {&#13;
    /**&#13;
     * Returns styles-string for svg-export&#13;
     * @param {Boolean} skipShadow a boolean to skip shadow filter output&#13;
     * @return {String}&#13;
     */&#13;
    getSvgStyles: function(skipShadow) {&#13;
&#13;
      var fillRule = this.fillRule,&#13;
          strokeWidth = this.strokeWidth ? this.strokeWidth : '0',&#13;
          strokeDashArray = this.strokeDashArray ? this.strokeDashArray.join(' ') : 'none',&#13;
          strokeLineCap = this.strokeLineCap ? this.strokeLineCap : 'butt',&#13;
          strokeLineJoin = this.strokeLineJoin ? this.strokeLineJoin : 'miter',&#13;
          strokeMiterLimit = this.strokeMiterLimit ? this.strokeMiterLimit : '4',&#13;
          opacity = typeof this.opacity !== 'undefined' ? this.opacity : '1',&#13;
          visibility = this.visible ? '' : ' visibility: hidden;',&#13;
          filter = skipShadow ? '' : this.getSvgFilter(),&#13;
          fill = getSvgColorString('fill', this.fill),&#13;
          stroke = getSvgColorString('stroke', this.stroke);&#13;
&#13;
      return [&#13;
        stroke,&#13;
        'stroke-width: ', strokeWidth, '; ',&#13;
        'stroke-dasharray: ', strokeDashArray, '; ',&#13;
        'stroke-linecap: ', strokeLineCap, '; ',&#13;
        'stroke-linejoin: ', strokeLineJoin, '; ',&#13;
        'stroke-miterlimit: ', strokeMiterLimit, '; ',&#13;
        fill,&#13;
        'fill-rule: ', fillRule, '; ',&#13;
        'opacity: ', opacity, ';',&#13;
        filter,&#13;
        visibility&#13;
      ].join('');&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns styles-string for svg-export&#13;
     * @param {Object} style style properties for the span a boolean to skip shadow filter output&#13;
     * @param {Boolean} useWhiteSpace a boolean to include an additional attribute in the style.&#13;
     * @return {String}&#13;
     */&#13;
    getSvgSpanStyles: function(style, useWhiteSpace) {&#13;
      var term = '; ',&#13;
          strokeWidth = style.strokeWidth ? 'stroke-width: ' + style.strokeWidth + term : '',&#13;
          fontFamily = style.fontFamily ? 'font-family: ' + style.fontFamily.replace(/"/g, '\'') + term : '',&#13;
          fontSize = style.fontSize ? 'font-size: ' + style.fontSize + term : '',&#13;
          fontStyle = style.fontStyle ? 'font-style: ' + style.fontStyle + term : '',&#13;
          fontWeight = style.fontWeight ? 'font-weight: ' + style.fontWeight + term : '',&#13;
          fill = style.fill ? getSvgColorString('fill', style.fill) : '',&#13;
          stroke = style.stroke ? getSvgColorString('stroke', style.stroke) : '',&#13;
          textDecoration = this.getSvgTextDecoration(style);&#13;
      if (textDecoration) {&#13;
        textDecoration = 'text-decoration: ' + textDecoration + term;&#13;
      }&#13;
      return [&#13;
        stroke,&#13;
        strokeWidth,&#13;
        fontFamily,&#13;
        fontSize,&#13;
        fontStyle,&#13;
        fontWeight,&#13;
        textDecoration,&#13;
        fill,&#13;
        useWhiteSpace ? 'white-space: pre; ' : ''&#13;
      ].join('');&#13;
    },&#13;
&#13;
    getSvgTextDecoration: function(style) {&#13;
      if ('overline' in style || 'underline' in style || 'linethrough' in style) {&#13;
        return (style.overline ? 'overline ' : '') +&#13;
          (style.underline ? 'underline ' : '') + (style.linethrough ? 'line-through ' : '');&#13;
      }&#13;
      return '';&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns filter for svg shadow&#13;
     * @return {String}&#13;
     */&#13;
    getSvgFilter: function() {&#13;
      return this.shadow ? 'filter: url(#SVGID_' + this.shadow.id + ');' : '';&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns id attribute for svg output&#13;
     * @return {String}&#13;
     */&#13;
    getSvgId: function() {&#13;
      return this.id ? 'id="' + this.id + '" ' : '';&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns transform-string for svg-export&#13;
     * @return {String}&#13;
     */&#13;
    getSvgTransform: function() {&#13;
      var angle = this.angle,&#13;
          skewX = (this.skewX % 360),&#13;
          skewY = (this.skewY % 360),&#13;
          center = this.getCenterPoint(),&#13;
&#13;
          NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,&#13;
&#13;
          translatePart = 'translate(' +&#13;
                            toFixed(center.x, NUM_FRACTION_DIGITS) +&#13;
                            ' ' +&#13;
                            toFixed(center.y, NUM_FRACTION_DIGITS) +&#13;
                          ')',&#13;
&#13;
          anglePart = angle !== 0&#13;
            ? (' rotate(' + toFixed(angle, NUM_FRACTION_DIGITS) + ')')&#13;
            : '',&#13;
&#13;
          scalePart = (this.scaleX === 1 &amp;&amp; this.scaleY === 1)&#13;
            ? '' :&#13;
            (' scale(' +&#13;
              toFixed(this.scaleX, NUM_FRACTION_DIGITS) +&#13;
              ' ' +&#13;
              toFixed(this.scaleY, NUM_FRACTION_DIGITS) +&#13;
            ')'),&#13;
&#13;
          skewXPart = skewX !== 0 ? ' skewX(' + toFixed(skewX, NUM_FRACTION_DIGITS) + ')' : '',&#13;
&#13;
          skewYPart = skewY !== 0 ? ' skewY(' + toFixed(skewY, NUM_FRACTION_DIGITS) + ')' : '',&#13;
&#13;
          flipXPart = this.flipX ? ' matrix(-1 0 0 1 0 0) ' : '',&#13;
&#13;
          flipYPart = this.flipY ? ' matrix(1 0 0 -1 0 0)' : '';&#13;
&#13;
      return [&#13;
        translatePart, anglePart, scalePart, flipXPart, flipYPart, skewXPart, skewYPart&#13;
      ].join('');&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns transform-string for svg-export from the transform matrix of single elements&#13;
     * @return {String}&#13;
     */&#13;
    getSvgTransformMatrix: function() {&#13;
      return this.transformMatrix ? ' matrix(' + this.transformMatrix.join(' ') + ') ' : '';&#13;
    },&#13;
&#13;
    _setSVGBg: function(textBgRects) {&#13;
      if (this.backgroundColor) {&#13;
        textBgRects.push(&#13;
          '\t\t&lt;rect ',&#13;
          this._getFillAttributes(this.backgroundColor),&#13;
          ' x="',&#13;
          toFixed(-this.width / 2, NUM_FRACTION_DIGITS),&#13;
          '" y="',&#13;
          toFixed(-this.height / 2, NUM_FRACTION_DIGITS),&#13;
          '" width="',&#13;
          toFixed(this.width, NUM_FRACTION_DIGITS),&#13;
          '" height="',&#13;
          toFixed(this.height, NUM_FRACTION_DIGITS),&#13;
          '"&gt;&lt;/rect&gt;\n');&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _createBaseSVGMarkup: function() {&#13;
      var markup = [];&#13;
&#13;
      if (this.fill &amp;&amp; this.fill.toLive) {&#13;
        markup.push(this.fill.toSVG(this, false));&#13;
      }&#13;
      if (this.stroke &amp;&amp; this.stroke.toLive) {&#13;
        markup.push(this.stroke.toSVG(this, false));&#13;
      }&#13;
      if (this.shadow) {&#13;
        markup.push(this.shadow.toSVG(this));&#13;
      }&#13;
      return markup;&#13;
    },&#13;
&#13;
    addPaintOrder: function() {&#13;
      return this.paintFirst !== 'fill' ? ' paint-order="' + this.paintFirst + '" ' : '';&#13;
    }&#13;
  });&#13;
})();&#13;
/* _TO_SVG_END_ */&#13;
&#13;
&#13;
(function() {&#13;
&#13;
  var extend = fabric.util.object.extend,&#13;
      originalSet = 'stateProperties';&#13;
&#13;
  /*&#13;
    Depends on `stateProperties`&#13;
  */&#13;
  function saveProps(origin, destination, props) {&#13;
    var tmpObj = { }, deep = true;&#13;
    props.forEach(function(prop) {&#13;
      tmpObj[prop] = origin[prop];&#13;
    });&#13;
    extend(origin[destination], tmpObj, deep);&#13;
  }&#13;
&#13;
  function _isEqual(origValue, currentValue, firstPass) {&#13;
    if (origValue === currentValue) {&#13;
      // if the objects are identical, return&#13;
      return true;&#13;
    }&#13;
    else if (Array.isArray(origValue)) {&#13;
      if (origValue.length !== currentValue.length) {&#13;
        return false;&#13;
      }&#13;
      for (var i = 0, len = origValue.length; i &lt; len; i++) {&#13;
        if (!_isEqual(origValue[i], currentValue[i])) {&#13;
          return false;&#13;
        }&#13;
      }&#13;
      return true;&#13;
    }&#13;
    else if (origValue &amp;&amp; typeof origValue === 'object') {&#13;
      var keys = Object.keys(origValue), key;&#13;
      if (!firstPass &amp;&amp; keys.length !== Object.keys(currentValue).length) {&#13;
        return false;&#13;
      }&#13;
      for (var i = 0, len = keys.length; i &lt; len; i++) {&#13;
        key = keys[i];&#13;
        if (!_isEqual(origValue[key], currentValue[key])) {&#13;
          return false;&#13;
        }&#13;
      }&#13;
      return true;&#13;
    }&#13;
  }&#13;
&#13;
&#13;
  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {&#13;
&#13;
    /**&#13;
     * Returns true if object state (one of its state properties) was changed&#13;
     * @param {String} [propertySet] optional name for the set of property we want to save&#13;
     * @return {Boolean} true if instance' state has changed since `{@link fabric.Object#saveState}` was called&#13;
     */&#13;
    hasStateChanged: function(propertySet) {&#13;
      propertySet = propertySet || originalSet;&#13;
      var dashedPropertySet = '_' + propertySet;&#13;
      if (Object.keys(this[dashedPropertySet]).length &lt; this[propertySet].length) {&#13;
        return true;&#13;
      }&#13;
      return !_isEqual(this[dashedPropertySet], this, true);&#13;
    },&#13;
&#13;
    /**&#13;
     * Saves state of an object&#13;
     * @param {Object} [options] Object with additional `stateProperties` array to include when saving state&#13;
     * @return {fabric.Object} thisArg&#13;
     */&#13;
    saveState: function(options) {&#13;
      var propertySet = options &amp;&amp; options.propertySet || originalSet,&#13;
          destination = '_' + propertySet;&#13;
      if (!this[destination]) {&#13;
        return this.setupState(options);&#13;
      }&#13;
      saveProps(this, destination, this[propertySet]);&#13;
      if (options &amp;&amp; options.stateProperties) {&#13;
        saveProps(this, destination, options.stateProperties);&#13;
      }&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Setups state of an object&#13;
     * @param {Object} [options] Object with additional `stateProperties` array to include when saving state&#13;
     * @return {fabric.Object} thisArg&#13;
     */&#13;
    setupState: function(options) {&#13;
      options = options || { };&#13;
      var propertySet = options.propertySet || originalSet;&#13;
      options.propertySet = propertySet;&#13;
      this['_' + propertySet] = { };&#13;
      this.saveState(options);&#13;
      return this;&#13;
    }&#13;
  });&#13;
})();&#13;
&#13;
&#13;
(function() {&#13;
&#13;
  var degreesToRadians = fabric.util.degreesToRadians;&#13;
&#13;
  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {&#13;
&#13;
    /**&#13;
     * The object interactivity controls.&#13;
     * @private&#13;
     */&#13;
    _controlsVisibility: null,&#13;
&#13;
    /**&#13;
     * Determines which corner has been clicked&#13;
     * @private&#13;
     * @param {Object} pointer The pointer indicating the mouse position&#13;
     * @return {String|Boolean} corner code (tl, tr, bl, br, etc.), or false if nothing is found&#13;
     */&#13;
    _findTargetCorner: function(pointer) {&#13;
      // objects in group, anykind, are not self modificable,&#13;
      // must not return an hovered corner.&#13;
      if (!this.hasControls || this.group || (!this.canvas || this.canvas._activeObject !== this)) {&#13;
        return false;&#13;
      }&#13;
&#13;
      var ex = pointer.x,&#13;
          ey = pointer.y,&#13;
          xPoints,&#13;
          lines;&#13;
      this.__corner = 0;&#13;
      for (var i in this.oCoords) {&#13;
&#13;
        if (!this.isControlVisible(i)) {&#13;
          continue;&#13;
        }&#13;
&#13;
        if (i === 'mtr' &amp;&amp; !this.hasRotatingPoint) {&#13;
          continue;&#13;
        }&#13;
&#13;
        if (this.get('lockUniScaling') &amp;&amp;&#13;
           (i === 'mt' || i === 'mr' || i === 'mb' || i === 'ml')) {&#13;
          continue;&#13;
        }&#13;
&#13;
        lines = this._getImageLines(this.oCoords[i].corner);&#13;
&#13;
        // debugging&#13;
&#13;
        // canvas.contextTop.fillRect(lines.bottomline.d.x, lines.bottomline.d.y, 2, 2);&#13;
        // canvas.contextTop.fillRect(lines.bottomline.o.x, lines.bottomline.o.y, 2, 2);&#13;
&#13;
        // canvas.contextTop.fillRect(lines.leftline.d.x, lines.leftline.d.y, 2, 2);&#13;
        // canvas.contextTop.fillRect(lines.leftline.o.x, lines.leftline.o.y, 2, 2);&#13;
&#13;
        // canvas.contextTop.fillRect(lines.topline.d.x, lines.topline.d.y, 2, 2);&#13;
        // canvas.contextTop.fillRect(lines.topline.o.x, lines.topline.o.y, 2, 2);&#13;
&#13;
        // canvas.contextTop.fillRect(lines.rightline.d.x, lines.rightline.d.y, 2, 2);&#13;
        // canvas.contextTop.fillRect(lines.rightline.o.x, lines.rightline.o.y, 2, 2);&#13;
&#13;
        xPoints = this._findCrossPoints({ x: ex, y: ey }, lines);&#13;
        if (xPoints !== 0 &amp;&amp; xPoints % 2 === 1) {&#13;
          this.__corner = i;&#13;
          return i;&#13;
        }&#13;
      }&#13;
      return false;&#13;
    },&#13;
&#13;
    /**&#13;
     * Sets the coordinates of the draggable boxes in the corners of&#13;
     * the image used to scale/rotate it.&#13;
     * @private&#13;
     */&#13;
    _setCornerCoords: function() {&#13;
      var coords = this.oCoords,&#13;
          newTheta = degreesToRadians(45 - this.angle),&#13;
          /* Math.sqrt(2 * Math.pow(this.cornerSize, 2)) / 2, */&#13;
          /* 0.707106 stands for sqrt(2)/2 */&#13;
          cornerHypotenuse = this.cornerSize * 0.707106,&#13;
          cosHalfOffset = cornerHypotenuse * Math.cos(newTheta),&#13;
          sinHalfOffset = cornerHypotenuse * Math.sin(newTheta),&#13;
          x, y;&#13;
&#13;
      for (var point in coords) {&#13;
        x = coords[point].x;&#13;
        y = coords[point].y;&#13;
        coords[point].corner = {&#13;
          tl: {&#13;
            x: x - sinHalfOffset,&#13;
            y: y - cosHalfOffset&#13;
          },&#13;
          tr: {&#13;
            x: x + cosHalfOffset,&#13;
            y: y - sinHalfOffset&#13;
          },&#13;
          bl: {&#13;
            x: x - cosHalfOffset,&#13;
            y: y + sinHalfOffset&#13;
          },&#13;
          br: {&#13;
            x: x + sinHalfOffset,&#13;
            y: y + cosHalfOffset&#13;
          }&#13;
        };&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Draws a colored layer behind the object, inside its selection borders.&#13;
     * Requires public options: padding, selectionBackgroundColor&#13;
     * this function is called when the context is transformed&#13;
     * has checks to be skipped when the object is on a staticCanvas&#13;
     * @param {CanvasRenderingContext2D} ctx Context to draw on&#13;
     * @return {fabric.Object} thisArg&#13;
     * @chainable&#13;
     */&#13;
    drawSelectionBackground: function(ctx) {&#13;
      if (!this.selectionBackgroundColor ||&#13;
        (this.canvas &amp;&amp; !this.canvas.interactive) ||&#13;
        (this.canvas &amp;&amp; this.canvas._activeObject !== this)&#13;
      ) {&#13;
        return this;&#13;
      }&#13;
      ctx.save();&#13;
      var center = this.getCenterPoint(), wh = this._calculateCurrentDimensions(),&#13;
          vpt = this.canvas.viewportTransform;&#13;
      ctx.translate(center.x, center.y);&#13;
      ctx.scale(1 / vpt[0], 1 / vpt[3]);&#13;
      ctx.rotate(degreesToRadians(this.angle));&#13;
      ctx.fillStyle = this.selectionBackgroundColor;&#13;
      ctx.fillRect(-wh.x / 2, -wh.y / 2, wh.x, wh.y);&#13;
      ctx.restore();&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Draws borders of an object's bounding box.&#13;
     * Requires public properties: width, height&#13;
     * Requires public options: padding, borderColor&#13;
     * @param {CanvasRenderingContext2D} ctx Context to draw on&#13;
     * @param {Object} styleOverride object to override the object style&#13;
     * @return {fabric.Object} thisArg&#13;
     * @chainable&#13;
     */&#13;
    drawBorders: function(ctx, styleOverride) {&#13;
      styleOverride = styleOverride || {};&#13;
      var wh = this._calculateCurrentDimensions(),&#13;
          strokeWidth = 1 / this.borderScaleFactor,&#13;
          width = wh.x + strokeWidth,&#13;
          height = wh.y + strokeWidth,&#13;
          drawRotatingPoint = typeof styleOverride.hasRotatingPoint !== 'undefined' ?&#13;
            styleOverride.hasRotatingPoint : this.hasRotatingPoint,&#13;
          hasControls = typeof styleOverride.hasControls !== 'undefined' ?&#13;
            styleOverride.hasControls : this.hasControls,&#13;
          rotatingPointOffset = typeof styleOverride.rotatingPointOffset !== 'undefined' ?&#13;
            styleOverride.rotatingPointOffset : this.rotatingPointOffset;&#13;
&#13;
      ctx.save();&#13;
      ctx.strokeStyle = styleOverride.borderColor || this.borderColor;&#13;
      this._setLineDash(ctx, styleOverride.borderDashArray || this.borderDashArray, null);&#13;
&#13;
      ctx.strokeRect(&#13;
        -width / 2,&#13;
        -height / 2,&#13;
        width,&#13;
        height&#13;
      );&#13;
&#13;
      if (drawRotatingPoint &amp;&amp; this.isControlVisible('mtr') &amp;&amp; hasControls) {&#13;
&#13;
        var rotateHeight = -height / 2;&#13;
&#13;
        ctx.beginPath();&#13;
        ctx.moveTo(0, rotateHeight);&#13;
        ctx.lineTo(0, rotateHeight - rotatingPointOffset);&#13;
        ctx.stroke();&#13;
      }&#13;
&#13;
      ctx.restore();&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Draws borders of an object's bounding box when it is inside a group.&#13;
     * Requires public properties: width, height&#13;
     * Requires public options: padding, borderColor&#13;
     * @param {CanvasRenderingContext2D} ctx Context to draw on&#13;
     * @param {object} options object representing current object parameters&#13;
     * @param {Object} styleOverride object to override the object style&#13;
     * @return {fabric.Object} thisArg&#13;
     * @chainable&#13;
     */&#13;
    drawBordersInGroup: function(ctx, options, styleOverride) {&#13;
      styleOverride = styleOverride || {};&#13;
      var p = this._getNonTransformedDimensions(),&#13;
          matrix = fabric.util.customTransformMatrix(options.scaleX, options.scaleY, options.skewX),&#13;
          wh = fabric.util.transformPoint(p, matrix),&#13;
          strokeWidth = 1 / this.borderScaleFactor,&#13;
          width = wh.x + strokeWidth,&#13;
          height = wh.y + strokeWidth;&#13;
&#13;
      ctx.save();&#13;
      this._setLineDash(ctx, styleOverride.borderDashArray || this.borderDashArray, null);&#13;
      ctx.strokeStyle = styleOverride.borderColor || this.borderColor;&#13;
&#13;
      ctx.strokeRect(&#13;
        -width / 2,&#13;
        -height / 2,&#13;
        width,&#13;
        height&#13;
      );&#13;
&#13;
      ctx.restore();&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Draws corners of an object's bounding box.&#13;
     * Requires public properties: width, height&#13;
     * Requires public options: cornerSize, padding&#13;
     * @param {CanvasRenderingContext2D} ctx Context to draw on&#13;
     * @param {Object} styleOverride object to override the object style&#13;
     * @return {fabric.Object} thisArg&#13;
     * @chainable&#13;
     */&#13;
    drawControls: function(ctx, styleOverride) {&#13;
      styleOverride = styleOverride || {};&#13;
      var wh = this._calculateCurrentDimensions(),&#13;
          width = wh.x,&#13;
          height = wh.y,&#13;
          scaleOffset = styleOverride.cornerSize || this.cornerSize,&#13;
          left = -(width + scaleOffset) / 2,&#13;
          top = -(height + scaleOffset) / 2,&#13;
          transparentCorners = typeof styleOverride.transparentCorners !== 'undefined' ?&#13;
            styleOverride.transparentCorners : this.transparentCorners,&#13;
          hasRotatingPoint = typeof styleOverride.hasRotatingPoint !== 'undefined' ?&#13;
            styleOverride.hasRotatingPoint : this.hasRotatingPoint,&#13;
          methodName = transparentCorners ? 'stroke' : 'fill';&#13;
&#13;
      ctx.save();&#13;
      ctx.strokeStyle = ctx.fillStyle = styleOverride.cornerColor || this.cornerColor;&#13;
      if (!this.transparentCorners) {&#13;
        ctx.strokeStyle = styleOverride.cornerStrokeColor || this.cornerStrokeColor;&#13;
      }&#13;
      this._setLineDash(ctx, styleOverride.cornerDashArray || this.cornerDashArray, null);&#13;
&#13;
      // top-left&#13;
      this._drawControl('tl', ctx, methodName,&#13;
        left,&#13;
        top, styleOverride);&#13;
&#13;
      // top-right&#13;
      this._drawControl('tr', ctx, methodName,&#13;
        left + width,&#13;
        top, styleOverride);&#13;
&#13;
      // bottom-left&#13;
      this._drawControl('bl', ctx, methodName,&#13;
        left,&#13;
        top + height, styleOverride);&#13;
&#13;
      // bottom-right&#13;
      this._drawControl('br', ctx, methodName,&#13;
        left + width,&#13;
        top + height, styleOverride);&#13;
&#13;
      if (!this.get('lockUniScaling')) {&#13;
&#13;
        // middle-top&#13;
        this._drawControl('mt', ctx, methodName,&#13;
          left + width / 2,&#13;
          top, styleOverride);&#13;
&#13;
        // middle-bottom&#13;
        this._drawControl('mb', ctx, methodName,&#13;
          left + width / 2,&#13;
          top + height, styleOverride);&#13;
&#13;
        // middle-right&#13;
        this._drawControl('mr', ctx, methodName,&#13;
          left + width,&#13;
          top + height / 2, styleOverride);&#13;
&#13;
        // middle-left&#13;
        this._drawControl('ml', ctx, methodName,&#13;
          left,&#13;
          top + height / 2, styleOverride);&#13;
      }&#13;
&#13;
      // middle-top-rotate&#13;
      if (hasRotatingPoint) {&#13;
        this._drawControl('mtr', ctx, methodName,&#13;
          left + width / 2,&#13;
          top - this.rotatingPointOffset, styleOverride);&#13;
      }&#13;
&#13;
      ctx.restore();&#13;
&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _drawControl: function(control, ctx, methodName, left, top, styleOverride) {&#13;
      styleOverride = styleOverride || {};&#13;
      if (!this.isControlVisible(control)) {&#13;
        return;&#13;
      }&#13;
      var size = this.cornerSize, stroke = !this.transparentCorners &amp;&amp; this.cornerStrokeColor;&#13;
      switch (styleOverride.cornerStyle || this.cornerStyle) {&#13;
        case 'circle':&#13;
          ctx.beginPath();&#13;
          ctx.arc(left + size / 2, top + size / 2, size / 2, 0, 2 * Math.PI, false);&#13;
          ctx[methodName]();&#13;
          if (stroke) {&#13;
            ctx.stroke();&#13;
          }&#13;
          break;&#13;
        default:&#13;
          this.transparentCorners || ctx.clearRect(left, top, size, size);&#13;
          ctx[methodName + 'Rect'](left, top, size, size);&#13;
          if (stroke) {&#13;
            ctx.strokeRect(left, top, size, size);&#13;
          }&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns true if the specified control is visible, false otherwise.&#13;
     * @param {String} controlName The name of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.&#13;
     * @returns {Boolean} true if the specified control is visible, false otherwise&#13;
     */&#13;
    isControlVisible: function(controlName) {&#13;
      return this._getControlsVisibility()[controlName];&#13;
    },&#13;
&#13;
    /**&#13;
     * Sets the visibility of the specified control.&#13;
     * @param {String} controlName The name of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.&#13;
     * @param {Boolean} visible true to set the specified control visible, false otherwise&#13;
     * @return {fabric.Object} thisArg&#13;
     * @chainable&#13;
     */&#13;
    setControlVisible: function(controlName, visible) {&#13;
      this._getControlsVisibility()[controlName] = visible;&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Sets the visibility state of object controls.&#13;
     * @param {Object} [options] Options object&#13;
     * @param {Boolean} [options.bl] true to enable the bottom-left control, false to disable it&#13;
     * @param {Boolean} [options.br] true to enable the bottom-right control, false to disable it&#13;
     * @param {Boolean} [options.mb] true to enable the middle-bottom control, false to disable it&#13;
     * @param {Boolean} [options.ml] true to enable the middle-left control, false to disable it&#13;
     * @param {Boolean} [options.mr] true to enable the middle-right control, false to disable it&#13;
     * @param {Boolean} [options.mt] true to enable the middle-top control, false to disable it&#13;
     * @param {Boolean} [options.tl] true to enable the top-left control, false to disable it&#13;
     * @param {Boolean} [options.tr] true to enable the top-right control, false to disable it&#13;
     * @param {Boolean} [options.mtr] true to enable the middle-top-rotate control, false to disable it&#13;
     * @return {fabric.Object} thisArg&#13;
     * @chainable&#13;
     */&#13;
    setControlsVisibility: function(options) {&#13;
      options || (options = { });&#13;
&#13;
      for (var p in options) {&#13;
        this.setControlVisible(p, options[p]);&#13;
      }&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns the instance of the control visibility set for this object.&#13;
     * @private&#13;
     * @returns {Object}&#13;
     */&#13;
    _getControlsVisibility: function() {&#13;
      if (!this._controlsVisibility) {&#13;
        this._controlsVisibility = {&#13;
          tl: true,&#13;
          tr: true,&#13;
          br: true,&#13;
          bl: true,&#13;
          ml: true,&#13;
          mt: true,&#13;
          mr: true,&#13;
          mb: true,&#13;
          mtr: true&#13;
        };&#13;
      }&#13;
      return this._controlsVisibility;&#13;
    },&#13;
&#13;
    /**&#13;
     * This callback function is called every time _discardActiveObject or _setActiveObject&#13;
     * try to to deselect this object. If the function returns true, the process is cancelled&#13;
     * @param {Object} [options] options sent from the upper functions&#13;
     * @param {Event} [options.e] event if the process is generated by an event&#13;
     */&#13;
    onDeselect: function() {&#13;
      // implemented by sub-classes, as needed.&#13;
    },&#13;
&#13;
&#13;
    /**&#13;
     * This callback function is called every time _discardActiveObject or _setActiveObject&#13;
     * try to to select this object. If the function returns true, the process is cancelled&#13;
     * @param {Object} [options] options sent from the upper functions&#13;
     * @param {Event} [options.e] event if the process is generated by an event&#13;
     */&#13;
    onSelect: function() {&#13;
      // implemented by sub-classes, as needed.&#13;
    }&#13;
  });&#13;
})();&#13;
&#13;
&#13;
fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {&#13;
&#13;
  /**&#13;
   * Animation duration (in ms) for fx* methods&#13;
   * @type Number&#13;
   * @default&#13;
   */&#13;
  FX_DURATION: 500,&#13;
&#13;
  /**&#13;
   * Centers object horizontally with animation.&#13;
   * @param {fabric.Object} object Object to center&#13;
   * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties&#13;
   * @param {Function} [callbacks.onComplete] Invoked on completion&#13;
   * @param {Function} [callbacks.onChange] Invoked on every step of animation&#13;
   * @return {fabric.Canvas} thisArg&#13;
   * @chainable&#13;
   */&#13;
  fxCenterObjectH: function (object, callbacks) {&#13;
    callbacks = callbacks || { };&#13;
&#13;
    var empty = function() { },&#13;
        onComplete = callbacks.onComplete || empty,&#13;
        onChange = callbacks.onChange || empty,&#13;
        _this = this;&#13;
&#13;
    fabric.util.animate({&#13;
      startValue: object.left,&#13;
      endValue: this.getCenter().left,&#13;
      duration: this.FX_DURATION,&#13;
      onChange: function(value) {&#13;
        object.set('left', value);&#13;
        _this.requestRenderAll();&#13;
        onChange();&#13;
      },&#13;
      onComplete: function() {&#13;
        object.setCoords();&#13;
        onComplete();&#13;
      }&#13;
    });&#13;
&#13;
    return this;&#13;
  },&#13;
&#13;
  /**&#13;
   * Centers object vertically with animation.&#13;
   * @param {fabric.Object} object Object to center&#13;
   * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties&#13;
   * @param {Function} [callbacks.onComplete] Invoked on completion&#13;
   * @param {Function} [callbacks.onChange] Invoked on every step of animation&#13;
   * @return {fabric.Canvas} thisArg&#13;
   * @chainable&#13;
   */&#13;
  fxCenterObjectV: function (object, callbacks) {&#13;
    callbacks = callbacks || { };&#13;
&#13;
    var empty = function() { },&#13;
        onComplete = callbacks.onComplete || empty,&#13;
        onChange = callbacks.onChange || empty,&#13;
        _this = this;&#13;
&#13;
    fabric.util.animate({&#13;
      startValue: object.top,&#13;
      endValue: this.getCenter().top,&#13;
      duration: this.FX_DURATION,&#13;
      onChange: function(value) {&#13;
        object.set('top', value);&#13;
        _this.requestRenderAll();&#13;
        onChange();&#13;
      },&#13;
      onComplete: function() {&#13;
        object.setCoords();&#13;
        onComplete();&#13;
      }&#13;
    });&#13;
&#13;
    return this;&#13;
  },&#13;
&#13;
  /**&#13;
   * Same as `fabric.Canvas#remove` but animated&#13;
   * @param {fabric.Object} object Object to remove&#13;
   * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties&#13;
   * @param {Function} [callbacks.onComplete] Invoked on completion&#13;
   * @param {Function} [callbacks.onChange] Invoked on every step of animation&#13;
   * @return {fabric.Canvas} thisArg&#13;
   * @chainable&#13;
   */&#13;
  fxRemove: function (object, callbacks) {&#13;
    callbacks = callbacks || { };&#13;
&#13;
    var empty = function() { },&#13;
        onComplete = callbacks.onComplete || empty,&#13;
        onChange = callbacks.onChange || empty,&#13;
        _this = this;&#13;
&#13;
    fabric.util.animate({&#13;
      startValue: object.opacity,&#13;
      endValue: 0,&#13;
      duration: this.FX_DURATION,&#13;
      onChange: function(value) {&#13;
        object.set('opacity', value);&#13;
        _this.requestRenderAll();&#13;
        onChange();&#13;
      },&#13;
      onComplete: function () {&#13;
        _this.remove(object);&#13;
        onComplete();&#13;
      }&#13;
    });&#13;
&#13;
    return this;&#13;
  }&#13;
});&#13;
&#13;
fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {&#13;
  /**&#13;
   * Animates object's properties&#13;
   * @param {String|Object} property Property to animate (if string) or properties to animate (if object)&#13;
   * @param {Number|Object} value Value to animate property to (if string was given first) or options object&#13;
   * @return {fabric.Object} thisArg&#13;
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#animation}&#13;
   * @chainable&#13;
   *&#13;
   * As object  multiple properties&#13;
   *&#13;
   * object.animate({ left: ..., top: ... });&#13;
   * object.animate({ left: ..., top: ... }, { duration: ... });&#13;
   *&#13;
   * As string  one property&#13;
   *&#13;
   * object.animate('left', ...);&#13;
   * object.animate('left', { duration: ... });&#13;
   *&#13;
   */&#13;
  animate: function() {&#13;
    if (arguments[0] &amp;&amp; typeof arguments[0] === 'object') {&#13;
      var propsToAnimate = [], prop, skipCallbacks;&#13;
      for (prop in arguments[0]) {&#13;
        propsToAnimate.push(prop);&#13;
      }&#13;
      for (var i = 0, len = propsToAnimate.length; i &lt; len; i++) {&#13;
        prop = propsToAnimate[i];&#13;
        skipCallbacks = i !== len - 1;&#13;
        this._animate(prop, arguments[0][prop], arguments[1], skipCallbacks);&#13;
      }&#13;
    }&#13;
    else {&#13;
      this._animate.apply(this, arguments);&#13;
    }&#13;
    return this;&#13;
  },&#13;
&#13;
  /**&#13;
   * @private&#13;
   * @param {String} property Property to animate&#13;
   * @param {String} to Value to animate to&#13;
   * @param {Object} [options] Options object&#13;
   * @param {Boolean} [skipCallbacks] When true, callbacks like onchange and oncomplete are not invoked&#13;
   */&#13;
  _animate: function(property, to, options, skipCallbacks) {&#13;
    var _this = this, propPair;&#13;
&#13;
    to = to.toString();&#13;
&#13;
    if (!options) {&#13;
      options = { };&#13;
    }&#13;
    else {&#13;
      options = fabric.util.object.clone(options);&#13;
    }&#13;
&#13;
    if (~property.indexOf('.')) {&#13;
      propPair = property.split('.');&#13;
    }&#13;
&#13;
    var currentValue = propPair&#13;
      ? this.get(propPair[0])[propPair[1]]&#13;
      : this.get(property);&#13;
&#13;
    if (!('from' in options)) {&#13;
      options.from = currentValue;&#13;
    }&#13;
&#13;
    if (~to.indexOf('=')) {&#13;
      to = currentValue + parseFloat(to.replace('=', ''));&#13;
    }&#13;
    else {&#13;
      to = parseFloat(to);&#13;
    }&#13;
&#13;
    fabric.util.animate({&#13;
      startValue: options.from,&#13;
      endValue: to,&#13;
      byValue: options.by,&#13;
      easing: options.easing,&#13;
      duration: options.duration,&#13;
      abort: options.abort &amp;&amp; function() {&#13;
        return options.abort.call(_this);&#13;
      },&#13;
      onChange: function(value, valueProgress, timeProgress) {&#13;
        if (propPair) {&#13;
          _this[propPair[0]][propPair[1]] = value;&#13;
        }&#13;
        else {&#13;
          _this.set(property, value);&#13;
        }&#13;
        if (skipCallbacks) {&#13;
          return;&#13;
        }&#13;
        options.onChange &amp;&amp; options.onChange(value, valueProgress, timeProgress);&#13;
      },&#13;
      onComplete: function(value, valueProgress, timeProgress) {&#13;
        if (skipCallbacks) {&#13;
          return;&#13;
        }&#13;
&#13;
        _this.setCoords();&#13;
        options.onComplete &amp;&amp; options.onComplete(value, valueProgress, timeProgress);&#13;
      }&#13;
    });&#13;
  }&#13;
});&#13;
&#13;
&#13;
(function(global) {&#13;
&#13;
  'use strict';&#13;
&#13;
  var fabric = global.fabric || (global.fabric = { }),&#13;
      extend = fabric.util.object.extend,&#13;
      clone = fabric.util.object.clone,&#13;
      coordProps = { x1: 1, x2: 1, y1: 1, y2: 1 },&#13;
      supportsLineDash = fabric.StaticCanvas.supports('setLineDash');&#13;
&#13;
  if (fabric.Line) {&#13;
    fabric.warn('fabric.Line is already defined');&#13;
    return;&#13;
  }&#13;
&#13;
  /**&#13;
   * Line class&#13;
   * @class fabric.Line&#13;
   * @extends fabric.Object&#13;
   * @see {@link fabric.Line#initialize} for constructor definition&#13;
   */&#13;
  fabric.Line = fabric.util.createClass(fabric.Object, /** @lends fabric.Line.prototype */ {&#13;
&#13;
    /**&#13;
     * Type of an object&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    type: 'line',&#13;
&#13;
    /**&#13;
     * x value or first line edge&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    x1: 0,&#13;
&#13;
    /**&#13;
     * y value or first line edge&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    y1: 0,&#13;
&#13;
    /**&#13;
     * x value or second line edge&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    x2: 0,&#13;
&#13;
    /**&#13;
     * y value or second line edge&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    y2: 0,&#13;
&#13;
    cacheProperties: fabric.Object.prototype.cacheProperties.concat('x1', 'x2', 'y1', 'y2'),&#13;
&#13;
    /**&#13;
     * Constructor&#13;
     * @param {Array} [points] Array of points&#13;
     * @param {Object} [options] Options object&#13;
     * @return {fabric.Line} thisArg&#13;
     */&#13;
    initialize: function(points, options) {&#13;
      if (!points) {&#13;
        points = [0, 0, 0, 0];&#13;
      }&#13;
&#13;
      this.callSuper('initialize', options);&#13;
&#13;
      this.set('x1', points[0]);&#13;
      this.set('y1', points[1]);&#13;
      this.set('x2', points[2]);&#13;
      this.set('y2', points[3]);&#13;
&#13;
      this._setWidthHeight(options);&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Object} [options] Options&#13;
     */&#13;
    _setWidthHeight: function(options) {&#13;
      options || (options = { });&#13;
&#13;
      this.width = Math.abs(this.x2 - this.x1);&#13;
      this.height = Math.abs(this.y2 - this.y1);&#13;
&#13;
      this.left = 'left' in options&#13;
        ? options.left&#13;
        : this._getLeftToOriginX();&#13;
&#13;
      this.top = 'top' in options&#13;
        ? options.top&#13;
        : this._getTopToOriginY();&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {String} key&#13;
     * @param {*} value&#13;
     */&#13;
    _set: function(key, value) {&#13;
      this.callSuper('_set', key, value);&#13;
      if (typeof coordProps[key] !== 'undefined') {&#13;
        this._setWidthHeight();&#13;
      }&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @return {Number} leftToOriginX Distance from left edge of canvas to originX of Line.&#13;
     */&#13;
    _getLeftToOriginX: makeEdgeToOriginGetter(&#13;
      { // property names&#13;
        origin: 'originX',&#13;
        axis1: 'x1',&#13;
        axis2: 'x2',&#13;
        dimension: 'width'&#13;
      },&#13;
      { // possible values of origin&#13;
        nearest: 'left',&#13;
        center: 'center',&#13;
        farthest: 'right'&#13;
      }&#13;
    ),&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @return {Number} topToOriginY Distance from top edge of canvas to originY of Line.&#13;
     */&#13;
    _getTopToOriginY: makeEdgeToOriginGetter(&#13;
      { // property names&#13;
        origin: 'originY',&#13;
        axis1: 'y1',&#13;
        axis2: 'y2',&#13;
        dimension: 'height'&#13;
      },&#13;
      { // possible values of origin&#13;
        nearest: 'top',&#13;
        center: 'center',&#13;
        farthest: 'bottom'&#13;
      }&#13;
    ),&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     */&#13;
    _render: function(ctx) {&#13;
      ctx.beginPath();&#13;
&#13;
      if (!this.strokeDashArray || this.strokeDashArray &amp;&amp; supportsLineDash) {&#13;
        // move from center (of virtual box) to its left/top corner&#13;
        // we can't assume x1, y1 is top left and x2, y2 is bottom right&#13;
        var p = this.calcLinePoints();&#13;
        ctx.moveTo(p.x1, p.y1);&#13;
        ctx.lineTo(p.x2, p.y2);&#13;
      }&#13;
&#13;
      ctx.lineWidth = this.strokeWidth;&#13;
&#13;
      // TODO: test this&#13;
      // make sure setting "fill" changes color of a line&#13;
      // (by copying fillStyle to strokeStyle, since line is stroked, not filled)&#13;
      var origStrokeStyle = ctx.strokeStyle;&#13;
      ctx.strokeStyle = this.stroke || ctx.fillStyle;&#13;
      this.stroke &amp;&amp; this._renderStroke(ctx);&#13;
      ctx.strokeStyle = origStrokeStyle;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     */&#13;
    _renderDashedStroke: function(ctx) {&#13;
      var p = this.calcLinePoints();&#13;
&#13;
      ctx.beginPath();&#13;
      fabric.util.drawDashedLine(ctx, p.x1, p.y1, p.x2, p.y2, this.strokeDashArray);&#13;
      ctx.closePath();&#13;
    },&#13;
&#13;
    /**&#13;
     * This function is an helper for svg import. it returns the center of the object in the svg&#13;
     * untransformed coordinates&#13;
     * @private&#13;
     * @return {Object} center point from element coordinates&#13;
     */&#13;
    _findCenterFromElement: function() {&#13;
      return {&#13;
        x: (this.x1 + this.x2) / 2,&#13;
        y: (this.y1 + this.y2) / 2,&#13;
      };&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns object representation of an instance&#13;
     * @methd toObject&#13;
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output&#13;
     * @return {Object} object representation of an instance&#13;
     */&#13;
    toObject: function(propertiesToInclude) {&#13;
      return extend(this.callSuper('toObject', propertiesToInclude), this.calcLinePoints());&#13;
    },&#13;
&#13;
    /*&#13;
     * Calculate object dimensions from its properties&#13;
     * @private&#13;
     */&#13;
    _getNonTransformedDimensions: function() {&#13;
      var dim = this.callSuper('_getNonTransformedDimensions');&#13;
      if (this.strokeLineCap === 'butt') {&#13;
        if (this.width === 0) {&#13;
          dim.y -= this.strokeWidth;&#13;
        }&#13;
        if (this.height === 0) {&#13;
          dim.x -= this.strokeWidth;&#13;
        }&#13;
      }&#13;
      return dim;&#13;
    },&#13;
&#13;
    /**&#13;
     * Recalculates line points given width and height&#13;
     * @private&#13;
     */&#13;
    calcLinePoints: function() {&#13;
      var xMult = this.x1 &lt;= this.x2 ? -1 : 1,&#13;
          yMult = this.y1 &lt;= this.y2 ? -1 : 1,&#13;
          x1 = (xMult * this.width * 0.5),&#13;
          y1 = (yMult * this.height * 0.5),&#13;
          x2 = (xMult * this.width * -0.5),&#13;
          y2 = (yMult * this.height * -0.5);&#13;
&#13;
      return {&#13;
        x1: x1,&#13;
        x2: x2,&#13;
        y1: y1,&#13;
        y2: y2&#13;
      };&#13;
    },&#13;
&#13;
    /* _TO_SVG_START_ */&#13;
    /**&#13;
     * Returns SVG representation of an instance&#13;
     * @param {Function} [reviver] Method for further parsing of svg representation.&#13;
     * @return {String} svg representation of an instance&#13;
     */&#13;
    toSVG: function(reviver) {&#13;
      var markup = this._createBaseSVGMarkup(),&#13;
          p = this.calcLinePoints();&#13;
      markup.push(&#13;
        '&lt;line ', this.getSvgId(),&#13;
        'x1="', p.x1,&#13;
        '" y1="', p.y1,&#13;
        '" x2="', p.x2,&#13;
        '" y2="', p.y2,&#13;
        '" style="', this.getSvgStyles(),&#13;
        '" transform="', this.getSvgTransform(),&#13;
        this.getSvgTransformMatrix(),&#13;
        '"/&gt;\n'&#13;
      );&#13;
&#13;
      return reviver ? reviver(markup.join('')) : markup.join('');&#13;
    },&#13;
    /* _TO_SVG_END_ */&#13;
  });&#13;
&#13;
  /* _FROM_SVG_START_ */&#13;
  /**&#13;
   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Line.fromElement})&#13;
   * @static&#13;
   * @memberOf fabric.Line&#13;
   * @see http://www.w3.org/TR/SVG/shapes.html#LineElement&#13;
   */&#13;
  fabric.Line.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('x1 y1 x2 y2'.split(' '));&#13;
&#13;
  /**&#13;
   * Returns fabric.Line instance from an SVG element&#13;
   * @static&#13;
   * @memberOf fabric.Line&#13;
   * @param {SVGElement} element Element to parse&#13;
   * @param {Object} [options] Options object&#13;
   * @param {Function} [callback] callback function invoked after parsing&#13;
   */&#13;
  fabric.Line.fromElement = function(element, callback, options) {&#13;
    options = options || { };&#13;
    var parsedAttributes = fabric.parseAttributes(element, fabric.Line.ATTRIBUTE_NAMES),&#13;
        points = [&#13;
          parsedAttributes.x1 || 0,&#13;
          parsedAttributes.y1 || 0,&#13;
          parsedAttributes.x2 || 0,&#13;
          parsedAttributes.y2 || 0&#13;
        ];&#13;
    callback(new fabric.Line(points, extend(parsedAttributes, options)));&#13;
  };&#13;
  /* _FROM_SVG_END_ */&#13;
&#13;
  /**&#13;
   * Returns fabric.Line instance from an object representation&#13;
   * @static&#13;
   * @memberOf fabric.Line&#13;
   * @param {Object} object Object to create an instance from&#13;
   * @param {function} [callback] invoked with new instance as first argument&#13;
   */&#13;
  fabric.Line.fromObject = function(object, callback) {&#13;
    function _callback(instance) {&#13;
      delete instance.points;&#13;
      callback &amp;&amp; callback(instance);&#13;
    };&#13;
    var options = clone(object, true);&#13;
    options.points = [object.x1, object.y1, object.x2, object.y2];&#13;
    fabric.Object._fromObject('Line', options, _callback, 'points');&#13;
  };&#13;
&#13;
  /**&#13;
   * Produces a function that calculates distance from canvas edge to Line origin.&#13;
   */&#13;
  function makeEdgeToOriginGetter(propertyNames, originValues) {&#13;
    var origin = propertyNames.origin,&#13;
        axis1 = propertyNames.axis1,&#13;
        axis2 = propertyNames.axis2,&#13;
        dimension = propertyNames.dimension,&#13;
        nearest = originValues.nearest,&#13;
        center = originValues.center,&#13;
        farthest = originValues.farthest;&#13;
&#13;
    return function() {&#13;
      switch (this.get(origin)) {&#13;
        case nearest:&#13;
          return Math.min(this.get(axis1), this.get(axis2));&#13;
        case center:&#13;
          return Math.min(this.get(axis1), this.get(axis2)) + (0.5 * this.get(dimension));&#13;
        case farthest:&#13;
          return Math.max(this.get(axis1), this.get(axis2));&#13;
      }&#13;
    };&#13;
&#13;
  }&#13;
&#13;
})(typeof exports !== 'undefined' ? exports : this);&#13;
&#13;
&#13;
(function(global) {&#13;
&#13;
  'use strict';&#13;
&#13;
  var fabric = global.fabric || (global.fabric = { }),&#13;
      pi = Math.PI,&#13;
      extend = fabric.util.object.extend;&#13;
&#13;
  if (fabric.Circle) {&#13;
    fabric.warn('fabric.Circle is already defined.');&#13;
    return;&#13;
  }&#13;
&#13;
  /**&#13;
   * Circle class&#13;
   * @class fabric.Circle&#13;
   * @extends fabric.Object&#13;
   * @see {@link fabric.Circle#initialize} for constructor definition&#13;
   */&#13;
  fabric.Circle = fabric.util.createClass(fabric.Object, /** @lends fabric.Circle.prototype */ {&#13;
&#13;
    /**&#13;
     * Type of an object&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    type: 'circle',&#13;
&#13;
    /**&#13;
     * Radius of this circle&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    radius: 0,&#13;
&#13;
    /**&#13;
     * Start angle of the circle, moving clockwise&#13;
     * @type Number&#13;
     * @default 0&#13;
     */&#13;
    startAngle: 0,&#13;
&#13;
    /**&#13;
     * End angle of the circle&#13;
     * @type Number&#13;
     * @default 2Pi&#13;
     */&#13;
    endAngle: pi * 2,&#13;
&#13;
    cacheProperties: fabric.Object.prototype.cacheProperties.concat('radius'),&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {String} key&#13;
     * @param {*} value&#13;
     * @return {fabric.Circle} thisArg&#13;
     */&#13;
    _set: function(key, value) {&#13;
      this.callSuper('_set', key, value);&#13;
&#13;
      if (key === 'radius') {&#13;
        this.setRadius(value);&#13;
      }&#13;
&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns object representation of an instance&#13;
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output&#13;
     * @return {Object} object representation of an instance&#13;
     */&#13;
    toObject: function(propertiesToInclude) {&#13;
      return this.callSuper('toObject', ['radius', 'startAngle', 'endAngle'].concat(propertiesToInclude));&#13;
    },&#13;
&#13;
    /* _TO_SVG_START_ */&#13;
    /**&#13;
     * Returns svg representation of an instance&#13;
     * @param {Function} [reviver] Method for further parsing of svg representation.&#13;
     * @return {String} svg representation of an instance&#13;
     */&#13;
    toSVG: function(reviver) {&#13;
      var markup = this._createBaseSVGMarkup(), x = 0, y = 0,&#13;
          angle = (this.endAngle - this.startAngle) % ( 2 * pi);&#13;
&#13;
      if (angle === 0) {&#13;
        markup.push(&#13;
          '&lt;circle ', this.getSvgId(),&#13;
          'cx="' + x + '" cy="' + y + '" ',&#13;
          'r="', this.radius,&#13;
          '" style="', this.getSvgStyles(),&#13;
          '" transform="', this.getSvgTransform(),&#13;
          ' ', this.getSvgTransformMatrix(), '"',&#13;
          this.addPaintOrder(),&#13;
          '/&gt;\n'&#13;
        );&#13;
      }&#13;
      else {&#13;
        var startX = Math.cos(this.startAngle) * this.radius,&#13;
            startY = Math.sin(this.startAngle) * this.radius,&#13;
            endX = Math.cos(this.endAngle) * this.radius,&#13;
            endY = Math.sin(this.endAngle) * this.radius,&#13;
            largeFlag = angle &gt; pi ? '1' : '0';&#13;
&#13;
        markup.push(&#13;
          '&lt;path d="M ' + startX + ' ' + startY,&#13;
          ' A ' + this.radius + ' ' + this.radius,&#13;
          ' 0 ', +largeFlag + ' 1', ' ' + endX + ' ' + endY,&#13;
          '" style="', this.getSvgStyles(),&#13;
          '" transform="', this.getSvgTransform(),&#13;
          ' ', this.getSvgTransformMatrix(), '"',&#13;
          this.addPaintOrder(),&#13;
          '"/&gt;\n'&#13;
        );&#13;
      }&#13;
&#13;
      return reviver ? reviver(markup.join('')) : markup.join('');&#13;
    },&#13;
    /* _TO_SVG_END_ */&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {CanvasRenderingContext2D} ctx context to render on&#13;
     */&#13;
    _render: function(ctx) {&#13;
      ctx.beginPath();&#13;
      ctx.arc(&#13;
        0,&#13;
        0,&#13;
        this.radius,&#13;
        this.startAngle,&#13;
        this.endAngle, false);&#13;
      this._renderPaintInOrder(ctx);&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns horizontal radius of an object (according to how an object is scaled)&#13;
     * @return {Number}&#13;
     */&#13;
    getRadiusX: function() {&#13;
      return this.get('radius') * this.get('scaleX');&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns vertical radius of an object (according to how an object is scaled)&#13;
     * @return {Number}&#13;
     */&#13;
    getRadiusY: function() {&#13;
      return this.get('radius') * this.get('scaleY');&#13;
    },&#13;
&#13;
    /**&#13;
     * Sets radius of an object (and updates width accordingly)&#13;
     * @return {fabric.Circle} thisArg&#13;
     */&#13;
    setRadius: function(value) {&#13;
      this.radius = value;&#13;
      return this.set('width', value * 2).set('height', value * 2);&#13;
    },&#13;
  });&#13;
&#13;
  /* _FROM_SVG_START_ */&#13;
  /**&#13;
   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Circle.fromElement})&#13;
   * @static&#13;
   * @memberOf fabric.Circle&#13;
   * @see: http://www.w3.org/TR/SVG/shapes.html#CircleElement&#13;
   */&#13;
  fabric.Circle.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('cx cy r'.split(' '));&#13;
&#13;
  /**&#13;
   * Returns {@link fabric.Circle} instance from an SVG element&#13;
   * @static&#13;
   * @memberOf fabric.Circle&#13;
   * @param {SVGElement} element Element to parse&#13;
   * @param {Object} [options] Options object&#13;
   * @param {Function} [callback] Options callback invoked after parsing is finished&#13;
   * @throws {Error} If value of `r` attribute is missing or invalid&#13;
   */&#13;
  fabric.Circle.fromElement = function(element, callback, options) {&#13;
    options || (options = { });&#13;
&#13;
    var parsedAttributes = fabric.parseAttributes(element, fabric.Circle.ATTRIBUTE_NAMES);&#13;
&#13;
    if (!isValidRadius(parsedAttributes)) {&#13;
      throw new Error('value of `r` attribute is required and can not be negative');&#13;
    }&#13;
&#13;
    parsedAttributes.left = (parsedAttributes.left || 0) - parsedAttributes.radius;&#13;
    parsedAttributes.top = (parsedAttributes.top || 0) - parsedAttributes.radius;&#13;
    callback(new fabric.Circle(extend(parsedAttributes, options)));&#13;
  };&#13;
&#13;
  /**&#13;
   * @private&#13;
   */&#13;
  function isValidRadius(attributes) {&#13;
    return (('radius' in attributes) &amp;&amp; (attributes.radius &gt;= 0));&#13;
  }&#13;
  /* _FROM_SVG_END_ */&#13;
&#13;
  /**&#13;
   * Returns {@link fabric.Circle} instance from an object representation&#13;
   * @static&#13;
   * @memberOf fabric.Circle&#13;
   * @param {Object} object Object to create an instance from&#13;
   * @param {function} [callback] invoked with new instance as first argument&#13;
   * @return {Object} Instance of fabric.Circle&#13;
   */&#13;
  fabric.Circle.fromObject = function(object, callback) {&#13;
    return fabric.Object._fromObject('Circle', object, callback);&#13;
  };&#13;
&#13;
})(typeof exports !== 'undefined' ? exports : this);&#13;
&#13;
&#13;
(function(global) {&#13;
&#13;
  'use strict';&#13;
&#13;
  var fabric = global.fabric || (global.fabric = { });&#13;
&#13;
  if (fabric.Triangle) {&#13;
    fabric.warn('fabric.Triangle is already defined');&#13;
    return;&#13;
  }&#13;
&#13;
  /**&#13;
   * Triangle class&#13;
   * @class fabric.Triangle&#13;
   * @extends fabric.Object&#13;
   * @return {fabric.Triangle} thisArg&#13;
   * @see {@link fabric.Triangle#initialize} for constructor definition&#13;
   */&#13;
  fabric.Triangle = fabric.util.createClass(fabric.Object, /** @lends fabric.Triangle.prototype */ {&#13;
&#13;
    /**&#13;
     * Type of an object&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    type: 'triangle',&#13;
&#13;
    /**&#13;
     * Width is set to 100 to compensate the old initialize code that was setting it to 100&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    width: 100,&#13;
&#13;
    /**&#13;
     * Height is set to 100 to compensate the old initialize code that was setting it to 100&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    height: 100,&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     */&#13;
    _render: function(ctx) {&#13;
      var widthBy2 = this.width / 2,&#13;
          heightBy2 = this.height / 2;&#13;
&#13;
      ctx.beginPath();&#13;
      ctx.moveTo(-widthBy2, heightBy2);&#13;
      ctx.lineTo(0, -heightBy2);&#13;
      ctx.lineTo(widthBy2, heightBy2);&#13;
      ctx.closePath();&#13;
&#13;
      this._renderPaintInOrder(ctx);&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     */&#13;
    _renderDashedStroke: function(ctx) {&#13;
      var widthBy2 = this.width / 2,&#13;
          heightBy2 = this.height / 2;&#13;
&#13;
      ctx.beginPath();&#13;
      fabric.util.drawDashedLine(ctx, -widthBy2, heightBy2, 0, -heightBy2, this.strokeDashArray);&#13;
      fabric.util.drawDashedLine(ctx, 0, -heightBy2, widthBy2, heightBy2, this.strokeDashArray);&#13;
      fabric.util.drawDashedLine(ctx, widthBy2, heightBy2, -widthBy2, heightBy2, this.strokeDashArray);&#13;
      ctx.closePath();&#13;
    },&#13;
&#13;
    /* _TO_SVG_START_ */&#13;
    /**&#13;
     * Returns SVG representation of an instance&#13;
     * @param {Function} [reviver] Method for further parsing of svg representation.&#13;
     * @return {String} svg representation of an instance&#13;
     */&#13;
    toSVG: function(reviver) {&#13;
      var markup = this._createBaseSVGMarkup(),&#13;
          widthBy2 = this.width / 2,&#13;
          heightBy2 = this.height / 2,&#13;
          points = [&#13;
            -widthBy2 + ' ' + heightBy2,&#13;
            '0 ' + -heightBy2,&#13;
            widthBy2 + ' ' + heightBy2&#13;
          ]&#13;
            .join(',');&#13;
&#13;
      markup.push(&#13;
        '&lt;polygon ', this.getSvgId(),&#13;
        'points="', points,&#13;
        '" style="', this.getSvgStyles(),&#13;
        '" transform="', this.getSvgTransform(), '"',&#13;
        this.addPaintOrder(),&#13;
        '/&gt;'&#13;
      );&#13;
&#13;
      return reviver ? reviver(markup.join('')) : markup.join('');&#13;
    },&#13;
    /* _TO_SVG_END_ */&#13;
  });&#13;
&#13;
  /**&#13;
   * Returns {@link fabric.Triangle} instance from an object representation&#13;
   * @static&#13;
   * @memberOf fabric.Triangle&#13;
   * @param {Object} object Object to create an instance from&#13;
   * @param {function} [callback] invoked with new instance as first argument&#13;
   */&#13;
  fabric.Triangle.fromObject = function(object, callback) {&#13;
    return fabric.Object._fromObject('Triangle', object, callback);&#13;
  };&#13;
&#13;
})(typeof exports !== 'undefined' ? exports : this);&#13;
&#13;
&#13;
(function(global) {&#13;
&#13;
  'use strict';&#13;
&#13;
  var fabric = global.fabric || (global.fabric = { }),&#13;
      piBy2   = Math.PI * 2,&#13;
      extend = fabric.util.object.extend;&#13;
&#13;
  if (fabric.Ellipse) {&#13;
    fabric.warn('fabric.Ellipse is already defined.');&#13;
    return;&#13;
  }&#13;
&#13;
  /**&#13;
   * Ellipse class&#13;
   * @class fabric.Ellipse&#13;
   * @extends fabric.Object&#13;
   * @return {fabric.Ellipse} thisArg&#13;
   * @see {@link fabric.Ellipse#initialize} for constructor definition&#13;
   */&#13;
  fabric.Ellipse = fabric.util.createClass(fabric.Object, /** @lends fabric.Ellipse.prototype */ {&#13;
&#13;
    /**&#13;
     * Type of an object&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    type: 'ellipse',&#13;
&#13;
    /**&#13;
     * Horizontal radius&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    rx:   0,&#13;
&#13;
    /**&#13;
     * Vertical radius&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    ry:   0,&#13;
&#13;
    cacheProperties: fabric.Object.prototype.cacheProperties.concat('rx', 'ry'),&#13;
&#13;
    /**&#13;
     * Constructor&#13;
     * @param {Object} [options] Options object&#13;
     * @return {fabric.Ellipse} thisArg&#13;
     */&#13;
    initialize: function(options) {&#13;
      this.callSuper('initialize', options);&#13;
      this.set('rx', options &amp;&amp; options.rx || 0);&#13;
      this.set('ry', options &amp;&amp; options.ry || 0);&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {String} key&#13;
     * @param {*} value&#13;
     * @return {fabric.Ellipse} thisArg&#13;
     */&#13;
    _set: function(key, value) {&#13;
      this.callSuper('_set', key, value);&#13;
      switch (key) {&#13;
&#13;
        case 'rx':&#13;
          this.rx = value;&#13;
          this.set('width', value * 2);&#13;
          break;&#13;
&#13;
        case 'ry':&#13;
          this.ry = value;&#13;
          this.set('height', value * 2);&#13;
          break;&#13;
&#13;
      }&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns horizontal radius of an object (according to how an object is scaled)&#13;
     * @return {Number}&#13;
     */&#13;
    getRx: function() {&#13;
      return this.get('rx') * this.get('scaleX');&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns Vertical radius of an object (according to how an object is scaled)&#13;
     * @return {Number}&#13;
     */&#13;
    getRy: function() {&#13;
      return this.get('ry') * this.get('scaleY');&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns object representation of an instance&#13;
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output&#13;
     * @return {Object} object representation of an instance&#13;
     */&#13;
    toObject: function(propertiesToInclude) {&#13;
      return this.callSuper('toObject', ['rx', 'ry'].concat(propertiesToInclude));&#13;
    },&#13;
&#13;
    /* _TO_SVG_START_ */&#13;
    /**&#13;
     * Returns svg representation of an instance&#13;
     * @param {Function} [reviver] Method for further parsing of svg representation.&#13;
     * @return {String} svg representation of an instance&#13;
     */&#13;
    toSVG: function(reviver) {&#13;
      var markup = this._createBaseSVGMarkup();&#13;
      markup.push(&#13;
        '&lt;ellipse ', this.getSvgId(),&#13;
        'cx="0" cy="0" ',&#13;
        'rx="', this.rx,&#13;
        '" ry="', this.ry,&#13;
        '" style="', this.getSvgStyles(),&#13;
        '" transform="', this.getSvgTransform(),&#13;
        this.getSvgTransformMatrix(), '"',&#13;
        this.addPaintOrder(),&#13;
        '/&gt;\n'&#13;
      );&#13;
&#13;
      return reviver ? reviver(markup.join('')) : markup.join('');&#13;
    },&#13;
    /* _TO_SVG_END_ */&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {CanvasRenderingContext2D} ctx context to render on&#13;
     */&#13;
    _render: function(ctx) {&#13;
      ctx.beginPath();&#13;
      ctx.save();&#13;
      ctx.transform(1, 0, 0, this.ry / this.rx, 0, 0);&#13;
      ctx.arc(&#13;
        0,&#13;
        0,&#13;
        this.rx,&#13;
        0,&#13;
        piBy2,&#13;
        false);&#13;
      ctx.restore();&#13;
      this._renderPaintInOrder(ctx);&#13;
    },&#13;
  });&#13;
&#13;
  /* _FROM_SVG_START_ */&#13;
  /**&#13;
   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Ellipse.fromElement})&#13;
   * @static&#13;
   * @memberOf fabric.Ellipse&#13;
   * @see http://www.w3.org/TR/SVG/shapes.html#EllipseElement&#13;
   */&#13;
  fabric.Ellipse.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('cx cy rx ry'.split(' '));&#13;
&#13;
  /**&#13;
   * Returns {@link fabric.Ellipse} instance from an SVG element&#13;
   * @static&#13;
   * @memberOf fabric.Ellipse&#13;
   * @param {SVGElement} element Element to parse&#13;
   * @param {Object} [options] Options object&#13;
   * @param {Function} [callback] Options callback invoked after parsing is finished&#13;
   * @return {fabric.Ellipse}&#13;
   */&#13;
  fabric.Ellipse.fromElement = function(element, callback, options) {&#13;
    options || (options = { });&#13;
&#13;
    var parsedAttributes = fabric.parseAttributes(element, fabric.Ellipse.ATTRIBUTE_NAMES);&#13;
&#13;
    parsedAttributes.left = (parsedAttributes.left || 0) - parsedAttributes.rx;&#13;
    parsedAttributes.top = (parsedAttributes.top || 0) - parsedAttributes.ry;&#13;
    callback(new fabric.Ellipse(extend(parsedAttributes, options)));&#13;
  };&#13;
  /* _FROM_SVG_END_ */&#13;
&#13;
  /**&#13;
   * Returns {@link fabric.Ellipse} instance from an object representation&#13;
   * @static&#13;
   * @memberOf fabric.Ellipse&#13;
   * @param {Object} object Object to create an instance from&#13;
   * @param {function} [callback] invoked with new instance as first argument&#13;
   * @return {fabric.Ellipse}&#13;
   */&#13;
  fabric.Ellipse.fromObject = function(object, callback) {&#13;
    return fabric.Object._fromObject('Ellipse', object, callback);&#13;
  };&#13;
&#13;
})(typeof exports !== 'undefined' ? exports : this);&#13;
&#13;
&#13;
(function(global) {&#13;
&#13;
  'use strict';&#13;
&#13;
  var fabric = global.fabric || (global.fabric = { }),&#13;
      extend = fabric.util.object.extend;&#13;
&#13;
  if (fabric.Rect) {&#13;
    fabric.warn('fabric.Rect is already defined');&#13;
    return;&#13;
  }&#13;
&#13;
  /**&#13;
   * Rectangle class&#13;
   * @class fabric.Rect&#13;
   * @extends fabric.Object&#13;
   * @return {fabric.Rect} thisArg&#13;
   * @see {@link fabric.Rect#initialize} for constructor definition&#13;
   */&#13;
  fabric.Rect = fabric.util.createClass(fabric.Object, /** @lends fabric.Rect.prototype */ {&#13;
&#13;
    /**&#13;
     * List of properties to consider when checking if state of an object is changed ({@link fabric.Object#hasStateChanged})&#13;
     * as well as for history (undo/redo) purposes&#13;
     * @type Array&#13;
     */&#13;
    stateProperties: fabric.Object.prototype.stateProperties.concat('rx', 'ry'),&#13;
&#13;
    /**&#13;
     * Type of an object&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    type: 'rect',&#13;
&#13;
    /**&#13;
     * Horizontal border radius&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    rx:   0,&#13;
&#13;
    /**&#13;
     * Vertical border radius&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    ry:   0,&#13;
&#13;
    cacheProperties: fabric.Object.prototype.cacheProperties.concat('rx', 'ry'),&#13;
&#13;
    /**&#13;
     * Constructor&#13;
     * @param {Object} [options] Options object&#13;
     * @return {Object} thisArg&#13;
     */&#13;
    initialize: function(options) {&#13;
      this.callSuper('initialize', options);&#13;
      this._initRxRy();&#13;
    },&#13;
&#13;
    /**&#13;
     * Initializes rx/ry attributes&#13;
     * @private&#13;
     */&#13;
    _initRxRy: function() {&#13;
      if (this.rx &amp;&amp; !this.ry) {&#13;
        this.ry = this.rx;&#13;
      }&#13;
      else if (this.ry &amp;&amp; !this.rx) {&#13;
        this.rx = this.ry;&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     */&#13;
    _render: function(ctx) {&#13;
&#13;
      // optimize 1x1 case (used in spray brush)&#13;
      if (this.width === 1 &amp;&amp; this.height === 1) {&#13;
        ctx.fillRect(-0.5, -0.5, 1, 1);&#13;
        return;&#13;
      }&#13;
&#13;
      var rx = this.rx ? Math.min(this.rx, this.width / 2) : 0,&#13;
          ry = this.ry ? Math.min(this.ry, this.height / 2) : 0,&#13;
          w = this.width,&#13;
          h = this.height,&#13;
          x = -this.width / 2,&#13;
          y = -this.height / 2,&#13;
          isRounded = rx !== 0 || ry !== 0,&#13;
          /* "magic number" for bezier approximations of arcs (http://itc.ktu.lt/itc354/Riskus354.pdf) */&#13;
          k = 1 - 0.5522847498;&#13;
      ctx.beginPath();&#13;
&#13;
      ctx.moveTo(x + rx, y);&#13;
&#13;
      ctx.lineTo(x + w - rx, y);&#13;
      isRounded &amp;&amp; ctx.bezierCurveTo(x + w - k * rx, y, x + w, y + k * ry, x + w, y + ry);&#13;
&#13;
      ctx.lineTo(x + w, y + h - ry);&#13;
      isRounded &amp;&amp; ctx.bezierCurveTo(x + w, y + h - k * ry, x + w - k * rx, y + h, x + w - rx, y + h);&#13;
&#13;
      ctx.lineTo(x + rx, y + h);&#13;
      isRounded &amp;&amp; ctx.bezierCurveTo(x + k * rx, y + h, x, y + h - k * ry, x, y + h - ry);&#13;
&#13;
      ctx.lineTo(x, y + ry);&#13;
      isRounded &amp;&amp; ctx.bezierCurveTo(x, y + k * ry, x + k * rx, y, x + rx, y);&#13;
&#13;
      ctx.closePath();&#13;
&#13;
      this._renderPaintInOrder(ctx);&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     */&#13;
    _renderDashedStroke: function(ctx) {&#13;
      var x = -this.width / 2,&#13;
          y = -this.height / 2,&#13;
          w = this.width,&#13;
          h = this.height;&#13;
&#13;
      ctx.beginPath();&#13;
      fabric.util.drawDashedLine(ctx, x, y, x + w, y, this.strokeDashArray);&#13;
      fabric.util.drawDashedLine(ctx, x + w, y, x + w, y + h, this.strokeDashArray);&#13;
      fabric.util.drawDashedLine(ctx, x + w, y + h, x, y + h, this.strokeDashArray);&#13;
      fabric.util.drawDashedLine(ctx, x, y + h, x, y, this.strokeDashArray);&#13;
      ctx.closePath();&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns object representation of an instance&#13;
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output&#13;
     * @return {Object} object representation of an instance&#13;
     */&#13;
    toObject: function(propertiesToInclude) {&#13;
      return this.callSuper('toObject', ['rx', 'ry'].concat(propertiesToInclude));&#13;
    },&#13;
&#13;
    /* _TO_SVG_START_ */&#13;
    /**&#13;
     * Returns svg representation of an instance&#13;
     * @param {Function} [reviver] Method for further parsing of svg representation.&#13;
     * @return {String} svg representation of an instance&#13;
     */&#13;
    toSVG: function(reviver) {&#13;
      var markup = this._createBaseSVGMarkup(), x = -this.width / 2, y = -this.height / 2;&#13;
      markup.push(&#13;
        '&lt;rect ', this.getSvgId(),&#13;
        'x="', x, '" y="', y,&#13;
        '" rx="', this.get('rx'), '" ry="', this.get('ry'),&#13;
        '" width="', this.width, '" height="', this.height,&#13;
        '" style="', this.getSvgStyles(),&#13;
        '" transform="', this.getSvgTransform(),&#13;
        this.getSvgTransformMatrix(), '"',&#13;
        this.addPaintOrder(),&#13;
        '/&gt;\n');&#13;
&#13;
      return reviver ? reviver(markup.join('')) : markup.join('');&#13;
    },&#13;
    /* _TO_SVG_END_ */&#13;
  });&#13;
&#13;
  /* _FROM_SVG_START_ */&#13;
  /**&#13;
   * List of attribute names to account for when parsing SVG element (used by `fabric.Rect.fromElement`)&#13;
   * @static&#13;
   * @memberOf fabric.Rect&#13;
   * @see: http://www.w3.org/TR/SVG/shapes.html#RectElement&#13;
   */&#13;
  fabric.Rect.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('x y rx ry width height'.split(' '));&#13;
&#13;
  /**&#13;
   * Returns {@link fabric.Rect} instance from an SVG element&#13;
   * @static&#13;
   * @memberOf fabric.Rect&#13;
   * @param {SVGElement} element Element to parse&#13;
   * @param {Function} callback callback function invoked after parsing&#13;
   * @param {Object} [options] Options object&#13;
   */&#13;
  fabric.Rect.fromElement = function(element, callback, options) {&#13;
    if (!element) {&#13;
      return callback(null);&#13;
    }&#13;
    options = options || { };&#13;
&#13;
    var parsedAttributes = fabric.parseAttributes(element, fabric.Rect.ATTRIBUTE_NAMES);&#13;
&#13;
    parsedAttributes.left = parsedAttributes.left || 0;&#13;
    parsedAttributes.top  = parsedAttributes.top  || 0;&#13;
    var rect = new fabric.Rect(extend((options ? fabric.util.object.clone(options) : { }), parsedAttributes));&#13;
    rect.visible = rect.visible &amp;&amp; rect.width &gt; 0 &amp;&amp; rect.height &gt; 0;&#13;
    callback(rect);&#13;
  };&#13;
  /* _FROM_SVG_END_ */&#13;
&#13;
  /**&#13;
   * Returns {@link fabric.Rect} instance from an object representation&#13;
   * @static&#13;
   * @memberOf fabric.Rect&#13;
   * @param {Object} object Object to create an instance from&#13;
   * @param {Function} [callback] Callback to invoke when an fabric.Rect instance is created&#13;
   */&#13;
  fabric.Rect.fromObject = function(object, callback) {&#13;
    return fabric.Object._fromObject('Rect', object, callback);&#13;
  };&#13;
&#13;
})(typeof exports !== 'undefined' ? exports : this);&#13;
&#13;
&#13;
(function(global) {&#13;
&#13;
  'use strict';&#13;
&#13;
  var fabric = global.fabric || (global.fabric = { }),&#13;
      extend = fabric.util.object.extend,&#13;
      min = fabric.util.array.min,&#13;
      max = fabric.util.array.max,&#13;
      toFixed = fabric.util.toFixed,&#13;
      NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;&#13;
&#13;
  if (fabric.Polyline) {&#13;
    fabric.warn('fabric.Polyline is already defined');&#13;
    return;&#13;
  }&#13;
&#13;
  /**&#13;
   * Polyline class&#13;
   * @class fabric.Polyline&#13;
   * @extends fabric.Object&#13;
   * @see {@link fabric.Polyline#initialize} for constructor definition&#13;
   */&#13;
  fabric.Polyline = fabric.util.createClass(fabric.Object, /** @lends fabric.Polyline.prototype */ {&#13;
&#13;
    /**&#13;
     * Type of an object&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    type: 'polyline',&#13;
&#13;
    /**&#13;
     * Points array&#13;
     * @type Array&#13;
     * @default&#13;
     */&#13;
    points: null,&#13;
&#13;
    cacheProperties: fabric.Object.prototype.cacheProperties.concat('points'),&#13;
&#13;
    /**&#13;
     * Constructor&#13;
     * @param {Array} points Array of points (where each point is an object with x and y)&#13;
     * @param {Object} [options] Options object&#13;
     * @return {fabric.Polyline} thisArg&#13;
     * @example&#13;
     * var poly = new fabric.Polyline([&#13;
     *     { x: 10, y: 10 },&#13;
     *     { x: 50, y: 30 },&#13;
     *     { x: 40, y: 70 },&#13;
     *     { x: 60, y: 50 },&#13;
     *     { x: 100, y: 150 },&#13;
     *     { x: 40, y: 100 }&#13;
     *   ], {&#13;
     *   stroke: 'red',&#13;
     *   left: 100,&#13;
     *   top: 100&#13;
     * });&#13;
     */&#13;
    initialize: function(points, options) {&#13;
      options = options || {};&#13;
      this.points = points || [];&#13;
      this.callSuper('initialize', options);&#13;
      var calcDim = this._calcDimensions();&#13;
      if (typeof options.left === 'undefined') {&#13;
        this.left = calcDim.left;&#13;
      }&#13;
      if (typeof options.top === 'undefined') {&#13;
        this.top = calcDim.top;&#13;
      }&#13;
      this.width = calcDim.width;&#13;
      this.height = calcDim.height;&#13;
      this.pathOffset = {&#13;
        x: calcDim.left + this.width / 2,&#13;
        y: calcDim.top + this.height / 2&#13;
      };&#13;
    },&#13;
&#13;
    /**&#13;
     * Calculate the polygon min and max point from points array,&#13;
     * returning an object with left, top, widht, height to measure the&#13;
     * polygon size&#13;
     * @return {Object} object.left X coordinate of the polygon leftmost point&#13;
     * @return {Object} object.top Y coordinate of the polygon topmost point&#13;
     * @return {Object} object.width distance between X coordinates of the polygon leftmost and rightmost point&#13;
     * @return {Object} object.height distance between Y coordinates of the polygon topmost and bottommost point&#13;
     * @private&#13;
     */&#13;
    _calcDimensions: function() {&#13;
&#13;
      var points = this.points,&#13;
          minX = min(points, 'x') || 0,&#13;
          minY = min(points, 'y') || 0,&#13;
          maxX = max(points, 'x') || 0,&#13;
          maxY = max(points, 'y') || 0,&#13;
          width = (maxX - minX),&#13;
          height = (maxY - minY);&#13;
&#13;
      return {&#13;
        left: minX,&#13;
        top: minY,&#13;
        width: width,&#13;
        height: height&#13;
      };&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns object representation of an instance&#13;
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output&#13;
     * @return {Object} Object representation of an instance&#13;
     */&#13;
    toObject: function(propertiesToInclude) {&#13;
      return extend(this.callSuper('toObject', propertiesToInclude), {&#13;
        points: this.points.concat()&#13;
      });&#13;
    },&#13;
&#13;
    /* _TO_SVG_START_ */&#13;
    /**&#13;
     * Returns svg representation of an instance&#13;
     * @param {Function} [reviver] Method for further parsing of svg representation.&#13;
     * @return {String} svg representation of an instance&#13;
     */&#13;
    toSVG: function(reviver) {&#13;
      var points = [], diffX = this.pathOffset.x, diffY = this.pathOffset.y,&#13;
          markup = this._createBaseSVGMarkup();&#13;
&#13;
      for (var i = 0, len = this.points.length; i &lt; len; i++) {&#13;
        points.push(&#13;
          toFixed(this.points[i].x - diffX, NUM_FRACTION_DIGITS), ',',&#13;
          toFixed(this.points[i].y - diffY, NUM_FRACTION_DIGITS), ' '&#13;
        );&#13;
      }&#13;
      markup.push(&#13;
        '&lt;', this.type, ' ', this.getSvgId(),&#13;
        'points="', points.join(''),&#13;
        '" style="', this.getSvgStyles(),&#13;
        '" transform="', this.getSvgTransform(),&#13;
        ' ', this.getSvgTransformMatrix(), '"',&#13;
        this.addPaintOrder(),&#13;
        '/&gt;\n'&#13;
      );&#13;
&#13;
      return reviver ? reviver(markup.join('')) : markup.join('');&#13;
    },&#13;
    /* _TO_SVG_END_ */&#13;
&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     */&#13;
    commonRender: function(ctx) {&#13;
      var point, len = this.points.length,&#13;
          x = this.pathOffset.x,&#13;
          y = this.pathOffset.y;&#13;
&#13;
      if (!len || isNaN(this.points[len - 1].y)) {&#13;
        // do not draw if no points or odd points&#13;
        // NaN comes from parseFloat of a empty string in parser&#13;
        return false;&#13;
      }&#13;
      ctx.beginPath();&#13;
      ctx.moveTo(this.points[0].x - x, this.points[0].y - y);&#13;
      for (var i = 0; i &lt; len; i++) {&#13;
        point = this.points[i];&#13;
        ctx.lineTo(point.x - x, point.y - y);&#13;
      }&#13;
      return true;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     */&#13;
    _render: function(ctx) {&#13;
      if (!this.commonRender(ctx)) {&#13;
        return;&#13;
      }&#13;
      this._renderPaintInOrder(ctx);&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     */&#13;
    _renderDashedStroke: function(ctx) {&#13;
      var p1, p2;&#13;
&#13;
      ctx.beginPath();&#13;
      for (var i = 0, len = this.points.length; i &lt; len; i++) {&#13;
        p1 = this.points[i];&#13;
        p2 = this.points[i + 1] || p1;&#13;
        fabric.util.drawDashedLine(ctx, p1.x, p1.y, p2.x, p2.y, this.strokeDashArray);&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns complexity of an instance&#13;
     * @return {Number} complexity of this instance&#13;
     */&#13;
    complexity: function() {&#13;
      return this.get('points').length;&#13;
    }&#13;
  });&#13;
&#13;
  /* _FROM_SVG_START_ */&#13;
  /**&#13;
   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Polyline.fromElement})&#13;
   * @static&#13;
   * @memberOf fabric.Polyline&#13;
   * @see: http://www.w3.org/TR/SVG/shapes.html#PolylineElement&#13;
   */&#13;
  fabric.Polyline.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();&#13;
&#13;
  /**&#13;
   * Returns fabric.Polyline instance from an SVG element&#13;
   * @static&#13;
   * @memberOf fabric.Polyline&#13;
   * @param {SVGElement} element Element to parser&#13;
   * @param {Function} callback callback function invoked after parsing&#13;
   * @param {Object} [options] Options object&#13;
   */&#13;
  fabric.Polyline.fromElement = function(element, callback, options) {&#13;
    if (!element) {&#13;
      return callback(null);&#13;
    }&#13;
    options || (options = { });&#13;
&#13;
    var points = fabric.parsePointsAttribute(element.getAttribute('points')),&#13;
        parsedAttributes = fabric.parseAttributes(element, fabric.Polyline.ATTRIBUTE_NAMES);&#13;
&#13;
    callback(new fabric.Polyline(points, fabric.util.object.extend(parsedAttributes, options)));&#13;
  };&#13;
  /* _FROM_SVG_END_ */&#13;
&#13;
  /**&#13;
   * Returns fabric.Polyline instance from an object representation&#13;
   * @static&#13;
   * @memberOf fabric.Polyline&#13;
   * @param {Object} object Object to create an instance from&#13;
   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created&#13;
   */&#13;
  fabric.Polyline.fromObject = function(object, callback) {&#13;
    return fabric.Object._fromObject('Polyline', object, callback, 'points');&#13;
  };&#13;
&#13;
})(typeof exports !== 'undefined' ? exports : this);&#13;
&#13;
&#13;
(function(global) {&#13;
&#13;
  'use strict';&#13;
&#13;
  var fabric = global.fabric || (global.fabric = { }),&#13;
      extend = fabric.util.object.extend;&#13;
&#13;
  if (fabric.Polygon) {&#13;
    fabric.warn('fabric.Polygon is already defined');&#13;
    return;&#13;
  }&#13;
&#13;
  /**&#13;
   * Polygon class&#13;
   * @class fabric.Polygon&#13;
   * @extends fabric.Polyline&#13;
   * @see {@link fabric.Polygon#initialize} for constructor definition&#13;
   */&#13;
  fabric.Polygon = fabric.util.createClass(fabric.Polyline, /** @lends fabric.Polygon.prototype */ {&#13;
&#13;
    /**&#13;
     * Type of an object&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    type: 'polygon',&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     */&#13;
    _render: function(ctx) {&#13;
      if (!this.commonRender(ctx)) {&#13;
        return;&#13;
      }&#13;
      ctx.closePath();&#13;
      this._renderPaintInOrder(ctx);&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     */&#13;
    _renderDashedStroke: function(ctx) {&#13;
      this.callSuper('_renderDashedStroke', ctx);&#13;
      ctx.closePath();&#13;
    },&#13;
  });&#13;
&#13;
  /* _FROM_SVG_START_ */&#13;
  /**&#13;
   * List of attribute names to account for when parsing SVG element (used by `fabric.Polygon.fromElement`)&#13;
   * @static&#13;
   * @memberOf fabric.Polygon&#13;
   * @see: http://www.w3.org/TR/SVG/shapes.html#PolygonElement&#13;
   */&#13;
  fabric.Polygon.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();&#13;
&#13;
  /**&#13;
   * Returns {@link fabric.Polygon} instance from an SVG element&#13;
   * @static&#13;
   * @memberOf fabric.Polygon&#13;
   * @param {SVGElement} element Element to parse&#13;
   * @param {Function} callback callback function invoked after parsing&#13;
   * @param {Object} [options] Options object&#13;
   */&#13;
  fabric.Polygon.fromElement = function(element, callback, options) {&#13;
    if (!element) {&#13;
      return callback(null);&#13;
    }&#13;
&#13;
    options || (options = { });&#13;
&#13;
    var points = fabric.parsePointsAttribute(element.getAttribute('points')),&#13;
        parsedAttributes = fabric.parseAttributes(element, fabric.Polygon.ATTRIBUTE_NAMES);&#13;
&#13;
    callback(new fabric.Polygon(points, extend(parsedAttributes, options)));&#13;
  };&#13;
  /* _FROM_SVG_END_ */&#13;
&#13;
  /**&#13;
   * Returns fabric.Polygon instance from an object representation&#13;
   * @static&#13;
   * @memberOf fabric.Polygon&#13;
   * @param {Object} object Object to create an instance from&#13;
   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created&#13;
   */&#13;
  fabric.Polygon.fromObject = function(object, callback) {&#13;
    return fabric.Object._fromObject('Polygon', object, callback, 'points');&#13;
  };&#13;
&#13;
})(typeof exports !== 'undefined' ? exports : this);&#13;
&#13;
&#13;
(function(global) {&#13;
&#13;
  'use strict';&#13;
&#13;
  var fabric = global.fabric || (global.fabric = { }),&#13;
      min = fabric.util.array.min,&#13;
      max = fabric.util.array.max,&#13;
      extend = fabric.util.object.extend,&#13;
      _toString = Object.prototype.toString,&#13;
      drawArc = fabric.util.drawArc,&#13;
      commandLengths = {&#13;
        m: 2,&#13;
        l: 2,&#13;
        h: 1,&#13;
        v: 1,&#13;
        c: 6,&#13;
        s: 4,&#13;
        q: 4,&#13;
        t: 2,&#13;
        a: 7&#13;
      },&#13;
      repeatedCommands = {&#13;
        m: 'l',&#13;
        M: 'L'&#13;
      };&#13;
&#13;
  if (fabric.Path) {&#13;
    fabric.warn('fabric.Path is already defined');&#13;
    return;&#13;
  }&#13;
&#13;
  /**&#13;
   * Path class&#13;
   * @class fabric.Path&#13;
   * @extends fabric.Object&#13;
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#path_and_pathgroup}&#13;
   * @see {@link fabric.Path#initialize} for constructor definition&#13;
   */&#13;
  fabric.Path = fabric.util.createClass(fabric.Object, /** @lends fabric.Path.prototype */ {&#13;
&#13;
    /**&#13;
     * Type of an object&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    type: 'path',&#13;
&#13;
    /**&#13;
     * Array of path points&#13;
     * @type Array&#13;
     * @default&#13;
     */&#13;
    path: null,&#13;
&#13;
    cacheProperties: fabric.Object.prototype.cacheProperties.concat('path', 'fillRule'),&#13;
&#13;
    stateProperties: fabric.Object.prototype.stateProperties.concat('path'),&#13;
&#13;
    /**&#13;
     * Constructor&#13;
     * @param {Array|String} path Path data (sequence of coordinates and corresponding "command" tokens)&#13;
     * @param {Object} [options] Options object&#13;
     * @return {fabric.Path} thisArg&#13;
     */&#13;
    initialize: function(path, options) {&#13;
      options = options || { };&#13;
      this.callSuper('initialize', options);&#13;
&#13;
      if (!path) {&#13;
        path = [];&#13;
      }&#13;
&#13;
      var fromArray = _toString.call(path) === '[object Array]';&#13;
&#13;
      this.path = fromArray&#13;
        ? path&#13;
        // one of commands (m,M,l,L,q,Q,c,C,etc.) followed by non-command characters (i.e. command values)&#13;
        : path.match &amp;&amp; path.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);&#13;
&#13;
      if (!this.path) {&#13;
        return;&#13;
      }&#13;
&#13;
      if (!fromArray) {&#13;
        this.path = this._parsePath();&#13;
      }&#13;
&#13;
      this._setPositionDimensions(options);&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Object} options Options object&#13;
     */&#13;
    _setPositionDimensions: function(options) {&#13;
      var calcDim = this._parseDimensions();&#13;
&#13;
      this.width = calcDim.width;&#13;
      this.height = calcDim.height;&#13;
&#13;
      if (typeof options.left === 'undefined') {&#13;
        this.left = calcDim.left;&#13;
      }&#13;
&#13;
      if (typeof options.top === 'undefined') {&#13;
        this.top = calcDim.top;&#13;
      }&#13;
&#13;
      this.pathOffset = this.pathOffset || {&#13;
        x: calcDim.left + this.width / 2,&#13;
        y: calcDim.top + this.height / 2&#13;
      };&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {CanvasRenderingContext2D} ctx context to render path on&#13;
     */&#13;
    _renderPathCommands: function(ctx) {&#13;
      var current, // current instruction&#13;
          previous = null,&#13;
          subpathStartX = 0,&#13;
          subpathStartY = 0,&#13;
          x = 0, // current x&#13;
          y = 0, // current y&#13;
          controlX = 0, // current control point x&#13;
          controlY = 0, // current control point y&#13;
          tempX,&#13;
          tempY,&#13;
          l = -this.pathOffset.x,&#13;
          t = -this.pathOffset.y;&#13;
&#13;
      ctx.beginPath();&#13;
&#13;
      for (var i = 0, len = this.path.length; i &lt; len; ++i) {&#13;
&#13;
        current = this.path[i];&#13;
&#13;
        switch (current[0]) { // first letter&#13;
&#13;
          case 'l': // lineto, relative&#13;
            x += current[1];&#13;
            y += current[2];&#13;
            ctx.lineTo(x + l, y + t);&#13;
            break;&#13;
&#13;
          case 'L': // lineto, absolute&#13;
            x = current[1];&#13;
            y = current[2];&#13;
            ctx.lineTo(x + l, y + t);&#13;
            break;&#13;
&#13;
          case 'h': // horizontal lineto, relative&#13;
            x += current[1];&#13;
            ctx.lineTo(x + l, y + t);&#13;
            break;&#13;
&#13;
          case 'H': // horizontal lineto, absolute&#13;
            x = current[1];&#13;
            ctx.lineTo(x + l, y + t);&#13;
            break;&#13;
&#13;
          case 'v': // vertical lineto, relative&#13;
            y += current[1];&#13;
            ctx.lineTo(x + l, y + t);&#13;
            break;&#13;
&#13;
          case 'V': // verical lineto, absolute&#13;
            y = current[1];&#13;
            ctx.lineTo(x + l, y + t);&#13;
            break;&#13;
&#13;
          case 'm': // moveTo, relative&#13;
            x += current[1];&#13;
            y += current[2];&#13;
            subpathStartX = x;&#13;
            subpathStartY = y;&#13;
            ctx.moveTo(x + l, y + t);&#13;
            break;&#13;
&#13;
          case 'M': // moveTo, absolute&#13;
            x = current[1];&#13;
            y = current[2];&#13;
            subpathStartX = x;&#13;
            subpathStartY = y;&#13;
            ctx.moveTo(x + l, y + t);&#13;
            break;&#13;
&#13;
          case 'c': // bezierCurveTo, relative&#13;
            tempX = x + current[5];&#13;
            tempY = y + current[6];&#13;
            controlX = x + current[3];&#13;
            controlY = y + current[4];&#13;
            ctx.bezierCurveTo(&#13;
              x + current[1] + l, // x1&#13;
              y + current[2] + t, // y1&#13;
              controlX + l, // x2&#13;
              controlY + t, // y2&#13;
              tempX + l,&#13;
              tempY + t&#13;
            );&#13;
            x = tempX;&#13;
            y = tempY;&#13;
            break;&#13;
&#13;
          case 'C': // bezierCurveTo, absolute&#13;
            x = current[5];&#13;
            y = current[6];&#13;
            controlX = current[3];&#13;
            controlY = current[4];&#13;
            ctx.bezierCurveTo(&#13;
              current[1] + l,&#13;
              current[2] + t,&#13;
              controlX + l,&#13;
              controlY + t,&#13;
              x + l,&#13;
              y + t&#13;
            );&#13;
            break;&#13;
&#13;
          case 's': // shorthand cubic bezierCurveTo, relative&#13;
&#13;
            // transform to absolute x,y&#13;
            tempX = x + current[3];&#13;
            tempY = y + current[4];&#13;
&#13;
            if (previous[0].match(/[CcSs]/) === null) {&#13;
              // If there is no previous command or if the previous command was not a C, c, S, or s,&#13;
              // the control point is coincident with the current point&#13;
              controlX = x;&#13;
              controlY = y;&#13;
            }&#13;
            else {&#13;
              // calculate reflection of previous control points&#13;
              controlX = 2 * x - controlX;&#13;
              controlY = 2 * y - controlY;&#13;
            }&#13;
&#13;
            ctx.bezierCurveTo(&#13;
              controlX + l,&#13;
              controlY + t,&#13;
              x + current[1] + l,&#13;
              y + current[2] + t,&#13;
              tempX + l,&#13;
              tempY + t&#13;
            );&#13;
            // set control point to 2nd one of this command&#13;
            // "... the first control point is assumed to be&#13;
            // the reflection of the second control point on&#13;
            // the previous command relative to the current point."&#13;
            controlX = x + current[1];&#13;
            controlY = y + current[2];&#13;
&#13;
            x = tempX;&#13;
            y = tempY;&#13;
            break;&#13;
&#13;
          case 'S': // shorthand cubic bezierCurveTo, absolute&#13;
            tempX = current[3];&#13;
            tempY = current[4];&#13;
            if (previous[0].match(/[CcSs]/) === null) {&#13;
              // If there is no previous command or if the previous command was not a C, c, S, or s,&#13;
              // the control point is coincident with the current point&#13;
              controlX = x;&#13;
              controlY = y;&#13;
            }&#13;
            else {&#13;
              // calculate reflection of previous control points&#13;
              controlX = 2 * x - controlX;&#13;
              controlY = 2 * y - controlY;&#13;
            }&#13;
            ctx.bezierCurveTo(&#13;
              controlX + l,&#13;
              controlY + t,&#13;
              current[1] + l,&#13;
              current[2] + t,&#13;
              tempX + l,&#13;
              tempY + t&#13;
            );&#13;
            x = tempX;&#13;
            y = tempY;&#13;
&#13;
            // set control point to 2nd one of this command&#13;
            // "... the first control point is assumed to be&#13;
            // the reflection of the second control point on&#13;
            // the previous command relative to the current point."&#13;
            controlX = current[1];&#13;
            controlY = current[2];&#13;
&#13;
            break;&#13;
&#13;
          case 'q': // quadraticCurveTo, relative&#13;
            // transform to absolute x,y&#13;
            tempX = x + current[3];&#13;
            tempY = y + current[4];&#13;
&#13;
            controlX = x + current[1];&#13;
            controlY = y + current[2];&#13;
&#13;
            ctx.quadraticCurveTo(&#13;
              controlX + l,&#13;
              controlY + t,&#13;
              tempX + l,&#13;
              tempY + t&#13;
            );&#13;
            x = tempX;&#13;
            y = tempY;&#13;
            break;&#13;
&#13;
          case 'Q': // quadraticCurveTo, absolute&#13;
            tempX = current[3];&#13;
            tempY = current[4];&#13;
&#13;
            ctx.quadraticCurveTo(&#13;
              current[1] + l,&#13;
              current[2] + t,&#13;
              tempX + l,&#13;
              tempY + t&#13;
            );&#13;
            x = tempX;&#13;
            y = tempY;&#13;
            controlX = current[1];&#13;
            controlY = current[2];&#13;
            break;&#13;
&#13;
          case 't': // shorthand quadraticCurveTo, relative&#13;
&#13;
            // transform to absolute x,y&#13;
            tempX = x + current[1];&#13;
            tempY = y + current[2];&#13;
&#13;
            if (previous[0].match(/[QqTt]/) === null) {&#13;
              // If there is no previous command or if the previous command was not a Q, q, T or t,&#13;
              // assume the control point is coincident with the current point&#13;
              controlX = x;&#13;
              controlY = y;&#13;
            }&#13;
            else {&#13;
              // calculate reflection of previous control point&#13;
              controlX = 2 * x - controlX;&#13;
              controlY = 2 * y - controlY;&#13;
            }&#13;
&#13;
            ctx.quadraticCurveTo(&#13;
              controlX + l,&#13;
              controlY + t,&#13;
              tempX + l,&#13;
              tempY + t&#13;
            );&#13;
            x = tempX;&#13;
            y = tempY;&#13;
&#13;
            break;&#13;
&#13;
          case 'T':&#13;
            tempX = current[1];&#13;
            tempY = current[2];&#13;
&#13;
            if (previous[0].match(/[QqTt]/) === null) {&#13;
              // If there is no previous command or if the previous command was not a Q, q, T or t,&#13;
              // assume the control point is coincident with the current point&#13;
              controlX = x;&#13;
              controlY = y;&#13;
            }&#13;
            else {&#13;
              // calculate reflection of previous control point&#13;
              controlX = 2 * x - controlX;&#13;
              controlY = 2 * y - controlY;&#13;
            }&#13;
            ctx.quadraticCurveTo(&#13;
              controlX + l,&#13;
              controlY + t,&#13;
              tempX + l,&#13;
              tempY + t&#13;
            );&#13;
            x = tempX;&#13;
            y = tempY;&#13;
            break;&#13;
&#13;
          case 'a':&#13;
            // TODO: optimize this&#13;
            drawArc(ctx, x + l, y + t, [&#13;
              current[1],&#13;
              current[2],&#13;
              current[3],&#13;
              current[4],&#13;
              current[5],&#13;
              current[6] + x + l,&#13;
              current[7] + y + t&#13;
            ]);&#13;
            x += current[6];&#13;
            y += current[7];&#13;
            break;&#13;
&#13;
          case 'A':&#13;
            // TODO: optimize this&#13;
            drawArc(ctx, x + l, y + t, [&#13;
              current[1],&#13;
              current[2],&#13;
              current[3],&#13;
              current[4],&#13;
              current[5],&#13;
              current[6] + l,&#13;
              current[7] + t&#13;
            ]);&#13;
            x = current[6];&#13;
            y = current[7];&#13;
            break;&#13;
&#13;
          case 'z':&#13;
          case 'Z':&#13;
            x = subpathStartX;&#13;
            y = subpathStartY;&#13;
            ctx.closePath();&#13;
            break;&#13;
        }&#13;
        previous = current;&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {CanvasRenderingContext2D} ctx context to render path on&#13;
     */&#13;
    _render: function(ctx) {&#13;
      this._renderPathCommands(ctx);&#13;
      this._renderPaintInOrder(ctx);&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns string representation of an instance&#13;
     * @return {String} string representation of an instance&#13;
     */&#13;
    toString: function() {&#13;
      return '#&lt;fabric.Path (' + this.complexity() +&#13;
        '): { "top": ' + this.top + ', "left": ' + this.left + ' }&gt;';&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns object representation of an instance&#13;
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output&#13;
     * @return {Object} object representation of an instance&#13;
     */&#13;
    toObject: function(propertiesToInclude) {&#13;
      var o = extend(this.callSuper('toObject', propertiesToInclude), {&#13;
        path: this.path.map(function(item) { return item.slice(); }),&#13;
        top: this.top,&#13;
        left: this.left,&#13;
      });&#13;
      return o;&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns dataless object representation of an instance&#13;
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output&#13;
     * @return {Object} object representation of an instance&#13;
     */&#13;
    toDatalessObject: function(propertiesToInclude) {&#13;
      var o = this.toObject(['sourcePath'].concat(propertiesToInclude));&#13;
      if (o.sourcePath) {&#13;
        delete o.path;&#13;
      }&#13;
      return o;&#13;
    },&#13;
&#13;
    /* _TO_SVG_START_ */&#13;
    /**&#13;
     * Returns svg representation of an instance&#13;
     * @param {Function} [reviver] Method for further parsing of svg representation.&#13;
     * @return {String} svg representation of an instance&#13;
     */&#13;
    toSVG: function(reviver) {&#13;
      var chunks = [],&#13;
          markup = this._createBaseSVGMarkup(), addTransform = '';&#13;
&#13;
      for (var i = 0, len = this.path.length; i &lt; len; i++) {&#13;
        chunks.push(this.path[i].join(' '));&#13;
      }&#13;
      var path = chunks.join(' ');&#13;
      addTransform = ' translate(' + (-this.pathOffset.x) + ', ' + (-this.pathOffset.y) + ') ';&#13;
      markup.push(&#13;
        '&lt;path ', this.getSvgId(),&#13;
        'd="', path,&#13;
        '" style="', this.getSvgStyles(),&#13;
        '" transform="', this.getSvgTransform(), addTransform,&#13;
        this.getSvgTransformMatrix(), '" stroke-linecap="round" ',&#13;
        this.addPaintOrder(),&#13;
        '/&gt;\n'&#13;
      );&#13;
&#13;
      return reviver ? reviver(markup.join('')) : markup.join('');&#13;
    },&#13;
    /* _TO_SVG_END_ */&#13;
&#13;
    /**&#13;
     * Returns number representation of an instance complexity&#13;
     * @return {Number} complexity of this instance&#13;
     */&#13;
    complexity: function() {&#13;
      return this.path.length;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _parsePath: function() {&#13;
      var result = [],&#13;
          coords = [],&#13;
          currentPath,&#13;
          parsed,&#13;
          re = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:e[-+]?\d+)?)/ig,&#13;
          match,&#13;
          coordsStr;&#13;
&#13;
      for (var i = 0, coordsParsed, len = this.path.length; i &lt; len; i++) {&#13;
        currentPath = this.path[i];&#13;
&#13;
        coordsStr = currentPath.slice(1).trim();&#13;
        coords.length = 0;&#13;
&#13;
        while ((match = re.exec(coordsStr))) {&#13;
          coords.push(match[0]);&#13;
        }&#13;
&#13;
        coordsParsed = [currentPath.charAt(0)];&#13;
&#13;
        for (var j = 0, jlen = coords.length; j &lt; jlen; j++) {&#13;
          parsed = parseFloat(coords[j]);&#13;
          if (!isNaN(parsed)) {&#13;
            coordsParsed.push(parsed);&#13;
          }&#13;
        }&#13;
&#13;
        var command = coordsParsed[0],&#13;
            commandLength = commandLengths[command.toLowerCase()],&#13;
            repeatedCommand = repeatedCommands[command] || command;&#13;
&#13;
        if (coordsParsed.length - 1 &gt; commandLength) {&#13;
          for (var k = 1, klen = coordsParsed.length; k &lt; klen; k += commandLength) {&#13;
            result.push([command].concat(coordsParsed.slice(k, k + commandLength)));&#13;
            command = repeatedCommand;&#13;
          }&#13;
        }&#13;
        else {&#13;
          result.push(coordsParsed);&#13;
        }&#13;
      }&#13;
&#13;
      return result;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _parseDimensions: function() {&#13;
&#13;
      var aX = [],&#13;
          aY = [],&#13;
          current, // current instruction&#13;
          previous = null,&#13;
          subpathStartX = 0,&#13;
          subpathStartY = 0,&#13;
          x = 0, // current x&#13;
          y = 0, // current y&#13;
          controlX = 0, // current control point x&#13;
          controlY = 0, // current control point y&#13;
          tempX,&#13;
          tempY,&#13;
          bounds;&#13;
&#13;
      for (var i = 0, len = this.path.length; i &lt; len; ++i) {&#13;
&#13;
        current = this.path[i];&#13;
&#13;
        switch (current[0]) { // first letter&#13;
&#13;
          case 'l': // lineto, relative&#13;
            x += current[1];&#13;
            y += current[2];&#13;
            bounds = [];&#13;
            break;&#13;
&#13;
          case 'L': // lineto, absolute&#13;
            x = current[1];&#13;
            y = current[2];&#13;
            bounds = [];&#13;
            break;&#13;
&#13;
          case 'h': // horizontal lineto, relative&#13;
            x += current[1];&#13;
            bounds = [];&#13;
            break;&#13;
&#13;
          case 'H': // horizontal lineto, absolute&#13;
            x = current[1];&#13;
            bounds = [];&#13;
            break;&#13;
&#13;
          case 'v': // vertical lineto, relative&#13;
            y += current[1];&#13;
            bounds = [];&#13;
            break;&#13;
&#13;
          case 'V': // verical lineto, absolute&#13;
            y = current[1];&#13;
            bounds = [];&#13;
            break;&#13;
&#13;
          case 'm': // moveTo, relative&#13;
            x += current[1];&#13;
            y += current[2];&#13;
            subpathStartX = x;&#13;
            subpathStartY = y;&#13;
            bounds = [];&#13;
            break;&#13;
&#13;
          case 'M': // moveTo, absolute&#13;
            x = current[1];&#13;
            y = current[2];&#13;
            subpathStartX = x;&#13;
            subpathStartY = y;&#13;
            bounds = [];&#13;
            break;&#13;
&#13;
          case 'c': // bezierCurveTo, relative&#13;
            tempX = x + current[5];&#13;
            tempY = y + current[6];&#13;
            controlX = x + current[3];&#13;
            controlY = y + current[4];&#13;
            bounds = fabric.util.getBoundsOfCurve(x, y,&#13;
              x + current[1], // x1&#13;
              y + current[2], // y1&#13;
              controlX, // x2&#13;
              controlY, // y2&#13;
              tempX,&#13;
              tempY&#13;
            );&#13;
            x = tempX;&#13;
            y = tempY;&#13;
            break;&#13;
&#13;
          case 'C': // bezierCurveTo, absolute&#13;
            controlX = current[3];&#13;
            controlY = current[4];&#13;
            bounds = fabric.util.getBoundsOfCurve(x, y,&#13;
              current[1],&#13;
              current[2],&#13;
              controlX,&#13;
              controlY,&#13;
              current[5],&#13;
              current[6]&#13;
            );&#13;
            x = current[5];&#13;
            y = current[6];&#13;
            break;&#13;
&#13;
          case 's': // shorthand cubic bezierCurveTo, relative&#13;
&#13;
            // transform to absolute x,y&#13;
            tempX = x + current[3];&#13;
            tempY = y + current[4];&#13;
&#13;
            if (previous[0].match(/[CcSs]/) === null) {&#13;
              // If there is no previous command or if the previous command was not a C, c, S, or s,&#13;
              // the control point is coincident with the current point&#13;
              controlX = x;&#13;
              controlY = y;&#13;
            }&#13;
            else {&#13;
              // calculate reflection of previous control points&#13;
              controlX = 2 * x - controlX;&#13;
              controlY = 2 * y - controlY;&#13;
            }&#13;
&#13;
            bounds = fabric.util.getBoundsOfCurve(x, y,&#13;
              controlX,&#13;
              controlY,&#13;
              x + current[1],&#13;
              y + current[2],&#13;
              tempX,&#13;
              tempY&#13;
            );&#13;
            // set control point to 2nd one of this command&#13;
            // "... the first control point is assumed to be&#13;
            // the reflection of the second control point on&#13;
            // the previous command relative to the current point."&#13;
            controlX = x + current[1];&#13;
            controlY = y + current[2];&#13;
            x = tempX;&#13;
            y = tempY;&#13;
            break;&#13;
&#13;
          case 'S': // shorthand cubic bezierCurveTo, absolute&#13;
            tempX = current[3];&#13;
            tempY = current[4];&#13;
            if (previous[0].match(/[CcSs]/) === null) {&#13;
              // If there is no previous command or if the previous command was not a C, c, S, or s,&#13;
              // the control point is coincident with the current point&#13;
              controlX = x;&#13;
              controlY = y;&#13;
            }&#13;
            else {&#13;
              // calculate reflection of previous control points&#13;
              controlX = 2 * x - controlX;&#13;
              controlY = 2 * y - controlY;&#13;
            }&#13;
            bounds = fabric.util.getBoundsOfCurve(x, y,&#13;
              controlX,&#13;
              controlY,&#13;
              current[1],&#13;
              current[2],&#13;
              tempX,&#13;
              tempY&#13;
            );&#13;
            x = tempX;&#13;
            y = tempY;&#13;
            // set control point to 2nd one of this command&#13;
            // "... the first control point is assumed to be&#13;
            // the reflection of the second control point on&#13;
            // the previous command relative to the current point."&#13;
            controlX = current[1];&#13;
            controlY = current[2];&#13;
            break;&#13;
&#13;
          case 'q': // quadraticCurveTo, relative&#13;
            // transform to absolute x,y&#13;
            tempX = x + current[3];&#13;
            tempY = y + current[4];&#13;
            controlX = x + current[1];&#13;
            controlY = y + current[2];&#13;
            bounds = fabric.util.getBoundsOfCurve(x, y,&#13;
              controlX,&#13;
              controlY,&#13;
              controlX,&#13;
              controlY,&#13;
              tempX,&#13;
              tempY&#13;
            );&#13;
            x = tempX;&#13;
            y = tempY;&#13;
            break;&#13;
&#13;
          case 'Q': // quadraticCurveTo, absolute&#13;
            controlX = current[1];&#13;
            controlY = current[2];&#13;
            bounds = fabric.util.getBoundsOfCurve(x, y,&#13;
              controlX,&#13;
              controlY,&#13;
              controlX,&#13;
              controlY,&#13;
              current[3],&#13;
              current[4]&#13;
            );&#13;
            x = current[3];&#13;
            y = current[4];&#13;
            break;&#13;
&#13;
          case 't': // shorthand quadraticCurveTo, relative&#13;
            // transform to absolute x,y&#13;
            tempX = x + current[1];&#13;
            tempY = y + current[2];&#13;
            if (previous[0].match(/[QqTt]/) === null) {&#13;
              // If there is no previous command or if the previous command was not a Q, q, T or t,&#13;
              // assume the control point is coincident with the current point&#13;
              controlX = x;&#13;
              controlY = y;&#13;
            }&#13;
            else {&#13;
              // calculate reflection of previous control point&#13;
              controlX = 2 * x - controlX;&#13;
              controlY = 2 * y - controlY;&#13;
            }&#13;
&#13;
            bounds = fabric.util.getBoundsOfCurve(x, y,&#13;
              controlX,&#13;
              controlY,&#13;
              controlX,&#13;
              controlY,&#13;
              tempX,&#13;
              tempY&#13;
            );&#13;
            x = tempX;&#13;
            y = tempY;&#13;
&#13;
            break;&#13;
&#13;
          case 'T':&#13;
            tempX = current[1];&#13;
            tempY = current[2];&#13;
&#13;
            if (previous[0].match(/[QqTt]/) === null) {&#13;
              // If there is no previous command or if the previous command was not a Q, q, T or t,&#13;
              // assume the control point is coincident with the current point&#13;
              controlX = x;&#13;
              controlY = y;&#13;
            }&#13;
            else {&#13;
              // calculate reflection of previous control point&#13;
              controlX = 2 * x - controlX;&#13;
              controlY = 2 * y - controlY;&#13;
            }&#13;
            bounds = fabric.util.getBoundsOfCurve(x, y,&#13;
              controlX,&#13;
              controlY,&#13;
              controlX,&#13;
              controlY,&#13;
              tempX,&#13;
              tempY&#13;
            );&#13;
            x = tempX;&#13;
            y = tempY;&#13;
            break;&#13;
&#13;
          case 'a':&#13;
            // TODO: optimize this&#13;
            bounds = fabric.util.getBoundsOfArc(x, y,&#13;
              current[1],&#13;
              current[2],&#13;
              current[3],&#13;
              current[4],&#13;
              current[5],&#13;
              current[6] + x,&#13;
              current[7] + y&#13;
            );&#13;
            x += current[6];&#13;
            y += current[7];&#13;
            break;&#13;
&#13;
          case 'A':&#13;
            // TODO: optimize this&#13;
            bounds = fabric.util.getBoundsOfArc(x, y,&#13;
              current[1],&#13;
              current[2],&#13;
              current[3],&#13;
              current[4],&#13;
              current[5],&#13;
              current[6],&#13;
              current[7]&#13;
            );&#13;
            x = current[6];&#13;
            y = current[7];&#13;
            break;&#13;
&#13;
          case 'z':&#13;
          case 'Z':&#13;
            x = subpathStartX;&#13;
            y = subpathStartY;&#13;
            break;&#13;
        }&#13;
        previous = current;&#13;
        bounds.forEach(function (point) {&#13;
          aX.push(point.x);&#13;
          aY.push(point.y);&#13;
        });&#13;
        aX.push(x);&#13;
        aY.push(y);&#13;
      }&#13;
&#13;
      var minX = min(aX) || 0,&#13;
          minY = min(aY) || 0,&#13;
          maxX = max(aX) || 0,&#13;
          maxY = max(aY) || 0,&#13;
          deltaX = maxX - minX,&#13;
          deltaY = maxY - minY,&#13;
&#13;
          o = {&#13;
            left: minX,&#13;
            top: minY,&#13;
            width: deltaX,&#13;
            height: deltaY&#13;
          };&#13;
&#13;
      return o;&#13;
    }&#13;
  });&#13;
&#13;
  /**&#13;
   * Creates an instance of fabric.Path from an object&#13;
   * @static&#13;
   * @memberOf fabric.Path&#13;
   * @param {Object} object&#13;
   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created&#13;
   */&#13;
  fabric.Path.fromObject = function(object, callback) {&#13;
    if (typeof object.sourcePath === 'string') {&#13;
      var pathUrl = object.sourcePath;&#13;
      fabric.loadSVGFromURL(pathUrl, function (elements) {&#13;
        var path = elements[0];&#13;
        path.setOptions(object);&#13;
        callback &amp;&amp; callback(path);&#13;
      });&#13;
    }&#13;
    else {&#13;
      fabric.Object._fromObject('Path', object, callback, 'path');&#13;
    }&#13;
  };&#13;
&#13;
  /* _FROM_SVG_START_ */&#13;
  /**&#13;
   * List of attribute names to account for when parsing SVG element (used by `fabric.Path.fromElement`)&#13;
   * @static&#13;
   * @memberOf fabric.Path&#13;
   * @see http://www.w3.org/TR/SVG/paths.html#PathElement&#13;
   */&#13;
  fabric.Path.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(['d']);&#13;
&#13;
  /**&#13;
   * Creates an instance of fabric.Path from an SVG &lt;path&gt; element&#13;
   * @static&#13;
   * @memberOf fabric.Path&#13;
   * @param {SVGElement} element to parse&#13;
   * @param {Function} callback Callback to invoke when an fabric.Path instance is created&#13;
   * @param {Object} [options] Options object&#13;
   * @param {Function} [callback] Options callback invoked after parsing is finished&#13;
   */&#13;
  fabric.Path.fromElement = function(element, callback, options) {&#13;
    var parsedAttributes = fabric.parseAttributes(element, fabric.Path.ATTRIBUTE_NAMES);&#13;
    callback(new fabric.Path(parsedAttributes.d, extend(parsedAttributes, options)));&#13;
  };&#13;
  /* _FROM_SVG_END_ */&#13;
&#13;
})(typeof exports !== 'undefined' ? exports : this);&#13;
&#13;
&#13;
(function(global) {&#13;
&#13;
  'use strict';&#13;
&#13;
  var fabric = global.fabric || (global.fabric = { }),&#13;
      extend = fabric.util.object.extend,&#13;
      min = fabric.util.array.min,&#13;
      max = fabric.util.array.max;&#13;
&#13;
  if (fabric.Group) {&#13;
    return;&#13;
  }&#13;
&#13;
  /**&#13;
   * Group class&#13;
   * @class fabric.Group&#13;
   * @extends fabric.Object&#13;
   * @mixes fabric.Collection&#13;
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#groups}&#13;
   * @see {@link fabric.Group#initialize} for constructor definition&#13;
   */&#13;
  fabric.Group = fabric.util.createClass(fabric.Object, fabric.Collection, /** @lends fabric.Group.prototype */ {&#13;
&#13;
    /**&#13;
     * Type of an object&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    type: 'group',&#13;
&#13;
    /**&#13;
     * Width of stroke&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    strokeWidth: 0,&#13;
&#13;
    /**&#13;
     * Indicates if click events should also check for subtargets&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    subTargetCheck: false,&#13;
&#13;
    /**&#13;
     * Groups are container, do not render anything on theyr own, ence no cache properties&#13;
     * @type Array&#13;
     * @default&#13;
     */&#13;
    cacheProperties: [],&#13;
&#13;
    /**&#13;
     * setOnGroup is a method used for TextBox that is no more used since 2.0.0 The behavior is still&#13;
     * available setting this boolean to true.&#13;
     * @type Boolean&#13;
     * @since 2.0.0&#13;
     * @default&#13;
     */&#13;
    useSetOnGroup: false,&#13;
&#13;
    /**&#13;
     * Constructor&#13;
     * @param {Object} objects Group objects&#13;
     * @param {Object} [options] Options object&#13;
     * @param {Boolean} [isAlreadyGrouped] if true, objects have been grouped already.&#13;
     * @return {Object} thisArg&#13;
     */&#13;
    initialize: function(objects, options, isAlreadyGrouped) {&#13;
      options = options || {};&#13;
      this._objects = [];&#13;
      // if objects enclosed in a group have been grouped already,&#13;
      // we cannot change properties of objects.&#13;
      // Thus we need to set options to group without objects,&#13;
      isAlreadyGrouped &amp;&amp; this.callSuper('initialize', options);&#13;
      this._objects = objects || [];&#13;
      for (var i = this._objects.length; i--; ) {&#13;
        this._objects[i].group = this;&#13;
      }&#13;
&#13;
      if (options.originX) {&#13;
        this.originX = options.originX;&#13;
      }&#13;
      if (options.originY) {&#13;
        this.originY = options.originY;&#13;
      }&#13;
&#13;
      if (!isAlreadyGrouped) {&#13;
        var center = options &amp;&amp; options.centerPoint;&#13;
        // if coming from svg i do not want to calc bounds.&#13;
        // i assume width and height are passed along options&#13;
        center || this._calcBounds();&#13;
        this._updateObjectsCoords(center);&#13;
        delete options.centerPoint;&#13;
        this.callSuper('initialize', options);&#13;
      }&#13;
      else {&#13;
        this._updateObjectsACoords();&#13;
      }&#13;
&#13;
      this.setCoords();&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Boolean} [skipCoordsChange] if true, coordinates of objects enclosed in a group do not change&#13;
     */&#13;
    _updateObjectsACoords: function() {&#13;
      var ignoreZoom = true, skipAbsolute = true;&#13;
      for (var i = this._objects.length; i--; ){&#13;
        this._objects[i].setCoords(ignoreZoom, skipAbsolute);&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Boolean} [skipCoordsChange] if true, coordinates of objects enclosed in a group do not change&#13;
     */&#13;
    _updateObjectsCoords: function(center) {&#13;
      var center = center || this.getCenterPoint();&#13;
      for (var i = this._objects.length; i--; ){&#13;
        this._updateObjectCoords(this._objects[i], center);&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Object} object&#13;
     * @param {fabric.Point} center, current center of group.&#13;
     */&#13;
    _updateObjectCoords: function(object, center) {&#13;
      var objectLeft = object.left,&#13;
          objectTop = object.top,&#13;
          ignoreZoom = true, skipAbsolute = true;&#13;
&#13;
      object.set({&#13;
        left: objectLeft - center.x,&#13;
        top: objectTop - center.y&#13;
      });&#13;
      object.group = this;&#13;
      object.setCoords(ignoreZoom, skipAbsolute);&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns string represenation of a group&#13;
     * @return {String}&#13;
     */&#13;
    toString: function() {&#13;
      return '#&lt;fabric.Group: (' + this.complexity() + ')&gt;';&#13;
    },&#13;
&#13;
    /**&#13;
     * Adds an object to a group; Then recalculates group's dimension, position.&#13;
     * @param {Object} object&#13;
     * @return {fabric.Group} thisArg&#13;
     * @chainable&#13;
     */&#13;
    addWithUpdate: function(object) {&#13;
      this._restoreObjectsState();&#13;
      fabric.util.resetObjectTransform(this);&#13;
      if (object) {&#13;
        this._objects.push(object);&#13;
        object.group = this;&#13;
        object._set('canvas', this.canvas);&#13;
      }&#13;
      this._calcBounds();&#13;
      this._updateObjectsCoords();&#13;
      this.setCoords();&#13;
      this.dirty = true;&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Removes an object from a group; Then recalculates group's dimension, position.&#13;
     * @param {Object} object&#13;
     * @return {fabric.Group} thisArg&#13;
     * @chainable&#13;
     */&#13;
    removeWithUpdate: function(object) {&#13;
      this._restoreObjectsState();&#13;
      fabric.util.resetObjectTransform(this);&#13;
&#13;
      this.remove(object);&#13;
      this._calcBounds();&#13;
      this._updateObjectsCoords();&#13;
      this.setCoords();&#13;
      this.dirty = true;&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _onObjectAdded: function(object) {&#13;
      this.dirty = true;&#13;
      object.group = this;&#13;
      object._set('canvas', this.canvas);&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _onObjectRemoved: function(object) {&#13;
      this.dirty = true;&#13;
      delete object.group;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _set: function(key, value) {&#13;
      var i = this._objects.length;&#13;
      if (this.useSetOnGroup) {&#13;
        while (i--) {&#13;
          this._objects[i].setOnGroup(key, value);&#13;
        }&#13;
      }&#13;
      if (key === 'canvas') {&#13;
        i = this._objects.length;&#13;
        while (i--) {&#13;
          this._objects[i]._set(key, value);&#13;
        }&#13;
      }&#13;
      this.callSuper('_set', key, value);&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns object representation of an instance&#13;
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output&#13;
     * @return {Object} object representation of an instance&#13;
     */&#13;
    toObject: function(propertiesToInclude) {&#13;
      var objsToObject = this.getObjects().map(function(obj) {&#13;
        var originalDefaults = obj.includeDefaultValues;&#13;
        obj.includeDefaultValues = obj.group.includeDefaultValues;&#13;
        var _obj = obj.toObject(propertiesToInclude);&#13;
        obj.includeDefaultValues = originalDefaults;&#13;
        return _obj;&#13;
      });&#13;
      return extend(this.callSuper('toObject', propertiesToInclude), {&#13;
        objects: objsToObject&#13;
      });&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns object representation of an instance, in dataless mode.&#13;
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output&#13;
     * @return {Object} object representation of an instance&#13;
     */&#13;
    toDatalessObject: function(propertiesToInclude) {&#13;
      var objsToObject, sourcePath = this.sourcePath;&#13;
      if (sourcePath) {&#13;
        objsToObject = sourcePath;&#13;
      }&#13;
      else {&#13;
        objsToObject = this.getObjects().map(function(obj) {&#13;
          var originalDefaults = obj.includeDefaultValues;&#13;
          obj.includeDefaultValues = obj.group.includeDefaultValues;&#13;
          var _obj = obj.toDatalessObject(propertiesToInclude);&#13;
          obj.includeDefaultValues = originalDefaults;&#13;
          return _obj;&#13;
        });&#13;
      }&#13;
      return extend(this.callSuper('toDatalessObject', propertiesToInclude), {&#13;
        objects: objsToObject&#13;
      });&#13;
    },&#13;
&#13;
    /**&#13;
     * Renders instance on a given context&#13;
     * @param {CanvasRenderingContext2D} ctx context to render instance on&#13;
     */&#13;
    render: function(ctx) {&#13;
      this._transformDone = true;&#13;
      this.callSuper('render', ctx);&#13;
      this._transformDone = false;&#13;
    },&#13;
&#13;
    /**&#13;
     * Decide if the object should cache or not. Create its own cache level&#13;
     * objectCaching is a global flag, wins over everything&#13;
     * needsItsOwnCache should be used when the object drawing method requires&#13;
     * a cache step. None of the fabric classes requires it.&#13;
     * Generally you do not cache objects in groups because the group outside is cached.&#13;
     * @return {Boolean}&#13;
     */&#13;
    shouldCache: function() {&#13;
      var ownCache = this.objectCaching &amp;&amp; (!this.group || this.needsItsOwnCache() || !this.group.isOnACache());&#13;
      this.ownCaching = ownCache;&#13;
      if (ownCache) {&#13;
        for (var i = 0, len = this._objects.length; i &lt; len; i++) {&#13;
          if (this._objects[i].willDrawShadow()) {&#13;
            this.ownCaching = false;&#13;
            return false;&#13;
          }&#13;
        }&#13;
      }&#13;
      return ownCache;&#13;
    },&#13;
&#13;
    /**&#13;
     * Check if this object or a child object will cast a shadow&#13;
     * @return {Boolean}&#13;
     */&#13;
    willDrawShadow: function() {&#13;
      if (this.shadow) {&#13;
        return this.callSuper('willDrawShadow');&#13;
      }&#13;
      for (var i = 0, len = this._objects.length; i &lt; len; i++) {&#13;
        if (this._objects[i].willDrawShadow()) {&#13;
          return true;&#13;
        }&#13;
      }&#13;
      return false;&#13;
    },&#13;
&#13;
    /**&#13;
     * Check if this group or its parent group are caching, recursively up&#13;
     * @return {Boolean}&#13;
     */&#13;
    isOnACache: function() {&#13;
      return this.ownCaching || (this.group &amp;&amp; this.group.isOnACache());&#13;
    },&#13;
&#13;
    /**&#13;
     * Execute the drawing operation for an object on a specified context&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     */&#13;
    drawObject: function(ctx) {&#13;
      for (var i = 0, len = this._objects.length; i &lt; len; i++) {&#13;
        this._objects[i].render(ctx);&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Check if cache is dirty&#13;
     */&#13;
    isCacheDirty: function() {&#13;
      if (this.callSuper('isCacheDirty')) {&#13;
        return true;&#13;
      }&#13;
      if (!this.statefullCache) {&#13;
        return false;&#13;
      }&#13;
      for (var i = 0, len = this._objects.length; i &lt; len; i++) {&#13;
        if (this._objects[i].isCacheDirty(true)) {&#13;
          if (this._cacheCanvas) {&#13;
            // if this group has not a cache canvas there is nothing to clean&#13;
            var x = this.cacheWidth / this.zoomX, y = this.cacheHeight / this.zoomY;&#13;
            this._cacheContext.clearRect(-x / 2, -y / 2, x, y);&#13;
          }&#13;
          return true;&#13;
        }&#13;
      }&#13;
      return false;&#13;
    },&#13;
&#13;
    /**&#13;
     * Retores original state of each of group objects (original state is that which was before group was created).&#13;
     * @private&#13;
     * @return {fabric.Group} thisArg&#13;
     * @chainable&#13;
     */&#13;
    _restoreObjectsState: function() {&#13;
      this._objects.forEach(this._restoreObjectState, this);&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Realises the transform from this group onto the supplied object&#13;
     * i.e. it tells you what would happen if the supplied object was in&#13;
     * the group, and then the group was destroyed. It mutates the supplied&#13;
     * object.&#13;
     * @param {fabric.Object} object&#13;
     * @return {fabric.Object} transformedObject&#13;
     */&#13;
    realizeTransform: function(object) {&#13;
      var matrix = object.calcTransformMatrix(),&#13;
          options = fabric.util.qrDecompose(matrix),&#13;
          center = new fabric.Point(options.translateX, options.translateY);&#13;
      object.flipX = false;&#13;
      object.flipY = false;&#13;
      object.set('scaleX', options.scaleX);&#13;
      object.set('scaleY', options.scaleY);&#13;
      object.skewX = options.skewX;&#13;
      object.skewY = options.skewY;&#13;
      object.angle = options.angle;&#13;
      object.setPositionByOrigin(center, 'center', 'center');&#13;
      return object;&#13;
    },&#13;
&#13;
    /**&#13;
     * Restores original state of a specified object in group&#13;
     * @private&#13;
     * @param {fabric.Object} object&#13;
     * @return {fabric.Group} thisArg&#13;
     */&#13;
    _restoreObjectState: function(object) {&#13;
      this.realizeTransform(object);&#13;
      object.setCoords();&#13;
      delete object.group;&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Destroys a group (restoring state of its objects)&#13;
     * @return {fabric.Group} thisArg&#13;
     * @chainable&#13;
     */&#13;
    destroy: function() {&#13;
      // when group is destroyed objects needs to get a repaint to be eventually&#13;
      // displayed on canvas.&#13;
      this._objects.forEach(function(object) {&#13;
        object.set('dirty', true);&#13;
      });&#13;
      return this._restoreObjectsState();&#13;
    },&#13;
&#13;
    /**&#13;
     * make a group an active selection, remove the group from canvas&#13;
     * the group has to be on canvas for this to work.&#13;
     * @return {fabric.ActiveSelection} thisArg&#13;
     * @chainable&#13;
     */&#13;
    toActiveSelection: function() {&#13;
      if (!this.canvas) {&#13;
        return;&#13;
      }&#13;
      var objects = this._objects, canvas = this.canvas;&#13;
      this._objects = [];&#13;
      var options = this.toObject();&#13;
      delete options.objects;&#13;
      var activeSelection = new fabric.ActiveSelection([]);&#13;
      activeSelection.set(options);&#13;
      activeSelection.type = 'activeSelection';&#13;
      canvas.remove(this);&#13;
      objects.forEach(function(object) {&#13;
        object.group = activeSelection;&#13;
        object.dirty = true;&#13;
        canvas.add(object);&#13;
      });&#13;
      activeSelection.canvas = canvas;&#13;
      activeSelection._objects = objects;&#13;
      canvas._activeObject = activeSelection;&#13;
      activeSelection.setCoords();&#13;
      return activeSelection;&#13;
    },&#13;
&#13;
    /**&#13;
     * Destroys a group (restoring state of its objects)&#13;
     * @return {fabric.Group} thisArg&#13;
     * @chainable&#13;
     */&#13;
    ungroupOnCanvas: function() {&#13;
      return this._restoreObjectsState();&#13;
    },&#13;
&#13;
    /**&#13;
     * Sets coordinates of all objects inside group&#13;
     * @return {fabric.Group} thisArg&#13;
     * @chainable&#13;
     */&#13;
    setObjectsCoords: function() {&#13;
      var ignoreZoom = true, skipAbsolute = true;&#13;
      this.forEachObject(function(object) {&#13;
        object.setCoords(ignoreZoom, skipAbsolute);&#13;
      });&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _calcBounds: function(onlyWidthHeight) {&#13;
      var aX = [],&#13;
          aY = [],&#13;
          o, prop,&#13;
          props = ['tr', 'br', 'bl', 'tl'],&#13;
          i = 0, iLen = this._objects.length,&#13;
          j, jLen = props.length,&#13;
          ignoreZoom = true;&#13;
&#13;
      for ( ; i &lt; iLen; ++i) {&#13;
        o = this._objects[i];&#13;
        o.setCoords(ignoreZoom);&#13;
        for (j = 0; j &lt; jLen; j++) {&#13;
          prop = props[j];&#13;
          aX.push(o.oCoords[prop].x);&#13;
          aY.push(o.oCoords[prop].y);&#13;
        }&#13;
      }&#13;
&#13;
      this.set(this._getBounds(aX, aY, onlyWidthHeight));&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _getBounds: function(aX, aY, onlyWidthHeight) {&#13;
      var minXY = new fabric.Point(min(aX), min(aY)),&#13;
          maxXY = new fabric.Point(max(aX), max(aY)),&#13;
          obj = {&#13;
            width: (maxXY.x - minXY.x) || 0,&#13;
            height: (maxXY.y - minXY.y) || 0&#13;
          };&#13;
&#13;
      if (!onlyWidthHeight) {&#13;
        obj.left = minXY.x || 0;&#13;
        obj.top = minXY.y || 0;&#13;
        if (this.originX === 'center') {&#13;
          obj.left += obj.width / 2;&#13;
        }&#13;
        if (this.originX === 'right') {&#13;
          obj.left += obj.width;&#13;
        }&#13;
        if (this.originY === 'center') {&#13;
          obj.top += obj.height / 2;&#13;
        }&#13;
        if (this.originY === 'bottom') {&#13;
          obj.top += obj.height;&#13;
        }&#13;
      }&#13;
      return obj;&#13;
    },&#13;
&#13;
    /* _TO_SVG_START_ */&#13;
    /**&#13;
     * Returns svg representation of an instance&#13;
     * @param {Function} [reviver] Method for further parsing of svg representation.&#13;
     * @return {String} svg representation of an instance&#13;
     */&#13;
    toSVG: function(reviver) {&#13;
      var markup = this._createBaseSVGMarkup();&#13;
      markup.push(&#13;
        '&lt;g ', this.getSvgId(), 'transform="',&#13;
        /* avoiding styles intentionally */&#13;
        this.getSvgTransform(),&#13;
        this.getSvgTransformMatrix(),&#13;
        '" style="',&#13;
        this.getSvgFilter(),&#13;
        '"&gt;\n'&#13;
      );&#13;
&#13;
      for (var i = 0, len = this._objects.length; i &lt; len; i++) {&#13;
        markup.push('\t', this._objects[i].toSVG(reviver));&#13;
      }&#13;
&#13;
      markup.push('&lt;/g&gt;\n');&#13;
&#13;
      return reviver ? reviver(markup.join('')) : markup.join('');&#13;
    },&#13;
    /* _TO_SVG_END_ */&#13;
  });&#13;
&#13;
  /**&#13;
   * Returns {@link fabric.Group} instance from an object representation&#13;
   * @static&#13;
   * @memberOf fabric.Group&#13;
   * @param {Object} object Object to create a group from&#13;
   * @param {Function} [callback] Callback to invoke when an group instance is created&#13;
   */&#13;
  fabric.Group.fromObject = function(object, callback) {&#13;
    fabric.util.enlivenObjects(object.objects, function(enlivenedObjects) {&#13;
      var options = fabric.util.object.clone(object, true);&#13;
      delete options.objects;&#13;
      callback &amp;&amp; callback(new fabric.Group(enlivenedObjects, options, true));&#13;
    });&#13;
  };&#13;
&#13;
})(typeof exports !== 'undefined' ? exports : this);&#13;
&#13;
&#13;
(function(global) {&#13;
&#13;
  'use strict';&#13;
&#13;
  var fabric = global.fabric || (global.fabric = { });&#13;
&#13;
  if (fabric.ActiveSelection) {&#13;
    return;&#13;
  }&#13;
&#13;
  /**&#13;
   * Group class&#13;
   * @class fabric.ActiveSelection&#13;
   * @extends fabric.Group&#13;
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#groups}&#13;
   * @see {@link fabric.ActiveSelection#initialize} for constructor definition&#13;
   */&#13;
  fabric.ActiveSelection = fabric.util.createClass(fabric.Group, /** @lends fabric.ActiveSelection.prototype */ {&#13;
&#13;
    /**&#13;
     * Type of an object&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    type: 'activeSelection',&#13;
&#13;
    /**&#13;
     * Constructor&#13;
     * @param {Object} objects ActiveSelection objects&#13;
     * @param {Object} [options] Options object&#13;
     * @return {Object} thisArg&#13;
     */&#13;
    initialize: function(objects, options) {&#13;
      options = options || {};&#13;
      this._objects = objects || [];&#13;
      for (var i = this._objects.length; i--; ) {&#13;
        this._objects[i].group = this;&#13;
      }&#13;
&#13;
      if (options.originX) {&#13;
        this.originX = options.originX;&#13;
      }&#13;
      if (options.originY) {&#13;
        this.originY = options.originY;&#13;
      }&#13;
      this._calcBounds();&#13;
      this._updateObjectsCoords();&#13;
      fabric.Object.prototype.initialize.call(this, options);&#13;
      this.setCoords();&#13;
    },&#13;
&#13;
    /**&#13;
     * Change te activeSelection to a normal group,&#13;
     * High level function that automatically adds it to canvas as&#13;
     * active object. no events fired.&#13;
     * @since 2.0.0&#13;
     * @return {fabric.Group}&#13;
     */&#13;
    toGroup: function() {&#13;
      var objects = this._objects;&#13;
      this._objects = [];&#13;
      var options = this.toObject();&#13;
      var newGroup = new fabric.Group([]);&#13;
      delete options.objects;&#13;
      newGroup.set(options);&#13;
      newGroup.type = 'group';&#13;
      objects.forEach(function(object) {&#13;
        object.group = newGroup;&#13;
        object.canvas.remove(object);&#13;
      });&#13;
      newGroup._objects = objects;&#13;
      if (!this.canvas) {&#13;
        return newGroup;&#13;
      }&#13;
      var canvas = this.canvas;&#13;
      canvas.add(newGroup);&#13;
      canvas._activeObject = newGroup;&#13;
      newGroup.setCoords();&#13;
      return newGroup;&#13;
    },&#13;
&#13;
    /**&#13;
     * If returns true, deselection is cancelled.&#13;
     * @since 2.0.0&#13;
     * @return {Boolean} [cancel]&#13;
     */&#13;
    onDeselect: function() {&#13;
      this.destroy();&#13;
      return false;&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns string representation of a group&#13;
     * @return {String}&#13;
     */&#13;
    toString: function() {&#13;
      return '#&lt;fabric.ActiveSelection: (' + this.complexity() + ')&gt;';&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _set: function(key, value) {&#13;
      var i = this._objects.length;&#13;
      if (key === 'canvas') {&#13;
        while (i--) {&#13;
          this._objects[i].set(key, value);&#13;
        }&#13;
      }&#13;
      if (this.useSetOnGroup) {&#13;
        while (i--) {&#13;
          this._objects[i].setOnGroup(key, value);&#13;
        }&#13;
      }&#13;
      fabric.Object.prototype._set.call(this, key, value);&#13;
    },&#13;
&#13;
    /**&#13;
     * Decide if the object should cache or not. Create its own cache level&#13;
     * objectCaching is a global flag, wins over everything&#13;
     * needsItsOwnCache should be used when the object drawing method requires&#13;
     * a cache step. None of the fabric classes requires it.&#13;
     * Generally you do not cache objects in groups because the group outside is cached.&#13;
     * @return {Boolean}&#13;
     */&#13;
    shouldCache: function() {&#13;
      return false;&#13;
    },&#13;
&#13;
    /**&#13;
     * Check if this object or a child object will cast a shadow&#13;
     * @return {Boolean}&#13;
     */&#13;
    willDrawShadow: function() {&#13;
      if (this.shadow) {&#13;
        return this.callSuper('willDrawShadow');&#13;
      }&#13;
      for (var i = 0, len = this._objects.length; i &lt; len; i++) {&#13;
        if (this._objects[i].willDrawShadow()) {&#13;
          return true;&#13;
        }&#13;
      }&#13;
      return false;&#13;
    },&#13;
&#13;
    /**&#13;
     * Check if this group or its parent group are caching, recursively up&#13;
     * @return {Boolean}&#13;
     */&#13;
    isOnACache: function() {&#13;
      return false;&#13;
    },&#13;
&#13;
    /**&#13;
     * Renders controls and borders for the object&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     * @param {Object} [styleOverride] properties to override the object style&#13;
     * @param {Object} [childrenOverride] properties to override the children overrides&#13;
     */&#13;
    _renderControls: function(ctx, styleOverride, childrenOverride) {&#13;
      ctx.save();&#13;
      ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;&#13;
      this.callSuper('_renderControls', ctx, styleOverride);&#13;
      childrenOverride = childrenOverride || { };&#13;
      if (typeof childrenOverride.hasControls === 'undefined') {&#13;
        childrenOverride.hasControls = false;&#13;
      }&#13;
      if (typeof childrenOverride.hasRotatingPoint === 'undefined') {&#13;
        childrenOverride.hasRotatingPoint = false;&#13;
      }&#13;
      childrenOverride.forActiveSelection = true;&#13;
      for (var i = 0, len = this._objects.length; i &lt; len; i++) {&#13;
        this._objects[i]._renderControls(ctx, childrenOverride);&#13;
      }&#13;
      ctx.restore();&#13;
    },&#13;
  });&#13;
&#13;
  /**&#13;
   * Returns {@link fabric.ActiveSelection} instance from an object representation&#13;
   * @static&#13;
   * @memberOf fabric.ActiveSelection&#13;
   * @param {Object} object Object to create a group from&#13;
   * @param {Function} [callback] Callback to invoke when an ActiveSelection instance is created&#13;
   */&#13;
  fabric.ActiveSelection.fromObject = function(object, callback) {&#13;
    fabric.util.enlivenObjects(object.objects, function(enlivenedObjects) {&#13;
      delete object.objects;&#13;
      callback &amp;&amp; callback(new fabric.ActiveSelection(enlivenedObjects, object, true));&#13;
    });&#13;
  };&#13;
&#13;
})(typeof exports !== 'undefined' ? exports : this);&#13;
&#13;
&#13;
(function(global) {&#13;
&#13;
  'use strict';&#13;
&#13;
  var extend = fabric.util.object.extend;&#13;
&#13;
  if (!global.fabric) {&#13;
    global.fabric = { };&#13;
  }&#13;
&#13;
  if (global.fabric.Image) {&#13;
    fabric.warn('fabric.Image is already defined.');&#13;
    return;&#13;
  }&#13;
&#13;
  /**&#13;
   * Image class&#13;
   * @class fabric.Image&#13;
   * @extends fabric.Object&#13;
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#images}&#13;
   * @see {@link fabric.Image#initialize} for constructor definition&#13;
   */&#13;
  fabric.Image = fabric.util.createClass(fabric.Object, /** @lends fabric.Image.prototype */ {&#13;
&#13;
    /**&#13;
     * Type of an object&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    type: 'image',&#13;
&#13;
    /**&#13;
     * crossOrigin value (one of "", "anonymous", "use-credentials")&#13;
     * @see https://developer.mozilla.org/en-US/docs/HTML/CORS_settings_attributes&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    crossOrigin: '',&#13;
&#13;
    /**&#13;
     * Width of a stroke.&#13;
     * For image quality a stroke multiple of 2 gives better results.&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    strokeWidth: 0,&#13;
&#13;
    /**&#13;
     * private&#13;
     * contains last value of scaleX to detect&#13;
     * if the Image got resized after the last Render&#13;
     * @type Number&#13;
     */&#13;
    _lastScaleX: 1,&#13;
&#13;
    /**&#13;
     * private&#13;
     * contains last value of scaleY to detect&#13;
     * if the Image got resized after the last Render&#13;
     * @type Number&#13;
     */&#13;
    _lastScaleY: 1,&#13;
&#13;
    /**&#13;
     * private&#13;
     * contains last value of scaling applied by the apply filter chain&#13;
     * @type Number&#13;
     */&#13;
    _filterScalingX: 1,&#13;
&#13;
    /**&#13;
     * private&#13;
     * contains last value of scaling applied by the apply filter chain&#13;
     * @type Number&#13;
     */&#13;
    _filterScalingY: 1,&#13;
&#13;
    /**&#13;
     * minimum scale factor under which any resizeFilter is triggered to resize the image&#13;
     * 0 will disable the automatic resize. 1 will trigger automatically always.&#13;
     * number bigger than 1 are not implemented yet.&#13;
     * @type Number&#13;
     */&#13;
    minimumScaleTrigger: 0.5,&#13;
&#13;
    /**&#13;
     * List of properties to consider when checking if&#13;
     * state of an object is changed ({@link fabric.Object#hasStateChanged})&#13;
     * as well as for history (undo/redo) purposes&#13;
     * @type Array&#13;
     */&#13;
    stateProperties: fabric.Object.prototype.stateProperties.concat('cropX', 'cropY'),&#13;
&#13;
    /**&#13;
     * When `true`, object is cached on an additional canvas.&#13;
     * default to false for images&#13;
     * since 1.7.0&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    objectCaching: false,&#13;
&#13;
    /**&#13;
     * key used to retrieve the texture representing this image&#13;
     * since 2.0.0&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    cacheKey: '',&#13;
&#13;
    /**&#13;
     * Image crop in pixels from original image size.&#13;
     * since 2.0.0&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    cropX: 0,&#13;
&#13;
    /**&#13;
     * Image crop in pixels from original image size.&#13;
     * since 2.0.0&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    cropY: 0,&#13;
&#13;
    /**&#13;
     * Constructor&#13;
     * @param {HTMLImageElement | String} element Image element&#13;
     * @param {Object} [options] Options object&#13;
     * @param {function} [callback] callback function to call after eventual filters applied.&#13;
     * @return {fabric.Image} thisArg&#13;
     */&#13;
    initialize: function(element, options) {&#13;
      options || (options = { });&#13;
      this.filters = [];&#13;
      this.cacheKey = 'texture' + fabric.Object.__uid++;&#13;
      this.callSuper('initialize', options);&#13;
      this._initElement(element, options);&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns image element which this instance if based on&#13;
     * @return {HTMLImageElement} Image element&#13;
     */&#13;
    getElement: function() {&#13;
      return this._element;&#13;
    },&#13;
&#13;
    /**&#13;
     * Sets image element for this instance to a specified one.&#13;
     * If filters defined they are applied to new image.&#13;
     * You might need to call `canvas.renderAll` and `object.setCoords` after replacing, to render new image and update controls area.&#13;
     * @param {HTMLImageElement} element&#13;
     * @param {Object} [options] Options object&#13;
     * @return {fabric.Image} thisArg&#13;
     * @chainable&#13;
     */&#13;
    setElement: function(element, options) {&#13;
      var backend = fabric.filterBackend;&#13;
      if (backend &amp;&amp; backend.evictCachesForKey) {&#13;
        backend.evictCachesForKey(this.cacheKey);&#13;
        backend.evictCachesForKey(this.cacheKey + '_filtered');&#13;
      }&#13;
      this._element = element;&#13;
      this._originalElement = element;&#13;
      this._initConfig(options);&#13;
      if (this.resizeFilter) {&#13;
        this.applyResizeFilters();&#13;
      }&#13;
      if (this.filters.length !== 0) {&#13;
        this.applyFilters();&#13;
      }&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Delete cacheKey if we have a webGlBackend&#13;
     * delete reference to image elements&#13;
     */&#13;
    dispose: function() {&#13;
      var backend = fabric.filterBackend;&#13;
      if (backend &amp;&amp; backend.evictCachesForKey) {&#13;
        backend.evictCachesForKey(this.cacheKey);&#13;
        backend.evictCachesForKey(this.cacheKey + '_filtered');&#13;
      }&#13;
      this._originalElement = undefined;&#13;
      this._element = undefined;&#13;
      this._filteredEl = undefined;&#13;
    },&#13;
&#13;
    /**&#13;
     * Sets crossOrigin value (on an instance and corresponding image element)&#13;
     * @return {fabric.Image} thisArg&#13;
     * @chainable&#13;
     */&#13;
    setCrossOrigin: function(value) {&#13;
      this.crossOrigin = value;&#13;
      this._element.crossOrigin = value;&#13;
&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns original size of an image&#13;
     * @return {Object} Object with "width" and "height" properties&#13;
     */&#13;
    getOriginalSize: function() {&#13;
      var element = this.getElement();&#13;
      return {&#13;
        width: element.width,&#13;
        height: element.height&#13;
      };&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     */&#13;
    _stroke: function(ctx) {&#13;
      if (!this.stroke || this.strokeWidth === 0) {&#13;
        return;&#13;
      }&#13;
      var w = this.width / 2, h = this.height / 2;&#13;
      ctx.beginPath();&#13;
      ctx.moveTo(-w, -h);&#13;
      ctx.lineTo(w, -h);&#13;
      ctx.lineTo(w, h);&#13;
      ctx.lineTo(-w, h);&#13;
      ctx.lineTo(-w, -h);&#13;
      ctx.closePath();&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     */&#13;
    _renderDashedStroke: function(ctx) {&#13;
      var x = -this.width / 2,&#13;
          y = -this.height / 2,&#13;
          w = this.width,&#13;
          h = this.height;&#13;
&#13;
      ctx.save();&#13;
      this._setStrokeStyles(ctx, this);&#13;
&#13;
      ctx.beginPath();&#13;
      fabric.util.drawDashedLine(ctx, x, y, x + w, y, this.strokeDashArray);&#13;
      fabric.util.drawDashedLine(ctx, x + w, y, x + w, y + h, this.strokeDashArray);&#13;
      fabric.util.drawDashedLine(ctx, x + w, y + h, x, y + h, this.strokeDashArray);&#13;
      fabric.util.drawDashedLine(ctx, x, y + h, x, y, this.strokeDashArray);&#13;
      ctx.closePath();&#13;
      ctx.restore();&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns object representation of an instance&#13;
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output&#13;
     * @return {Object} Object representation of an instance&#13;
     */&#13;
    toObject: function(propertiesToInclude) {&#13;
      var filters = [];&#13;
&#13;
      this.filters.forEach(function(filterObj) {&#13;
        if (filterObj) {&#13;
          filters.push(filterObj.toObject());&#13;
        }&#13;
      });&#13;
      var object = extend(&#13;
        this.callSuper(&#13;
          'toObject',&#13;
          ['crossOrigin', 'cropX', 'cropY'].concat(propertiesToInclude)&#13;
        ), {&#13;
          src: this.getSrc(),&#13;
          filters: filters,&#13;
        });&#13;
      if (this.resizeFilter) {&#13;
        object.resizeFilter = this.resizeFilter.toObject();&#13;
      }&#13;
      return object;&#13;
    },&#13;
&#13;
    /* _TO_SVG_START_ */&#13;
    /**&#13;
     * Returns SVG representation of an instance&#13;
     * @param {Function} [reviver] Method for further parsing of svg representation.&#13;
     * @return {String} svg representation of an instance&#13;
     */&#13;
    toSVG: function(reviver) {&#13;
      var markup = this._createBaseSVGMarkup(), x = -this.width / 2, y = -this.height / 2;&#13;
      markup.push('&lt;g transform="', this.getSvgTransform(), this.getSvgTransformMatrix(), '"&gt;\n');&#13;
      var imageMarkup = ['\t&lt;image ', this.getSvgId(), 'xlink:href="', this.getSvgSrc(true),&#13;
        '" x="', x, '" y="', y,&#13;
        '" style="', this.getSvgStyles(),&#13;
        // we're essentially moving origin of transformation from top/left corner to the center of the shape&#13;
        // by wrapping it in container &lt;g&gt; element with actual transformation, then offsetting object to the top/left&#13;
        // so that object's center aligns with container's left/top&#13;
        '" width="', this.width,&#13;
        '" height="', this.height,&#13;
        '"&gt;&lt;/image&gt;\n'];&#13;
      if (this.paintFirst === 'fill') {&#13;
        Array.prototype.push.apply(markup, imageMarkup);&#13;
      }&#13;
      if (this.stroke || this.strokeDashArray) {&#13;
        var origFill = this.fill;&#13;
        this.fill = null;&#13;
        markup.push(&#13;
          '\t&lt;rect ',&#13;
          'x="', x, '" y="', y,&#13;
          '" width="', this.width, '" height="', this.height,&#13;
          '" style="', this.getSvgStyles(),&#13;
          '"/&gt;\n'&#13;
        );&#13;
        this.fill = origFill;&#13;
      }&#13;
      if (this.paintFirst !== 'fill') {&#13;
        Array.prototype.push.apply(markup, imageMarkup);&#13;
      }&#13;
      markup.push('&lt;/g&gt;\n');&#13;
&#13;
      return reviver ? reviver(markup.join('')) : markup.join('');&#13;
    },&#13;
    /* _TO_SVG_END_ */&#13;
&#13;
    /**&#13;
     * Returns source of an image&#13;
     * @param {Boolean} filtered indicates if the src is needed for svg&#13;
     * @return {String} Source of an image&#13;
     */&#13;
    getSrc: function(filtered) {&#13;
      var element = filtered ? this._element : this._originalElement;&#13;
      if (element) {&#13;
        if (element.toDataURL) {&#13;
          return element.toDataURL();&#13;
        }&#13;
        return element.src;&#13;
      }&#13;
      else {&#13;
        return this.src || '';&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Sets source of an image&#13;
     * @param {String} src Source string (URL)&#13;
     * @param {Function} [callback] Callback is invoked when image has been loaded (and all filters have been applied)&#13;
     * @param {Object} [options] Options object&#13;
     * @return {fabric.Image} thisArg&#13;
     * @chainable&#13;
     */&#13;
    setSrc: function(src, callback, options) {&#13;
      fabric.util.loadImage(src, function(img) {&#13;
        this.setElement(img, options);&#13;
        callback(this);&#13;
      }, this, options &amp;&amp; options.crossOrigin);&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns string representation of an instance&#13;
     * @return {String} String representation of an instance&#13;
     */&#13;
    toString: function() {&#13;
      return '#&lt;fabric.Image: { src: "' + this.getSrc() + '" }&gt;';&#13;
    },&#13;
&#13;
    applyResizeFilters: function() {&#13;
      var filter = this.resizeFilter,&#13;
          retinaScaling = this.canvas ? this.canvas.getRetinaScaling() : 1,&#13;
          minimumScale = this.minimumScaleTrigger,&#13;
          scaleX = this.scaleX * retinaScaling,&#13;
          scaleY = this.scaleY * retinaScaling,&#13;
          elementToFilter = this._filteredEl || this._originalElement;&#13;
      if (!filter || (scaleX &gt; minimumScale &amp;&amp; scaleY &gt; minimumScale)) {&#13;
        this._element = elementToFilter;&#13;
        this._filterScalingX = 1;&#13;
        this._filterScalingY = 1;&#13;
        return;&#13;
      }&#13;
      if (!fabric.filterBackend) {&#13;
        fabric.filterBackend = fabric.initFilterBackend();&#13;
      }&#13;
      var canvasEl = fabric.util.createCanvasElement(),&#13;
          cacheKey = this._filteredEl ? this.cacheKey : (this.cacheKey + '_filtered'),&#13;
          sourceWidth = elementToFilter.width, sourceHeight = elementToFilter.height;&#13;
      canvasEl.width = sourceWidth;&#13;
      canvasEl.height = sourceHeight;&#13;
      this._element = canvasEl;&#13;
      filter.scaleX = scaleX;&#13;
      filter.scaleY = scaleY;&#13;
      fabric.filterBackend.applyFilters(&#13;
        [filter], elementToFilter, sourceWidth, sourceHeight, this._element, cacheKey);&#13;
      this._filterScalingX = canvasEl.width / this._originalElement.width;&#13;
      this._filterScalingY = canvasEl.height / this._originalElement.height;&#13;
    },&#13;
&#13;
    /**&#13;
     * Applies filters assigned to this image (from "filters" array) or from filter param&#13;
     * @method applyFilters&#13;
     * @param {Array} filters to be applied&#13;
     * @param {Boolean} forResizing specify if the filter operation is a resize operation&#13;
     * @return {thisArg} return the fabric.Image object&#13;
     * @chainable&#13;
     */&#13;
    applyFilters: function(filters) {&#13;
&#13;
      filters = filters || this.filters || [];&#13;
      filters = filters.filter(function(filter) { return filter; });&#13;
      if (filters.length === 0) {&#13;
        this._element = this._originalElement;&#13;
        this._filteredEl = null;&#13;
        this._filterScalingX = 1;&#13;
        this._filterScalingY = 1;&#13;
        return this;&#13;
      }&#13;
&#13;
      var imgElement = this._originalElement,&#13;
          sourceWidth = imgElement.naturalWidth || imgElement.width,&#13;
          sourceHeight = imgElement.naturalHeight || imgElement.height;&#13;
&#13;
      if (this._element === this._originalElement) {&#13;
        // if the element is the same we need to create a new element&#13;
        var canvasEl = fabric.util.createCanvasElement();&#13;
        canvasEl.width = sourceWidth;&#13;
        canvasEl.height = sourceHeight;&#13;
        this._element = canvasEl;&#13;
        this._filteredEl = canvasEl;&#13;
      }&#13;
      else {&#13;
        // clear the existing element to get new filter data&#13;
        this._element.getContext('2d').clearRect(0, 0, sourceWidth, sourceHeight);&#13;
      }&#13;
      if (!fabric.filterBackend) {&#13;
        fabric.filterBackend = fabric.initFilterBackend();&#13;
      }&#13;
      fabric.filterBackend.applyFilters(&#13;
        filters, this._originalElement, sourceWidth, sourceHeight, this._element, this.cacheKey);&#13;
      if (this._originalElement.width !== this._element.width ||&#13;
        this._originalElement.height !== this._element.height) {&#13;
        this._filterScalingX = this._element.width / this._originalElement.width;&#13;
        this._filterScalingY = this._element.height / this._originalElement.height;&#13;
      }&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     */&#13;
    _render: function(ctx) {&#13;
      if (this.isMoving === false &amp;&amp; this.resizeFilter &amp;&amp; this._needsResize()) {&#13;
        this._lastScaleX = this.scaleX;&#13;
        this._lastScaleY = this.scaleY;&#13;
        this.applyResizeFilters();&#13;
      }&#13;
      this._stroke(ctx);&#13;
      this._renderPaintInOrder(ctx);&#13;
    },&#13;
&#13;
    _renderFill: function(ctx) {&#13;
      var w = this.width, h = this.height, sW = w * this._filterScalingX, sH = h * this._filterScalingY,&#13;
          x = -w / 2, y = -h / 2, elementToDraw = this._element;&#13;
      elementToDraw &amp;&amp; ctx.drawImage(elementToDraw,&#13;
        this.cropX * this._filterScalingX,&#13;
        this.cropY * this._filterScalingY,&#13;
        sW,&#13;
        sH,&#13;
        x, y, w, h);&#13;
    },&#13;
&#13;
    /**&#13;
     * @private, needed to check if image needs resize&#13;
     */&#13;
    _needsResize: function() {&#13;
      return (this.scaleX !== this._lastScaleX || this.scaleY !== this._lastScaleY);&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _resetWidthHeight: function() {&#13;
      var element = this.getElement();&#13;
&#13;
      this.set('width', element.width);&#13;
      this.set('height', element.height);&#13;
    },&#13;
&#13;
    /**&#13;
     * The Image class's initialization method. This method is automatically&#13;
     * called by the constructor.&#13;
     * @private&#13;
     * @param {HTMLImageElement|String} element The element representing the image&#13;
     * @param {Object} [options] Options object&#13;
     */&#13;
    _initElement: function(element, options) {&#13;
      this.setElement(fabric.util.getById(element), options);&#13;
      fabric.util.addClass(this.getElement(), fabric.Image.CSS_CANVAS);&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Object} [options] Options object&#13;
     */&#13;
    _initConfig: function(options) {&#13;
      options || (options = { });&#13;
      this.setOptions(options);&#13;
      this._setWidthHeight(options);&#13;
      if (this._element &amp;&amp; this.crossOrigin) {&#13;
        this._element.crossOrigin = this.crossOrigin;&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Array} filters to be initialized&#13;
     * @param {Function} callback Callback to invoke when all fabric.Image.filters instances are created&#13;
     */&#13;
    _initFilters: function(filters, callback) {&#13;
      if (filters &amp;&amp; filters.length) {&#13;
        fabric.util.enlivenObjects(filters, function(enlivenedObjects) {&#13;
          callback &amp;&amp; callback(enlivenedObjects);&#13;
        }, 'fabric.Image.filters');&#13;
      }&#13;
      else {&#13;
        callback &amp;&amp; callback();&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Object} [options] Object with width/height properties&#13;
     */&#13;
    _setWidthHeight: function(options) {&#13;
      this.width = 'width' in options&#13;
        ? options.width&#13;
        : (this.getElement()&#13;
          ? this.getElement().width || 0&#13;
          : 0);&#13;
&#13;
      this.height = 'height' in options&#13;
        ? options.height&#13;
        : (this.getElement()&#13;
          ? this.getElement().height || 0&#13;
          : 0);&#13;
    },&#13;
&#13;
    /**&#13;
     * Calculate offset for center and scale factor for the image in order to respect&#13;
     * the preserveAspectRatio attribute&#13;
     * @private&#13;
     * @return {Object}&#13;
     */&#13;
    parsePreserveAspectRatioAttribute: function() {&#13;
      var pAR = fabric.util.parsePreserveAspectRatioAttribute(this.preserveAspectRatio || ''),&#13;
          rWidth = this._element.width, rHeight = this._element.height,&#13;
          scaleX = 1, scaleY = 1, offsetLeft = 0, offsetTop = 0, cropX = 0, cropY = 0,&#13;
          offset, pWidth = this.width, pHeight = this.height, parsedAttributes = { width: pWidth, height: pHeight };&#13;
      if (pAR &amp;&amp; (pAR.alignX !== 'none' || pAR.alignY !== 'none')) {&#13;
        if (pAR.meetOrSlice === 'meet') {&#13;
          scaleX = scaleY = fabric.util.findScaleToFit(this._element, parsedAttributes);&#13;
          offset = (pWidth - rWidth * scaleX) / 2;&#13;
          if (pAR.alignX === 'Min') {&#13;
            offsetLeft = -offset;&#13;
          }&#13;
          if (pAR.alignX === 'Max') {&#13;
            offsetLeft = offset;&#13;
          }&#13;
          offset = (pHeight - rHeight * scaleY) / 2;&#13;
          if (pAR.alignY === 'Min') {&#13;
            offsetTop = -offset;&#13;
          }&#13;
          if (pAR.alignY === 'Max') {&#13;
            offsetTop = offset;&#13;
          }&#13;
        }&#13;
        if (pAR.meetOrSlice === 'slice') {&#13;
          scaleX = scaleY = fabric.util.findScaleToCover(this._element, parsedAttributes);&#13;
          offset = rWidth - pWidth / scaleX;&#13;
          if (pAR.alignX === 'Mid') {&#13;
            cropX = offset / 2;&#13;
          }&#13;
          if (pAR.alignX === 'Max') {&#13;
            cropX = offset;&#13;
          }&#13;
          offset = rHeight - pHeight / scaleY;&#13;
          if (pAR.alignY === 'Mid') {&#13;
            cropY = offset / 2;&#13;
          }&#13;
          if (pAR.alignY === 'Max') {&#13;
            cropY = offset;&#13;
          }&#13;
          rWidth = pWidth / scaleX;&#13;
          rHeight = pHeight / scaleY;&#13;
        }&#13;
      }&#13;
      else {&#13;
        scaleX = pWidth / rWidth;&#13;
        scaleY = pHeight / rHeight;&#13;
      }&#13;
      return {&#13;
        width: rWidth,&#13;
        height: rHeight,&#13;
        scaleX: scaleX,&#13;
        scaleY: scaleY,&#13;
        offsetLeft: offsetLeft,&#13;
        offsetTop: offsetTop,&#13;
        cropX: cropX,&#13;
        cropY: cropY&#13;
      };&#13;
    }&#13;
  });&#13;
&#13;
  /**&#13;
   * Default CSS class name for canvas&#13;
   * @static&#13;
   * @type String&#13;
   * @default&#13;
   */&#13;
  fabric.Image.CSS_CANVAS = 'canvas-img';&#13;
&#13;
  /**&#13;
   * Alias for getSrc&#13;
   * @static&#13;
   */&#13;
  fabric.Image.prototype.getSvgSrc = fabric.Image.prototype.getSrc;&#13;
&#13;
  /**&#13;
   * Creates an instance of fabric.Image from its object representation&#13;
   * @static&#13;
   * @param {Object} object Object to create an instance from&#13;
   * @param {Function} callback Callback to invoke when an image instance is created&#13;
   */&#13;
  fabric.Image.fromObject = function(object, callback) {&#13;
    fabric.util.loadImage(object.src, function(img, error) {&#13;
      if (error) {&#13;
        callback &amp;&amp; callback(null, error);&#13;
        return;&#13;
      }&#13;
      fabric.Image.prototype._initFilters.call(object, object.filters, function(filters) {&#13;
        object.filters = filters || [];&#13;
        fabric.Image.prototype._initFilters.call(object, [object.resizeFilter], function(resizeFilters) {&#13;
          object.resizeFilter = resizeFilters[0];&#13;
          var image = new fabric.Image(img, object);&#13;
          callback(image);&#13;
        });&#13;
      });&#13;
    }, null, object.crossOrigin);&#13;
  };&#13;
&#13;
  /**&#13;
   * Creates an instance of fabric.Image from an URL string&#13;
   * @static&#13;
   * @param {String} url URL to create an image from&#13;
   * @param {Function} [callback] Callback to invoke when image is created (newly created image is passed as a first argument)&#13;
   * @param {Object} [imgOptions] Options object&#13;
   */&#13;
  fabric.Image.fromURL = function(url, callback, imgOptions) {&#13;
    fabric.util.loadImage(url, function(img) {&#13;
      callback &amp;&amp; callback(new fabric.Image(img, imgOptions));&#13;
    }, null, imgOptions &amp;&amp; imgOptions.crossOrigin);&#13;
  };&#13;
&#13;
  /* _FROM_SVG_START_ */&#13;
  /**&#13;
   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Image.fromElement})&#13;
   * @static&#13;
   * @see {@link http://www.w3.org/TR/SVG/struct.html#ImageElement}&#13;
   */&#13;
  fabric.Image.ATTRIBUTE_NAMES =&#13;
    fabric.SHARED_ATTRIBUTES.concat('x y width height preserveAspectRatio xlink:href crossOrigin'.split(' '));&#13;
&#13;
  /**&#13;
   * Returns {@link fabric.Image} instance from an SVG element&#13;
   * @static&#13;
   * @param {SVGElement} element Element to parse&#13;
   * @param {Object} [options] Options object&#13;
   * @param {Function} callback Callback to execute when fabric.Image object is created&#13;
   * @return {fabric.Image} Instance of fabric.Image&#13;
   */&#13;
  fabric.Image.fromElement = function(element, callback, options) {&#13;
    var parsedAttributes = fabric.parseAttributes(element, fabric.Image.ATTRIBUTE_NAMES);&#13;
    fabric.Image.fromURL(parsedAttributes['xlink:href'], callback,&#13;
      extend((options ? fabric.util.object.clone(options) : { }), parsedAttributes));&#13;
  };&#13;
  /* _FROM_SVG_END_ */&#13;
&#13;
})(typeof exports !== 'undefined' ? exports : this);&#13;
&#13;
&#13;
fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {&#13;
&#13;
  /**&#13;
   * @private&#13;
   * @return {Number} angle value&#13;
   */&#13;
  _getAngleValueForStraighten: function() {&#13;
    var angle = this.angle % 360;&#13;
    if (angle &gt; 0) {&#13;
      return Math.round((angle - 1) / 90) * 90;&#13;
    }&#13;
    return Math.round(angle / 90) * 90;&#13;
  },&#13;
&#13;
  /**&#13;
   * Straightens an object (rotating it from current angle to one of 0, 90, 180, 270, etc. depending on which is closer)&#13;
   * @return {fabric.Object} thisArg&#13;
   * @chainable&#13;
   */&#13;
  straighten: function() {&#13;
    this.rotate(this._getAngleValueForStraighten());&#13;
    return this;&#13;
  },&#13;
&#13;
  /**&#13;
   * Same as {@link fabric.Object.prototype.straighten} but with animation&#13;
   * @param {Object} callbacks Object with callback functions&#13;
   * @param {Function} [callbacks.onComplete] Invoked on completion&#13;
   * @param {Function} [callbacks.onChange] Invoked on every step of animation&#13;
   * @return {fabric.Object} thisArg&#13;
   * @chainable&#13;
   */&#13;
  fxStraighten: function(callbacks) {&#13;
    callbacks = callbacks || { };&#13;
&#13;
    var empty = function() { },&#13;
        onComplete = callbacks.onComplete || empty,&#13;
        onChange = callbacks.onChange || empty,&#13;
        _this = this;&#13;
&#13;
    fabric.util.animate({&#13;
      startValue: this.get('angle'),&#13;
      endValue: this._getAngleValueForStraighten(),&#13;
      duration: this.FX_DURATION,&#13;
      onChange: function(value) {&#13;
        _this.rotate(value);&#13;
        onChange();&#13;
      },&#13;
      onComplete: function() {&#13;
        _this.setCoords();&#13;
        onComplete();&#13;
      },&#13;
    });&#13;
&#13;
    return this;&#13;
  }&#13;
});&#13;
&#13;
fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {&#13;
&#13;
  /**&#13;
   * Straightens object, then rerenders canvas&#13;
   * @param {fabric.Object} object Object to straighten&#13;
   * @return {fabric.Canvas} thisArg&#13;
   * @chainable&#13;
   */&#13;
  straightenObject: function (object) {&#13;
    object.straighten();&#13;
    this.requestRenderAll();&#13;
    return this;&#13;
  },&#13;
&#13;
  /**&#13;
   * Same as {@link fabric.Canvas.prototype.straightenObject}, but animated&#13;
   * @param {fabric.Object} object Object to straighten&#13;
   * @return {fabric.Canvas} thisArg&#13;
   * @chainable&#13;
   */&#13;
  fxStraightenObject: function (object) {&#13;
    object.fxStraighten({&#13;
      onChange: this.requestRenderAllBound&#13;
    });&#13;
    return this;&#13;
  }&#13;
});&#13;
&#13;
&#13;
(function() {&#13;
&#13;
  'use strict';&#13;
&#13;
  /**&#13;
   * Tests if webgl supports certain precision&#13;
   * @param {WebGL} Canvas WebGL context to test on&#13;
   * @param {String} Precision to test can be any of following: 'lowp', 'mediump', 'highp'&#13;
   * @returns {Boolean} Whether the user's browser WebGL supports given precision.&#13;
   */&#13;
  function testPrecision(gl, precision){&#13;
    var fragmentSource = 'precision ' + precision + ' float;\nvoid main(){}';&#13;
    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);&#13;
    gl.shaderSource(fragmentShader, fragmentSource);&#13;
    gl.compileShader(fragmentShader);&#13;
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {&#13;
      return false;&#13;
    }&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * Indicate whether this filtering backend is supported by the user's browser.&#13;
   * @param {Number} tileSize check if the tileSize is supported&#13;
   * @returns {Boolean} Whether the user's browser supports WebGL.&#13;
   */&#13;
  fabric.isWebglSupported = function(tileSize) {&#13;
    if (fabric.isLikelyNode) {&#13;
      return false;&#13;
    }&#13;
    tileSize = tileSize || fabric.WebglFilterBackend.prototype.tileSize;&#13;
    var canvas = document.createElement('canvas');&#13;
    var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');&#13;
    var isSupported = false;&#13;
    // eslint-disable-next-line&#13;
    if (gl) {&#13;
      fabric.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);&#13;
      isSupported = fabric.maxTextureSize &gt;= tileSize;&#13;
      var precisions = ['highp', 'mediump', 'lowp'];&#13;
      for (var i = 0; i &lt; 3; i++){&#13;
        if (testPrecision(gl, precisions[i])){&#13;
          fabric.webGlPrecision = precisions[i];&#13;
          break;&#13;
        };&#13;
      }&#13;
    }&#13;
    this.isSupported = isSupported;&#13;
    return isSupported;&#13;
  };&#13;
&#13;
  fabric.WebglFilterBackend = WebglFilterBackend;&#13;
&#13;
  /**&#13;
   * WebGL filter backend.&#13;
   */&#13;
  function WebglFilterBackend(options) {&#13;
    if (options &amp;&amp; options.tileSize) {&#13;
      this.tileSize = options.tileSize;&#13;
    }&#13;
    this.setupGLContext(this.tileSize, this.tileSize);&#13;
    this.captureGPUInfo();&#13;
  };&#13;
&#13;
  WebglFilterBackend.prototype = /** @lends fabric.WebglFilterBackend.prototype */ {&#13;
&#13;
    tileSize: 2048,&#13;
&#13;
    /**&#13;
     * Experimental. This object is a sort of repository of help layers used to avoid&#13;
     * of recreating them during frequent filtering. If you are previewing a filter with&#13;
     * a slider you problably do not want to create help layers every filter step.&#13;
     * in this object there will be appended some canvases, created once, resized sometimes&#13;
     * cleared never. Clearing is left to the developer.&#13;
     **/&#13;
    resources: {&#13;
&#13;
    },&#13;
&#13;
    /**&#13;
     * Setup a WebGL context suitable for filtering, and bind any needed event handlers.&#13;
     */&#13;
    setupGLContext: function(width, height) {&#13;
      this.dispose();&#13;
      this.createWebGLCanvas(width, height);&#13;
      // eslint-disable-next-line&#13;
      this.aPosition = new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]);&#13;
      this.chooseFastestCopyGLTo2DMethod(width, height);&#13;
    },&#13;
&#13;
    /**&#13;
     * Pick a method to copy data from GL context to 2d canvas.  In some browsers using&#13;
     * putImageData is faster than drawImage for that specific operation.&#13;
     */&#13;
    chooseFastestCopyGLTo2DMethod: function(width, height) {&#13;
      var canMeasurePerf = typeof window.performance !== 'undefined';&#13;
      var canUseImageData;&#13;
      try {&#13;
        new ImageData(1, 1);&#13;
        canUseImageData = true;&#13;
      }&#13;
      catch (e) {&#13;
        canUseImageData = false;&#13;
      }&#13;
      // eslint-disable-next-line no-undef&#13;
      var canUseArrayBuffer = typeof ArrayBuffer !== 'undefined';&#13;
      // eslint-disable-next-line no-undef&#13;
      var canUseUint8Clamped = typeof Uint8ClampedArray !== 'undefined';&#13;
&#13;
      if (!(canMeasurePerf &amp;&amp; canUseImageData &amp;&amp; canUseArrayBuffer &amp;&amp; canUseUint8Clamped)) {&#13;
        return;&#13;
      }&#13;
&#13;
      var targetCanvas = fabric.util.createCanvasElement();&#13;
      // eslint-disable-next-line no-undef&#13;
      var imageBuffer = new ArrayBuffer(width * height * 4);&#13;
      var testContext = {&#13;
        imageBuffer: imageBuffer,&#13;
        destinationWidth: width,&#13;
        destinationHeight: height,&#13;
        targetCanvas: targetCanvas&#13;
      };&#13;
      var startTime, drawImageTime, putImageDataTime;&#13;
      targetCanvas.width = width;&#13;
      targetCanvas.height = height;&#13;
&#13;
      startTime = window.performance.now();&#13;
      copyGLTo2DDrawImage.call(testContext, this.gl, testContext);&#13;
      drawImageTime = window.performance.now() - startTime;&#13;
&#13;
      startTime = window.performance.now();&#13;
      copyGLTo2DPutImageData.call(testContext, this.gl, testContext);&#13;
      putImageDataTime = window.performance.now() - startTime;&#13;
&#13;
      if (drawImageTime &gt; putImageDataTime) {&#13;
        this.imageBuffer = imageBuffer;&#13;
        this.copyGLTo2D = copyGLTo2DPutImageData;&#13;
      }&#13;
      else {&#13;
        this.copyGLTo2D = copyGLTo2DDrawImage;&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Create a canvas element and associated WebGL context and attaches them as&#13;
     * class properties to the GLFilterBackend class.&#13;
     */&#13;
    createWebGLCanvas: function(width, height) {&#13;
      var canvas = fabric.util.createCanvasElement();&#13;
      canvas.width = width;&#13;
      canvas.height = height;&#13;
      var glOptions = { premultipliedAlpha: false },&#13;
          gl = canvas.getContext('webgl', glOptions);&#13;
      if (!gl) {&#13;
        gl = canvas.getContext('experimental-webgl', glOptions);&#13;
      }&#13;
      if (!gl) {&#13;
        return;&#13;
      }&#13;
      gl.clearColor(0, 0, 0, 0);&#13;
      // this canvas can fire webglcontextlost and webglcontextrestored&#13;
      this.canvas = canvas;&#13;
      this.gl = gl;&#13;
    },&#13;
&#13;
    /**&#13;
     * Attempts to apply the requested filters to the source provided, drawing the filtered output&#13;
     * to the provided target canvas.&#13;
     *&#13;
     * @param {Array} filters The filters to apply.&#13;
     * @param {HTMLImageElement|HTMLCanvasElement} source The source to be filtered.&#13;
     * @param {Number} width The width of the source input.&#13;
     * @param {Number} height The height of the source input.&#13;
     * @param {HTMLCanvasElement} targetCanvas The destination for filtered output to be drawn.&#13;
     * @param {String|undefined} cacheKey A key used to cache resources related to the source. If&#13;
     * omitted, caching will be skipped.&#13;
     */&#13;
    applyFilters: function(filters, source, width, height, targetCanvas, cacheKey) {&#13;
      var gl = this.gl;&#13;
      var cachedTexture;&#13;
      if (cacheKey) {&#13;
        cachedTexture = this.getCachedTexture(cacheKey, source);&#13;
      }&#13;
      var pipelineState = {&#13;
        originalWidth: source.width || source.originalWidth,&#13;
        originalHeight: source.height || source.originalHeight,&#13;
        sourceWidth: width,&#13;
        sourceHeight: height,&#13;
        destinationWidth: width,&#13;
        destinationHeight: height,&#13;
        context: gl,&#13;
        sourceTexture: this.createTexture(gl, width, height, !cachedTexture &amp;&amp; source),&#13;
        targetTexture: this.createTexture(gl, width, height),&#13;
        originalTexture: cachedTexture ||&#13;
          this.createTexture(gl, width, height, !cachedTexture &amp;&amp; source),&#13;
        passes: filters.length,&#13;
        webgl: true,&#13;
        aPosition: this.aPosition,&#13;
        programCache: this.programCache,&#13;
        pass: 0,&#13;
        filterBackend: this,&#13;
        targetCanvas: targetCanvas&#13;
      };&#13;
      var tempFbo = gl.createFramebuffer();&#13;
      gl.bindFramebuffer(gl.FRAMEBUFFER, tempFbo);&#13;
      filters.forEach(function(filter) { filter &amp;&amp; filter.applyTo(pipelineState); });&#13;
      resizeCanvasIfNeeded(pipelineState);&#13;
      this.copyGLTo2D(gl, pipelineState);&#13;
      gl.bindTexture(gl.TEXTURE_2D, null);&#13;
      gl.deleteTexture(pipelineState.sourceTexture);&#13;
      gl.deleteTexture(pipelineState.targetTexture);&#13;
      gl.deleteFramebuffer(tempFbo);&#13;
      targetCanvas.getContext('2d').setTransform(1, 0, 0, 1, 0, 0);&#13;
      return pipelineState;&#13;
    },&#13;
&#13;
    /**&#13;
     * The same as the applyFilter method but with additional logging of WebGL&#13;
     * errors.&#13;
     */&#13;
    applyFiltersDebug: function(filters, source, width, height, targetCanvas, cacheKey) {&#13;
      // The following code is useful when debugging a specific issue but adds ~10x slowdown.&#13;
      var gl = this.gl;&#13;
      var ret = this.applyFilters(filters, source, width, height, targetCanvas, cacheKey);&#13;
      var glError = gl.getError();&#13;
      if (glError !== gl.NO_ERROR) {&#13;
        var errorString = this.glErrorToString(gl, glError);&#13;
        var error = new Error('WebGL Error ' + errorString);&#13;
        error.glErrorCode = glError;&#13;
        throw error;&#13;
      }&#13;
      return ret;&#13;
    },&#13;
&#13;
    glErrorToString: function(context, errorCode) {&#13;
      if (!context) {&#13;
        return 'Context undefined for error code: ' + errorCode;&#13;
      }&#13;
      else if (typeof errorCode !== 'number') {&#13;
        return 'Error code is not a number';&#13;
      }&#13;
      switch (errorCode) {&#13;
        case context.NO_ERROR:&#13;
          return 'NO_ERROR';&#13;
        case context.INVALID_ENUM:&#13;
          return 'INVALID_ENUM';&#13;
        case context.INVALID_VALUE:&#13;
          return 'INVALID_VALUE';&#13;
        case context.INVALID_OPERATION:&#13;
          return 'INVALID_OPERATION';&#13;
        case context.INVALID_FRAMEBUFFER_OPERATION:&#13;
          return 'INVALID_FRAMEBUFFER_OPERATION';&#13;
        case context.OUT_OF_MEMORY:&#13;
          return 'OUT_OF_MEMORY';&#13;
        case context.CONTEXT_LOST_WEBGL:&#13;
          return 'CONTEXT_LOST_WEBGL';&#13;
        default:&#13;
          return 'UNKNOWN_ERROR';&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Detach event listeners, remove references, and clean up caches.&#13;
     */&#13;
    dispose: function() {&#13;
      if (this.canvas) {&#13;
        this.canvas = null;&#13;
        this.gl = null;&#13;
      }&#13;
      this.clearWebGLCaches();&#13;
    },&#13;
&#13;
    /**&#13;
     * Wipe out WebGL-related caches.&#13;
     */&#13;
    clearWebGLCaches: function() {&#13;
      this.programCache = {};&#13;
      this.textureCache = {};&#13;
    },&#13;
&#13;
    /**&#13;
     * Create a WebGL texture object.&#13;
     *&#13;
     * Accepts specific dimensions to initialize the textuer to or a source image.&#13;
     *&#13;
     * @param {WebGLRenderingContext} gl The GL context to use for creating the texture.&#13;
     * @param {Number} width The width to initialize the texture at.&#13;
     * @param {Number} height The height to initialize the texture.&#13;
     * @param {HTMLImageElement|HTMLCanvasElement} textureImageSource A source for the texture data.&#13;
     * @returns {WebGLTexture}&#13;
     */&#13;
    createTexture: function(gl, width, height, textureImageSource) {&#13;
      var texture = gl.createTexture();&#13;
      gl.bindTexture(gl.TEXTURE_2D, texture);&#13;
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);&#13;
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);&#13;
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);&#13;
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);&#13;
      if (textureImageSource) {&#13;
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImageSource);&#13;
      }&#13;
      else {&#13;
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);&#13;
      }&#13;
      return texture;&#13;
    },&#13;
&#13;
    /**&#13;
     * Can be optionally used to get a texture from the cache array&#13;
     *&#13;
     * If an existing texture is not found, a new texture is created and cached.&#13;
     *&#13;
     * @param {String} uniqueId A cache key to use to find an existing texture.&#13;
     * @param {HTMLImageElement|HTMLCanvasElement} textureImageSource A source to use to create the&#13;
     * texture cache entry if one does not already exist.&#13;
     */&#13;
    getCachedTexture: function(uniqueId, textureImageSource) {&#13;
      if (this.textureCache[uniqueId]) {&#13;
        return this.textureCache[uniqueId];&#13;
      }&#13;
      else {&#13;
        var texture = this.createTexture(&#13;
          this.gl, textureImageSource.width, textureImageSource.height, textureImageSource);&#13;
        this.textureCache[uniqueId] = texture;&#13;
        return texture;&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Clear out cached resources related to a source image that has been&#13;
     * filtered previously.&#13;
     *&#13;
     * @param {String} cacheKey The cache key provided when the source image was filtered.&#13;
     */&#13;
    evictCachesForKey: function(cacheKey) {&#13;
      if (this.textureCache[cacheKey]) {&#13;
        this.gl.deleteTexture(this.textureCache[cacheKey]);&#13;
        delete this.textureCache[cacheKey];&#13;
      }&#13;
    },&#13;
&#13;
    copyGLTo2D: copyGLTo2DDrawImage,&#13;
&#13;
    /**&#13;
     * Attempt to extract GPU information strings from a WebGL context.&#13;
     *&#13;
     * Useful information when debugging or blacklisting specific GPUs.&#13;
     *&#13;
     * @returns {Object} A GPU info object with renderer and vendor strings.&#13;
     */&#13;
    captureGPUInfo: function() {&#13;
      if (this.gpuInfo) {&#13;
        return this.gpuInfo;&#13;
      }&#13;
      var gl = this.gl;&#13;
      var ext = gl.getExtension('WEBGL_debug_renderer_info');&#13;
      var gpuInfo = { renderer: '', vendor: '' };&#13;
      if (ext) {&#13;
        var renderer = gl.getParameter(ext.UNMASKED_RENDERER_WEBGL);&#13;
        var vendor = gl.getParameter(ext.UNMASKED_VENDOR_WEBGL);&#13;
        if (renderer) {&#13;
          gpuInfo.renderer = renderer.toLowerCase();&#13;
        }&#13;
        if (vendor) {&#13;
          gpuInfo.vendor = vendor.toLowerCase();&#13;
        }&#13;
      }&#13;
      this.gpuInfo = gpuInfo;&#13;
      return gpuInfo;&#13;
    },&#13;
  };&#13;
})();&#13;
&#13;
function resizeCanvasIfNeeded(pipelineState) {&#13;
  var targetCanvas = pipelineState.targetCanvas,&#13;
      width = targetCanvas.width, height = targetCanvas.height,&#13;
      dWidth = pipelineState.destinationWidth,&#13;
      dHeight = pipelineState.destinationHeight;&#13;
&#13;
  if (width !== dWidth || height !== dHeight) {&#13;
    targetCanvas.width = dWidth;&#13;
    targetCanvas.height = dHeight;&#13;
  }&#13;
}&#13;
&#13;
/**&#13;
 * Copy an input WebGL canvas on to an output 2D canvas.&#13;
 *&#13;
 * The WebGL canvas is assumed to be upside down, with the top-left pixel of the&#13;
 * desired output image appearing in the bottom-left corner of the WebGL canvas.&#13;
 *&#13;
 * @param {WebGLRenderingContext} sourceContext The WebGL context to copy from.&#13;
 * @param {HTMLCanvasElement} targetCanvas The 2D target canvas to copy on to.&#13;
 * @param {Object} pipelineState The 2D target canvas to copy on to.&#13;
 */&#13;
function copyGLTo2DDrawImage(gl, pipelineState) {&#13;
  var glCanvas = gl.canvas, targetCanvas = pipelineState.targetCanvas,&#13;
      ctx = targetCanvas.getContext('2d');&#13;
  ctx.translate(0, targetCanvas.height); // move it down again&#13;
  ctx.scale(1, -1); // vertical flip&#13;
  // where is my image on the big glcanvas?&#13;
  var sourceY = glCanvas.height - targetCanvas.height;&#13;
  ctx.drawImage(glCanvas, 0, sourceY, targetCanvas.width, targetCanvas.height, 0, 0,&#13;
    targetCanvas.width, targetCanvas.height);&#13;
}&#13;
&#13;
/**&#13;
 * Copy an input WebGL canvas on to an output 2D canvas using 2d canvas' putImageData&#13;
 * API. Measurably faster than using ctx.drawImage in Firefox (version 54 on OSX Sierra).&#13;
 *&#13;
 * @param {WebGLRenderingContext} sourceContext The WebGL context to copy from.&#13;
 * @param {HTMLCanvasElement} targetCanvas The 2D target canvas to copy on to.&#13;
 * @param {Object} pipelineState The 2D target canvas to copy on to.&#13;
 */&#13;
function copyGLTo2DPutImageData(gl, pipelineState) {&#13;
  var targetCanvas = pipelineState.targetCanvas, ctx = targetCanvas.getContext('2d'),&#13;
      dWidth = pipelineState.destinationWidth,&#13;
      dHeight = pipelineState.destinationHeight,&#13;
      numBytes = dWidth * dHeight * 4;&#13;
&#13;
  // eslint-disable-next-line no-undef&#13;
  var u8 = new Uint8Array(this.imageBuffer, 0, numBytes);&#13;
  // eslint-disable-next-line no-undef&#13;
  var u8Clamped = new Uint8ClampedArray(this.imageBuffer, 0, numBytes);&#13;
&#13;
  gl.readPixels(0, 0, dWidth, dHeight, gl.RGBA, gl.UNSIGNED_BYTE, u8);&#13;
  var imgData = new ImageData(u8Clamped, dWidth, dHeight);&#13;
  ctx.putImageData(imgData, 0, 0);&#13;
}&#13;
&#13;
&#13;
(function() {&#13;
&#13;
  'use strict';&#13;
&#13;
  var noop = function() {};&#13;
&#13;
  fabric.Canvas2dFilterBackend = Canvas2dFilterBackend;&#13;
&#13;
  /**&#13;
   * Canvas 2D filter backend.&#13;
   */&#13;
  function Canvas2dFilterBackend() {};&#13;
&#13;
  Canvas2dFilterBackend.prototype = /** @lends fabric.Canvas2dFilterBackend.prototype */ {&#13;
    evictCachesForKey: noop,&#13;
    dispose: noop,&#13;
    clearWebGLCaches: noop,&#13;
&#13;
    /**&#13;
     * Experimental. This object is a sort of repository of help layers used to avoid&#13;
     * of recreating them during frequent filtering. If you are previewing a filter with&#13;
     * a slider you probably do not want to create help layers every filter step.&#13;
     * in this object there will be appended some canvases, created once, resized sometimes&#13;
     * cleared never. Clearing is left to the developer.&#13;
     **/&#13;
    resources: {&#13;
&#13;
    },&#13;
&#13;
    /**&#13;
     * Apply a set of filters against a source image and draw the filtered output&#13;
     * to the provided destination canvas.&#13;
     *&#13;
     * @param {EnhancedFilter} filters The filter to apply.&#13;
     * @param {HTMLImageElement|HTMLCanvasElement} sourceElement The source to be filtered.&#13;
     * @param {Number} sourceWidth The width of the source input.&#13;
     * @param {Number} sourceHeight The height of the source input.&#13;
     * @param {HTMLCanvasElement} targetCanvas The destination for filtered output to be drawn.&#13;
     */&#13;
    applyFilters: function(filters, sourceElement, sourceWidth, sourceHeight, targetCanvas) {&#13;
      var ctx = targetCanvas.getContext('2d');&#13;
      ctx.drawImage(sourceElement, 0, 0, sourceWidth, sourceHeight);&#13;
      var imageData = ctx.getImageData(0, 0, sourceWidth, sourceHeight);&#13;
      var originalImageData = ctx.getImageData(0, 0, sourceWidth, sourceHeight);&#13;
      var pipelineState = {&#13;
        sourceWidth: sourceWidth,&#13;
        sourceHeight: sourceHeight,&#13;
        imageData: imageData,&#13;
        originalEl: sourceElement,&#13;
        originalImageData: originalImageData,&#13;
        canvasEl: targetCanvas,&#13;
        ctx: ctx,&#13;
        filterBackend: this,&#13;
      };&#13;
      filters.forEach(function(filter) { filter.applyTo(pipelineState); });&#13;
      if (pipelineState.imageData.width !== sourceWidth || pipelineState.imageData.height !== sourceHeight) {&#13;
        targetCanvas.width = pipelineState.imageData.width;&#13;
        targetCanvas.height = pipelineState.imageData.height;&#13;
      }&#13;
      ctx.putImageData(pipelineState.imageData, 0, 0);&#13;
      return pipelineState;&#13;
    },&#13;
&#13;
  };&#13;
})();&#13;
&#13;
&#13;
/**&#13;
 * @namespace fabric.Image.filters&#13;
 * @memberOf fabric.Image&#13;
 * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#image_filters}&#13;
 * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}&#13;
 */&#13;
fabric.Image.filters = fabric.Image.filters || { };&#13;
&#13;
/**&#13;
 * Root filter class from which all filter classes inherit from&#13;
 * @class fabric.Image.filters.BaseFilter&#13;
 * @memberOf fabric.Image.filters&#13;
 */&#13;
fabric.Image.filters.BaseFilter = fabric.util.createClass(/** @lends fabric.Image.filters.BaseFilter.prototype */ {&#13;
&#13;
  /**&#13;
   * Filter type&#13;
   * @param {String} type&#13;
   * @default&#13;
   */&#13;
  type: 'BaseFilter',&#13;
&#13;
  /**&#13;
   * Array of attributes to send with buffers. do not modify&#13;
   * @private&#13;
   */&#13;
&#13;
  vertexSource: 'attribute vec2 aPosition;\n' +&#13;
    'varying vec2 vTexCoord;\n' +&#13;
    'void main() {\n' +&#13;
      'vTexCoord = aPosition;\n' +&#13;
      'gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\n' +&#13;
    '}',&#13;
&#13;
  fragmentSource: 'precision highp float;\n' +&#13;
    'varying vec2 vTexCoord;\n' +&#13;
    'uniform sampler2D uTexture;\n' +&#13;
    'void main() {\n' +&#13;
      'gl_FragColor = texture2D(uTexture, vTexCoord);\n' +&#13;
    '}',&#13;
&#13;
  /**&#13;
   * Constructor&#13;
   * @param {Object} [options] Options object&#13;
   */&#13;
  initialize: function(options) {&#13;
    if (options) {&#13;
      this.setOptions(options);&#13;
    }&#13;
  },&#13;
&#13;
  /**&#13;
   * Sets filter's properties from options&#13;
   * @param {Object} [options] Options object&#13;
   */&#13;
  setOptions: function(options) {&#13;
    for (var prop in options) {&#13;
      this[prop] = options[prop];&#13;
    }&#13;
  },&#13;
&#13;
  /**&#13;
   * Compile this filter's shader program.&#13;
   *&#13;
   * @param {WebGLRenderingContext} gl The GL canvas context to use for shader compilation.&#13;
   * @param {String} fragmentSource fragmentShader source for compilation&#13;
   * @param {String} vertexSource vertexShader source for compilation&#13;
   */&#13;
  createProgram: function(gl, fragmentSource, vertexSource) {&#13;
    fragmentSource = fragmentSource || this.fragmentSource;&#13;
    vertexSource = vertexSource || this.vertexSource;&#13;
    if (fabric.webGlPrecision !== 'highp'){&#13;
      fragmentSource = fragmentSource.replace(&#13;
        /precision highp float/g,&#13;
        'precision ' + fabric.webGlPrecision + ' float'&#13;
      );&#13;
    }&#13;
    var vertexShader = gl.createShader(gl.VERTEX_SHADER);&#13;
    gl.shaderSource(vertexShader, vertexSource);&#13;
    gl.compileShader(vertexShader);&#13;
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {&#13;
      throw new Error(&#13;
        // eslint-disable-next-line prefer-template&#13;
        'Vertex shader compile error for ' + this.type + ': ' +&#13;
        gl.getShaderInfoLog(vertexShader)&#13;
      );&#13;
    }&#13;
&#13;
    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);&#13;
    gl.shaderSource(fragmentShader, fragmentSource);&#13;
    gl.compileShader(fragmentShader);&#13;
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {&#13;
      throw new Error(&#13;
        // eslint-disable-next-line prefer-template&#13;
        'Fragment shader compile error for ' + this.type + ': ' +&#13;
        gl.getShaderInfoLog(fragmentShader)&#13;
      );&#13;
    }&#13;
&#13;
    var program = gl.createProgram();&#13;
    gl.attachShader(program, vertexShader);&#13;
    gl.attachShader(program, fragmentShader);&#13;
    gl.linkProgram(program);&#13;
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {&#13;
      throw new Error(&#13;
        // eslint-disable-next-line prefer-template&#13;
        'Shader link error for "${this.type}" ' +&#13;
        gl.getProgramInfoLog(program)&#13;
      );&#13;
    }&#13;
&#13;
    var attributeLocations = this.getAttributeLocations(gl, program);&#13;
    var uniformLocations = this.getUniformLocations(gl, program) || { };&#13;
    uniformLocations.uStepW = gl.getUniformLocation(program, 'uStepW');&#13;
    uniformLocations.uStepH = gl.getUniformLocation(program, 'uStepH');&#13;
    return {&#13;
      program: program,&#13;
      attributeLocations: attributeLocations,&#13;
      uniformLocations: uniformLocations&#13;
    };&#13;
  },&#13;
&#13;
  /**&#13;
   * Return a map of attribute names to WebGLAttributeLocation objects.&#13;
   *&#13;
   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.&#13;
   * @param {WebGLShaderProgram} program The shader program from which to take attribute locations.&#13;
   * @returns {Object} A map of attribute names to attribute locations.&#13;
   */&#13;
  getAttributeLocations: function(gl, program) {&#13;
    return {&#13;
      aPosition: gl.getAttribLocation(program, 'aPosition'),&#13;
    };&#13;
  },&#13;
&#13;
  /**&#13;
   * Return a map of uniform names to WebGLUniformLocation objects.&#13;
   *&#13;
   * Intended to be overridden by subclasses.&#13;
   *&#13;
   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.&#13;
   * @param {WebGLShaderProgram} program The shader program from which to take uniform locations.&#13;
   * @returns {Object} A map of uniform names to uniform locations.&#13;
   */&#13;
  getUniformLocations: function (/* gl, program */) {&#13;
    // in case i do not need any special uniform i need to return an empty object&#13;
    return { };&#13;
  },&#13;
&#13;
  /**&#13;
   * Send attribute data from this filter to its shader program on the GPU.&#13;
   *&#13;
   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.&#13;
   * @param {Object} attributeLocations A map of shader attribute names to their locations.&#13;
   */&#13;
  sendAttributeData: function(gl, attributeLocations, aPositionData) {&#13;
    var attributeLocation = attributeLocations.aPostion;&#13;
    var buffer = gl.createBuffer();&#13;
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);&#13;
    gl.enableVertexAttribArray(attributeLocation);&#13;
    gl.vertexAttribPointer(attributeLocation, 2, gl.FLOAT, false, 0, 0);&#13;
    gl.bufferData(gl.ARRAY_BUFFER, aPositionData, gl.STATIC_DRAW);&#13;
  },&#13;
&#13;
  _setupFrameBuffer: function(options) {&#13;
    var gl = options.context, width, height;&#13;
    if (options.passes &gt; 1) {&#13;
      width = options.destinationWidth;&#13;
      height = options.destinationHeight;&#13;
      if (options.sourceWidth !== width || options.sourceHeight !== height) {&#13;
        gl.deleteTexture(options.targetTexture);&#13;
        options.targetTexture = options.filterBackend.createTexture(gl, width, height);&#13;
      }&#13;
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D,&#13;
        options.targetTexture, 0);&#13;
    }&#13;
    else {&#13;
      // draw last filter on canvas and not to framebuffer.&#13;
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);&#13;
      gl.finish();&#13;
    }&#13;
  },&#13;
&#13;
  _swapTextures: function(options) {&#13;
    options.passes--;&#13;
    options.pass++;&#13;
    var temp = options.targetTexture;&#13;
    options.targetTexture = options.sourceTexture;&#13;
    options.sourceTexture = temp;&#13;
  },&#13;
&#13;
  /**&#13;
   * Intentionally left blank, to be overridden in custom filters&#13;
   * @param {Object} options&#13;
   **/&#13;
  isNeutralState: function(/* options */) {&#13;
    return false;&#13;
  },&#13;
&#13;
  /**&#13;
   * Apply this filter to the input image data provided.&#13;
   *&#13;
   * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.&#13;
   *&#13;
   * @param {Object} options&#13;
   * @param {Number} options.passes The number of filters remaining to be executed&#13;
   * @param {Boolean} options.webgl Whether to use webgl to render the filter.&#13;
   * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.&#13;
   * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.&#13;
   * @param {WebGLRenderingContext} options.context The GL context used for rendering.&#13;
   * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.&#13;
   */&#13;
  applyTo: function(options) {&#13;
    if (options.webgl) {&#13;
      if (options.passes &gt; 1 &amp;&amp; this.isNeutralState(options)) {&#13;
        // avoid doing something that we do not need&#13;
        return;&#13;
      }&#13;
      this._setupFrameBuffer(options);&#13;
      this.applyToWebGL(options);&#13;
      this._swapTextures(options);&#13;
    }&#13;
    else if (!this.isNeutralState()) {&#13;
      this.applyTo2d(options);&#13;
    }&#13;
  },&#13;
&#13;
  /**&#13;
   * Retrieves the cached shader.&#13;
   * @param {Object} options&#13;
   * @param {WebGLRenderingContext} options.context The GL context used for rendering.&#13;
   * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.&#13;
   */&#13;
  retrieveShader: function(options) {&#13;
    if (!options.programCache.hasOwnProperty(this.type)) {&#13;
      options.programCache[this.type] = this.createProgram(options.context);&#13;
    }&#13;
    return options.programCache[this.type];&#13;
  },&#13;
&#13;
  /**&#13;
   * Apply this filter using webgl.&#13;
   *&#13;
   * @param {Object} options&#13;
   * @param {Number} options.passes The number of filters remaining to be executed&#13;
   * @param {Boolean} options.webgl Whether to use webgl to render the filter.&#13;
   * @param {WebGLTexture} options.originalTexture The texture of the original input image.&#13;
   * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.&#13;
   * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.&#13;
   * @param {WebGLRenderingContext} options.context The GL context used for rendering.&#13;
   * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.&#13;
   */&#13;
  applyToWebGL: function(options) {&#13;
    var gl = options.context;&#13;
    var shader = this.retrieveShader(options);&#13;
    if (options.pass === 0 &amp;&amp; options.originalTexture) {&#13;
      gl.bindTexture(gl.TEXTURE_2D, options.originalTexture);&#13;
    }&#13;
    else {&#13;
      gl.bindTexture(gl.TEXTURE_2D, options.sourceTexture);&#13;
    }&#13;
    gl.useProgram(shader.program);&#13;
    this.sendAttributeData(gl, shader.attributeLocations, options.aPosition);&#13;
&#13;
    gl.uniform1f(shader.uniformLocations.uStepW, 1 / options.sourceWidth);&#13;
    gl.uniform1f(shader.uniformLocations.uStepH, 1 / options.sourceHeight);&#13;
&#13;
    this.sendUniformData(gl, shader.uniformLocations);&#13;
    gl.viewport(0, 0, options.destinationWidth, options.destinationHeight);&#13;
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);&#13;
  },&#13;
&#13;
  bindAdditionalTexture: function(gl, texture, textureUnit) {&#13;
    gl.activeTexture(textureUnit);&#13;
    gl.bindTexture(gl.TEXTURE_2D, texture);&#13;
    // reset active texture to 0 as usual&#13;
    gl.activeTexture(gl.TEXTURE0);&#13;
  },&#13;
&#13;
  unbindAdditionalTexture: function(gl, textureUnit) {&#13;
    gl.activeTexture(textureUnit);&#13;
    gl.bindTexture(gl.TEXTURE_2D, null);&#13;
    gl.activeTexture(gl.TEXTURE0);&#13;
  },&#13;
&#13;
  getMainParameter: function() {&#13;
    return this[this.mainParameter];&#13;
  },&#13;
&#13;
  setMainParameter: function(value) {&#13;
    this[this.mainParameter] = value;&#13;
  },&#13;
&#13;
  /**&#13;
   * Send uniform data from this filter to its shader program on the GPU.&#13;
   *&#13;
   * Intended to be overridden by subclasses.&#13;
   *&#13;
   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.&#13;
   * @param {Object} uniformLocations A map of shader uniform names to their locations.&#13;
   */&#13;
  sendUniformData: function(/* gl, uniformLocations */) {&#13;
    // Intentionally left blank.  Override me in subclasses.&#13;
  },&#13;
&#13;
  /**&#13;
   * If needed by a 2d filter, this functions can create an helper canvas to be used&#13;
   * remember that options.targetCanvas is available for use till end of chain.&#13;
   */&#13;
  createHelpLayer: function(options) {&#13;
    if (!options.helpLayer) {&#13;
      var helpLayer = document.createElement('canvas');&#13;
      helpLayer.width = options.sourceWidth;&#13;
      helpLayer.height = options.sourceHeight;&#13;
      options.helpLayer = helpLayer;&#13;
    }&#13;
  },&#13;
&#13;
  /**&#13;
   * Returns object representation of an instance&#13;
   * @return {Object} Object representation of an instance&#13;
   */&#13;
  toObject: function() {&#13;
    var object = { type: this.type }, mainP = this.mainParameter;&#13;
    if (mainP) {&#13;
      object[mainP] = this[mainP];&#13;
    }&#13;
    return object;&#13;
  },&#13;
&#13;
  /**&#13;
   * Returns a JSON representation of an instance&#13;
   * @return {Object} JSON&#13;
   */&#13;
  toJSON: function() {&#13;
    // delegate, not alias&#13;
    return this.toObject();&#13;
  }&#13;
});&#13;
&#13;
fabric.Image.filters.BaseFilter.fromObject = function(object, callback) {&#13;
  var filter = new fabric.Image.filters[object.type](object);&#13;
  callback &amp;&amp; callback(filter);&#13;
  return filter;&#13;
};&#13;
&#13;
&#13;
(function(global) {&#13;
&#13;
  'use strict';&#13;
&#13;
  var fabric  = global.fabric || (global.fabric = { }),&#13;
      filters = fabric.Image.filters,&#13;
      createClass = fabric.util.createClass;&#13;
&#13;
  /**&#13;
   * Color Matrix filter class&#13;
   * @class fabric.Image.filters.ColorMatrix&#13;
   * @memberOf fabric.Image.filters&#13;
   * @extends fabric.Image.filters.BaseFilter&#13;
   * @see {@link fabric.Image.filters.ColorMatrix#initialize} for constructor definition&#13;
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}&#13;
   * @see {@Link http://www.webwasp.co.uk/tutorials/219/Color_Matrix_Filter.php}&#13;
   * @see {@Link http://phoboslab.org/log/2013/11/fast-image-filters-with-webgl}&#13;
   * @example &lt;caption&gt;Kodachrome filter&lt;/caption&gt;&#13;
   * var filter = new fabric.Image.filters.ColorMatrix({&#13;
   *  matrix: [&#13;
       1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502,&#13;
       -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203,&#13;
       -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946,&#13;
       0, 0, 0, 1, 0&#13;
      ]&#13;
   * });&#13;
   * object.filters.push(filter);&#13;
   * object.applyFilters();&#13;
   */&#13;
  filters.ColorMatrix = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.ColorMatrix.prototype */ {&#13;
&#13;
    /**&#13;
     * Filter type&#13;
     * @param {String} type&#13;
     * @default&#13;
     */&#13;
    type: 'ColorMatrix',&#13;
&#13;
    fragmentSource: 'precision highp float;\n' +&#13;
      'uniform sampler2D uTexture;\n' +&#13;
      'varying vec2 vTexCoord;\n' +&#13;
      'uniform mat4 uColorMatrix;\n' +&#13;
      'uniform vec4 uConstants;\n' +&#13;
      'void main() {\n' +&#13;
        'vec4 color = texture2D(uTexture, vTexCoord);\n' +&#13;
        'color *= uColorMatrix;\n' +&#13;
        'color += uConstants;\n' +&#13;
        'gl_FragColor = color;\n' +&#13;
      '}',&#13;
&#13;
    /**&#13;
     * Colormatrix for pixels.&#13;
     * array of 20 floats. Numbers in positions 4, 9, 14, 19 loose meaning&#13;
     * outside the -1, 1 range.&#13;
     * 0.0039215686 is the part of 1 that get translated to 1 in 2d&#13;
     * @param {Array} matrix array of 20 numbers.&#13;
     * @default&#13;
     */&#13;
    matrix: [&#13;
      1, 0, 0, 0, 0,&#13;
      0, 1, 0, 0, 0,&#13;
      0, 0, 1, 0, 0,&#13;
      0, 0, 0, 1, 0&#13;
    ],&#13;
&#13;
    mainParameter: 'matrix',&#13;
&#13;
    /**&#13;
     * Lock the colormatrix on the color part, skipping alpha, manly for non webgl scenario&#13;
     * to save some calculation&#13;
     */&#13;
    colorsOnly: true,&#13;
&#13;
    /**&#13;
     * Constructor&#13;
     * @param {Object} [options] Options object&#13;
     */&#13;
    initialize: function(options) {&#13;
      this.callSuper('initialize', options);&#13;
      // create a new array instead mutating the prototype with push&#13;
      this.matrix = this.matrix.slice(0);&#13;
    },&#13;
&#13;
    /**&#13;
     * Intentionally left blank, to be overridden in custom filters&#13;
     * @param {Object} options&#13;
     **/&#13;
    isNeutralState: function(/* options */) {&#13;
      var _class = filters.ColorMatrix;&#13;
      for (var i = 20; i--;) {&#13;
        if (this.matrix[i] !== _class.prototype.matrix[i]) {&#13;
          return false;&#13;
        }&#13;
      }&#13;
      return true;&#13;
    },&#13;
&#13;
    /**&#13;
     * Apply the ColorMatrix operation to a Uint8Array representing the pixels of an image.&#13;
     *&#13;
     * @param {Object} options&#13;
     * @param {ImageData} options.imageData The Uint8Array to be filtered.&#13;
     */&#13;
    applyTo2d: function(options) {&#13;
      var imageData = options.imageData,&#13;
          data = imageData.data,&#13;
          iLen = data.length,&#13;
          m = this.matrix,&#13;
          r, g, b, a, i, colorsOnly = this.colorsOnly;&#13;
&#13;
      for (i = 0; i &lt; iLen; i += 4) {&#13;
        r = data[i];&#13;
        g = data[i + 1];&#13;
        b = data[i + 2];&#13;
        if (colorsOnly) {&#13;
          data[i] = r * m[0] + g * m[1] + b * m[2] + m[4] * 255;&#13;
          data[i + 1] = r * m[5] + g * m[6] + b * m[7] + m[9] * 255;&#13;
          data[i + 2] = r * m[10] + g * m[11] + b * m[12] + m[14] * 255;&#13;
        }&#13;
        else {&#13;
          a = data[i + 3];&#13;
          data[i] = r * m[0] + g * m[1] + b * m[2] + a * m[3] + m[4] * 255;&#13;
          data[i + 1] = r * m[5] + g * m[6] + b * m[7] + a * m[8] + m[9] * 255;&#13;
          data[i + 2] = r * m[10] + g * m[11] + b * m[12] + a * m[13] + m[14] * 255;&#13;
          data[i + 3] = r * m[15] + g * m[16] + b * m[17] + a * m[18] + m[19] * 255;&#13;
        }&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Return WebGL uniform locations for this filter's shader.&#13;
     *&#13;
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.&#13;
     * @param {WebGLShaderProgram} program This filter's compiled shader program.&#13;
     */&#13;
    getUniformLocations: function(gl, program) {&#13;
      return {&#13;
        uColorMatrix: gl.getUniformLocation(program, 'uColorMatrix'),&#13;
        uConstants: gl.getUniformLocation(program, 'uConstants'),&#13;
      };&#13;
    },&#13;
&#13;
    /**&#13;
     * Send data from this filter to its shader program's uniforms.&#13;
     *&#13;
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.&#13;
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects&#13;
     */&#13;
    sendUniformData: function(gl, uniformLocations) {&#13;
      var m = this.matrix,&#13;
          matrix = [&#13;
            m[0], m[1], m[2], m[3],&#13;
            m[5], m[6], m[7], m[8],&#13;
            m[10], m[11], m[12], m[13],&#13;
            m[15], m[16], m[17], m[18]&#13;
          ],&#13;
          constants = [m[4], m[9], m[14], m[19]];&#13;
      gl.uniformMatrix4fv(uniformLocations.uColorMatrix, false, matrix);&#13;
      gl.uniform4fv(uniformLocations.uConstants, constants);&#13;
    },&#13;
  });&#13;
&#13;
  /**&#13;
   * Returns filter instance from an object representation&#13;
   * @static&#13;
   * @param {Object} object Object to create an instance from&#13;
   * @param {function} [callback] function to invoke after filter creation&#13;
   * @return {fabric.Image.filters.ColorMatrix} Instance of fabric.Image.filters.ColorMatrix&#13;
   */&#13;
  fabric.Image.filters.ColorMatrix.fromObject = fabric.Image.filters.BaseFilter.fromObject;&#13;
})(typeof exports !== 'undefined' ? exports : this);&#13;
&#13;
&#13;
(function(global) {&#13;
&#13;
  'use strict';&#13;
&#13;
  var fabric  = global.fabric || (global.fabric = { }),&#13;
      filters = fabric.Image.filters,&#13;
      createClass = fabric.util.createClass;&#13;
&#13;
  /**&#13;
   * Brightness filter class&#13;
   * @class fabric.Image.filters.Brightness&#13;
   * @memberOf fabric.Image.filters&#13;
   * @extends fabric.Image.filters.BaseFilter&#13;
   * @see {@link fabric.Image.filters.Brightness#initialize} for constructor definition&#13;
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}&#13;
   * @example&#13;
   * var filter = new fabric.Image.filters.Brightness({&#13;
   *   brightness: 200&#13;
   * });&#13;
   * object.filters.push(filter);&#13;
   * object.applyFilters();&#13;
   */&#13;
  filters.Brightness = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Brightness.prototype */ {&#13;
&#13;
    /**&#13;
     * Filter type&#13;
     * @param {String} type&#13;
     * @default&#13;
     */&#13;
    type: 'Brightness',&#13;
&#13;
    /**&#13;
     * Fragment source for the brightness program&#13;
     */&#13;
    fragmentSource: 'precision highp float;\n' +&#13;
      'uniform sampler2D uTexture;\n' +&#13;
      'uniform float uBrightness;\n' +&#13;
      'varying vec2 vTexCoord;\n' +&#13;
      'void main() {\n' +&#13;
        'vec4 color = texture2D(uTexture, vTexCoord);\n' +&#13;
        'color.rgb += uBrightness;\n' +&#13;
        'gl_FragColor = color;\n' +&#13;
      '}',&#13;
&#13;
    /**&#13;
     * Brightness value, from -1 to 1.&#13;
     * translated to -255 to 255 for 2d&#13;
     * 0.0039215686 is the part of 1 that get translated to 1 in 2d&#13;
     * @param {Number} brightness&#13;
     * @default&#13;
     */&#13;
    brightness: 0,&#13;
&#13;
    /**&#13;
     * Describe the property that is the filter parameter&#13;
     * @param {String} m&#13;
     * @default&#13;
     */&#13;
    mainParameter: 'brightness',&#13;
&#13;
    /**&#13;
    * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.&#13;
    *&#13;
    * @param {Object} options&#13;
    * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.&#13;
    */&#13;
    applyTo2d: function(options) {&#13;
      if (this.brightness === 0) {&#13;
        return;&#13;
      }&#13;
      var imageData = options.imageData,&#13;
          data = imageData.data, i, len = data.length,&#13;
          brightness = Math.round(this.brightness * 255);&#13;
      for (i = 0; i &lt; len; i += 4) {&#13;
        data[i] = data[i] + brightness;&#13;
        data[i + 1] = data[i + 1] + brightness;&#13;
        data[i + 2] = data[i + 2] + brightness;&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Return WebGL uniform locations for this filter's shader.&#13;
     *&#13;
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.&#13;
     * @param {WebGLShaderProgram} program This filter's compiled shader program.&#13;
     */&#13;
    getUniformLocations: function(gl, program) {&#13;
      return {&#13;
        uBrightness: gl.getUniformLocation(program, 'uBrightness'),&#13;
      };&#13;
    },&#13;
&#13;
    /**&#13;
     * Send data from this filter to its shader program's uniforms.&#13;
     *&#13;
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.&#13;
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects&#13;
     */&#13;
    sendUniformData: function(gl, uniformLocations) {&#13;
      gl.uniform1f(uniformLocations.uBrightness, this.brightness);&#13;
    },&#13;
  });&#13;
&#13;
  /**&#13;
   * Returns filter instance from an object representation&#13;
   * @static&#13;
   * @param {Object} object Object to create an instance from&#13;
   * @param {function} [callback] to be invoked after filter creation&#13;
   * @return {fabric.Image.filters.Brightness} Instance of fabric.Image.filters.Brightness&#13;
   */&#13;
  fabric.Image.filters.Brightness.fromObject = fabric.Image.filters.BaseFilter.fromObject;&#13;
&#13;
})(typeof exports !== 'undefined' ? exports : this);&#13;
&#13;
&#13;
(function(global) {&#13;
&#13;
  'use strict';&#13;
&#13;
  var fabric  = global.fabric || (global.fabric = { }),&#13;
      extend = fabric.util.object.extend,&#13;
      filters = fabric.Image.filters,&#13;
      createClass = fabric.util.createClass;&#13;
&#13;
  /**&#13;
   * Adapted from &lt;a href="http://www.html5rocks.com/en/tutorials/canvas/imagefilters/"&gt;html5rocks article&lt;/a&gt;&#13;
   * @class fabric.Image.filters.Convolute&#13;
   * @memberOf fabric.Image.filters&#13;
   * @extends fabric.Image.filters.BaseFilter&#13;
   * @see {@link fabric.Image.filters.Convolute#initialize} for constructor definition&#13;
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}&#13;
   * @example &lt;caption&gt;Sharpen filter&lt;/caption&gt;&#13;
   * var filter = new fabric.Image.filters.Convolute({&#13;
   *   matrix: [ 0, -1,  0,&#13;
   *            -1,  5, -1,&#13;
   *             0, -1,  0 ]&#13;
   * });&#13;
   * object.filters.push(filter);&#13;
   * object.applyFilters();&#13;
   * canvas.renderAll();&#13;
   * @example &lt;caption&gt;Blur filter&lt;/caption&gt;&#13;
   * var filter = new fabric.Image.filters.Convolute({&#13;
   *   matrix: [ 1/9, 1/9, 1/9,&#13;
   *             1/9, 1/9, 1/9,&#13;
   *             1/9, 1/9, 1/9 ]&#13;
   * });&#13;
   * object.filters.push(filter);&#13;
   * object.applyFilters();&#13;
   * canvas.renderAll();&#13;
   * @example &lt;caption&gt;Emboss filter&lt;/caption&gt;&#13;
   * var filter = new fabric.Image.filters.Convolute({&#13;
   *   matrix: [ 1,   1,  1,&#13;
   *             1, 0.7, -1,&#13;
   *            -1,  -1, -1 ]&#13;
   * });&#13;
   * object.filters.push(filter);&#13;
   * object.applyFilters();&#13;
   * canvas.renderAll();&#13;
   * @example &lt;caption&gt;Emboss filter with opaqueness&lt;/caption&gt;&#13;
   * var filter = new fabric.Image.filters.Convolute({&#13;
   *   opaque: true,&#13;
   *   matrix: [ 1,   1,  1,&#13;
   *             1, 0.7, -1,&#13;
   *            -1,  -1, -1 ]&#13;
   * });&#13;
   * object.filters.push(filter);&#13;
   * object.applyFilters();&#13;
   * canvas.renderAll();&#13;
   */&#13;
  filters.Convolute = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Convolute.prototype */ {&#13;
&#13;
    /**&#13;
     * Filter type&#13;
     * @param {String} type&#13;
     * @default&#13;
     */&#13;
    type: 'Convolute',&#13;
&#13;
    /*&#13;
     * Opaque value (true/false)&#13;
     */&#13;
    opaque: false,&#13;
&#13;
    /*&#13;
     * matrix for the filter, max 9x9&#13;
     */&#13;
    matrix: [0, 0, 0, 0, 1, 0, 0, 0, 0],&#13;
&#13;
    /**&#13;
     * Fragment source for the brightness program&#13;
     */&#13;
    fragmentSource: {&#13;
      Convolute_3_1: 'precision highp float;\n' +&#13;
        'uniform sampler2D uTexture;\n' +&#13;
        'uniform float uMatrix[9];\n' +&#13;
        'uniform float uStepW;\n' +&#13;
        'uniform float uStepH;\n' +&#13;
        'varying vec2 vTexCoord;\n' +&#13;
        'void main() {\n' +&#13;
          'vec4 color = vec4(0, 0, 0, 0);\n' +&#13;
          'for (float h = 0.0; h &lt; 3.0; h+=1.0) {\n' +&#13;
            'for (float w = 0.0; w &lt; 3.0; w+=1.0) {\n' +&#13;
              'vec2 matrixPos = vec2(uStepW * (w - 1), uStepH * (h - 1));\n' +&#13;
              'color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 3.0 + w)];\n' +&#13;
            '}\n' +&#13;
          '}\n' +&#13;
          'gl_FragColor = color;\n' +&#13;
        '}',&#13;
      Convolute_3_0: 'precision highp float;\n' +&#13;
        'uniform sampler2D uTexture;\n' +&#13;
        'uniform float uMatrix[9];\n' +&#13;
        'uniform float uStepW;\n' +&#13;
        'uniform float uStepH;\n' +&#13;
        'varying vec2 vTexCoord;\n' +&#13;
        'void main() {\n' +&#13;
          'vec4 color = vec4(0, 0, 0, 1);\n' +&#13;
          'for (float h = 0.0; h &lt; 3.0; h+=1.0) {\n' +&#13;
            'for (float w = 0.0; w &lt; 3.0; w+=1.0) {\n' +&#13;
              'vec2 matrixPos = vec2(uStepW * (w - 1.0), uStepH * (h - 1.0));\n' +&#13;
              'color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 3.0 + w)];\n' +&#13;
            '}\n' +&#13;
          '}\n' +&#13;
          'float alpha = texture2D(uTexture, vTexCoord).a;\n' +&#13;
          'gl_FragColor = color;\n' +&#13;
          'gl_FragColor.a = alpha;\n' +&#13;
        '}',&#13;
      Convolute_5_1: 'precision highp float;\n' +&#13;
        'uniform sampler2D uTexture;\n' +&#13;
        'uniform float uMatrix[25];\n' +&#13;
        'uniform float uStepW;\n' +&#13;
        'uniform float uStepH;\n' +&#13;
        'varying vec2 vTexCoord;\n' +&#13;
        'void main() {\n' +&#13;
          'vec4 color = vec4(0, 0, 0, 0);\n' +&#13;
          'for (float h = 0.0; h &lt; 5.0; h+=1.0) {\n' +&#13;
            'for (float w = 0.0; w &lt; 5.0; w+=1.0) {\n' +&#13;
              'vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\n' +&#13;
              'color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 5.0 + w)];\n' +&#13;
            '}\n' +&#13;
          '}\n' +&#13;
          'gl_FragColor = color;\n' +&#13;
        '}',&#13;
      Convolute_5_0: 'precision highp float;\n' +&#13;
        'uniform sampler2D uTexture;\n' +&#13;
        'uniform float uMatrix[25];\n' +&#13;
        'uniform float uStepW;\n' +&#13;
        'uniform float uStepH;\n' +&#13;
        'varying vec2 vTexCoord;\n' +&#13;
        'void main() {\n' +&#13;
          'vec4 color = vec4(0, 0, 0, 1);\n' +&#13;
          'for (float h = 0.0; h &lt; 5.0; h+=1.0) {\n' +&#13;
            'for (float w = 0.0; w &lt; 5.0; w+=1.0) {\n' +&#13;
              'vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\n' +&#13;
              'color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 5.0 + w)];\n' +&#13;
            '}\n' +&#13;
          '}\n' +&#13;
          'float alpha = texture2D(uTexture, vTexCoord).a;\n' +&#13;
          'gl_FragColor = color;\n' +&#13;
          'gl_FragColor.a = alpha;\n' +&#13;
        '}',&#13;
      Convolute_7_1: 'precision highp float;\n' +&#13;
        'uniform sampler2D uTexture;\n' +&#13;
        'uniform float uMatrix[49];\n' +&#13;
        'uniform float uStepW;\n' +&#13;
        'uniform float uStepH;\n' +&#13;
        'varying vec2 vTexCoord;\n' +&#13;
        'void main() {\n' +&#13;
          'vec4 color = vec4(0, 0, 0, 0);\n' +&#13;
          'for (float h = 0.0; h &lt; 7.0; h+=1.0) {\n' +&#13;
            'for (float w = 0.0; w &lt; 7.0; w+=1.0) {\n' +&#13;
              'vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\n' +&#13;
              'color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 7.0 + w)];\n' +&#13;
            '}\n' +&#13;
          '}\n' +&#13;
          'gl_FragColor = color;\n' +&#13;
        '}',&#13;
      Convolute_7_0: 'precision highp float;\n' +&#13;
        'uniform sampler2D uTexture;\n' +&#13;
        'uniform float uMatrix[49];\n' +&#13;
        'uniform float uStepW;\n' +&#13;
        'uniform float uStepH;\n' +&#13;
        'varying vec2 vTexCoord;\n' +&#13;
        'void main() {\n' +&#13;
          'vec4 color = vec4(0, 0, 0, 1);\n' +&#13;
          'for (float h = 0.0; h &lt; 7.0; h+=1.0) {\n' +&#13;
            'for (float w = 0.0; w &lt; 7.0; w+=1.0) {\n' +&#13;
              'vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\n' +&#13;
              'color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 7.0 + w)];\n' +&#13;
            '}\n' +&#13;
          '}\n' +&#13;
          'float alpha = texture2D(uTexture, vTexCoord).a;\n' +&#13;
          'gl_FragColor = color;\n' +&#13;
          'gl_FragColor.a = alpha;\n' +&#13;
        '}',&#13;
      Convolute_9_1: 'precision highp float;\n' +&#13;
        'uniform sampler2D uTexture;\n' +&#13;
        'uniform float uMatrix[81];\n' +&#13;
        'uniform float uStepW;\n' +&#13;
        'uniform float uStepH;\n' +&#13;
        'varying vec2 vTexCoord;\n' +&#13;
        'void main() {\n' +&#13;
          'vec4 color = vec4(0, 0, 0, 0);\n' +&#13;
          'for (float h = 0.0; h &lt; 9.0; h+=1.0) {\n' +&#13;
            'for (float w = 0.0; w &lt; 9.0; w+=1.0) {\n' +&#13;
              'vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\n' +&#13;
              'color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 9.0 + w)];\n' +&#13;
            '}\n' +&#13;
          '}\n' +&#13;
          'gl_FragColor = color;\n' +&#13;
        '}',&#13;
      Convolute_9_0: 'precision highp float;\n' +&#13;
        'uniform sampler2D uTexture;\n' +&#13;
        'uniform float uMatrix[81];\n' +&#13;
        'uniform float uStepW;\n' +&#13;
        'uniform float uStepH;\n' +&#13;
        'varying vec2 vTexCoord;\n' +&#13;
        'void main() {\n' +&#13;
          'vec4 color = vec4(0, 0, 0, 1);\n' +&#13;
          'for (float h = 0.0; h &lt; 9.0; h+=1.0) {\n' +&#13;
            'for (float w = 0.0; w &lt; 9.0; w+=1.0) {\n' +&#13;
              'vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\n' +&#13;
              'color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 9.0 + w)];\n' +&#13;
            '}\n' +&#13;
          '}\n' +&#13;
          'float alpha = texture2D(uTexture, vTexCoord).a;\n' +&#13;
          'gl_FragColor = color;\n' +&#13;
          'gl_FragColor.a = alpha;\n' +&#13;
        '}',&#13;
    },&#13;
&#13;
    /**&#13;
     * Constructor&#13;
     * @memberOf fabric.Image.filters.Convolute.prototype&#13;
     * @param {Object} [options] Options object&#13;
     * @param {Boolean} [options.opaque=false] Opaque value (true/false)&#13;
     * @param {Array} [options.matrix] Filter matrix&#13;
     */&#13;
&#13;
&#13;
    /**&#13;
    * Retrieves the cached shader.&#13;
    * @param {Object} options&#13;
    * @param {WebGLRenderingContext} options.context The GL context used for rendering.&#13;
    * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.&#13;
    */&#13;
    retrieveShader: function(options) {&#13;
      var size = Math.sqrt(this.matrix.length);&#13;
      var cacheKey = this.type + '_' + size + '_' + (this.opaque ? 1 : 0);&#13;
      var shaderSource = this.fragmentSource[cacheKey];&#13;
      if (!options.programCache.hasOwnProperty(cacheKey)) {&#13;
        options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);&#13;
      }&#13;
      return options.programCache[cacheKey];&#13;
    },&#13;
&#13;
    /**&#13;
     * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.&#13;
     *&#13;
     * @param {Object} options&#13;
     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.&#13;
     */&#13;
    applyTo2d: function(options) {&#13;
      var imageData = options.imageData,&#13;
          data = imageData.data,&#13;
          weights = this.matrix,&#13;
          side = Math.round(Math.sqrt(weights.length)),&#13;
          halfSide = Math.floor(side / 2),&#13;
          sw = imageData.width,&#13;
          sh = imageData.height,&#13;
          output = options.ctx.createImageData(sw, sh),&#13;
          dst = output.data,&#13;
          // go through the destination image pixels&#13;
          alphaFac = this.opaque ? 1 : 0,&#13;
          r, g, b, a, dstOff,&#13;
          scx, scy, srcOff, wt,&#13;
          x, y, cx, cy;&#13;
&#13;
      for (y = 0; y &lt; sh; y++) {&#13;
        for (x = 0; x &lt; sw; x++) {&#13;
          dstOff = (y * sw + x) * 4;&#13;
          // calculate the weighed sum of the source image pixels that&#13;
          // fall under the convolution matrix&#13;
          r = 0; g = 0; b = 0; a = 0;&#13;
&#13;
          for (cy = 0; cy &lt; side; cy++) {&#13;
            for (cx = 0; cx &lt; side; cx++) {&#13;
              scy = y + cy - halfSide;&#13;
              scx = x + cx - halfSide;&#13;
&#13;
              // eslint-disable-next-line max-depth&#13;
              if (scy &lt; 0 || scy &gt; sh || scx &lt; 0 || scx &gt; sw) {&#13;
                continue;&#13;
              }&#13;
&#13;
              srcOff = (scy * sw + scx) * 4;&#13;
              wt = weights[cy * side + cx];&#13;
&#13;
              r += data[srcOff] * wt;&#13;
              g += data[srcOff + 1] * wt;&#13;
              b += data[srcOff + 2] * wt;&#13;
              // eslint-disable-next-line max-depth&#13;
              if (!alphaFac) {&#13;
                a += data[srcOff + 3] * wt;&#13;
              }&#13;
            }&#13;
          }&#13;
          dst[dstOff] = r;&#13;
          dst[dstOff + 1] = g;&#13;
          dst[dstOff + 2] = b;&#13;
          if (!alphaFac) {&#13;
            dst[dstOff + 3] = a;&#13;
          }&#13;
          else {&#13;
            dst[dstOff + 3] = data[dstOff + 3];&#13;
          }&#13;
        }&#13;
      }&#13;
      options.imageData = output;&#13;
    },&#13;
&#13;
    /**&#13;
     * Return WebGL uniform locations for this filter's shader.&#13;
     *&#13;
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.&#13;
     * @param {WebGLShaderProgram} program This filter's compiled shader program.&#13;
     */&#13;
    getUniformLocations: function(gl, program) {&#13;
      return {&#13;
        uMatrix: gl.getUniformLocation(program, 'uMatrix'),&#13;
        uOpaque: gl.getUniformLocation(program, 'uOpaque'),&#13;
        uHalfSize: gl.getUniformLocation(program, 'uHalfSize'),&#13;
        uSize: gl.getUniformLocation(program, 'uSize'),&#13;
      };&#13;
    },&#13;
&#13;
    /**&#13;
     * Send data from this filter to its shader program's uniforms.&#13;
     *&#13;
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.&#13;
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects&#13;
     */&#13;
    sendUniformData: function(gl, uniformLocations) {&#13;
      gl.uniform1fv(uniformLocations.uMatrix, this.matrix);&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns object representation of an instance&#13;
     * @return {Object} Object representation of an instance&#13;
     */&#13;
    toObject: function() {&#13;
      return extend(this.callSuper('toObject'), {&#13;
        opaque: this.opaque,&#13;
        matrix: this.matrix&#13;
      });&#13;
    }&#13;
  });&#13;
&#13;
  /**&#13;
   * Returns filter instance from an object representation&#13;
   * @static&#13;
   * @param {Object} object Object to create an instance from&#13;
   * @param {function} [callback] to be invoked after filter creation&#13;
   * @return {fabric.Image.filters.Convolute} Instance of fabric.Image.filters.Convolute&#13;
   */&#13;
  fabric.Image.filters.Convolute.fromObject = fabric.Image.filters.BaseFilter.fromObject;&#13;
&#13;
})(typeof exports !== 'undefined' ? exports : this);&#13;
&#13;
&#13;
(function(global) {&#13;
&#13;
  'use strict';&#13;
&#13;
  var fabric  = global.fabric || (global.fabric = { }),&#13;
      filters = fabric.Image.filters,&#13;
      createClass = fabric.util.createClass;&#13;
&#13;
  /**&#13;
   * Grayscale image filter class&#13;
   * @class fabric.Image.filters.Grayscale&#13;
   * @memberOf fabric.Image.filters&#13;
   * @extends fabric.Image.filters.BaseFilter&#13;
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}&#13;
   * @example&#13;
   * var filter = new fabric.Image.filters.Grayscale();&#13;
   * object.filters.push(filter);&#13;
   * object.applyFilters();&#13;
   */&#13;
  filters.Grayscale = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Grayscale.prototype */ {&#13;
&#13;
    /**&#13;
     * Filter type&#13;
     * @param {String} type&#13;
     * @default&#13;
     */&#13;
    type: 'Grayscale',&#13;
&#13;
    fragmentSource: {&#13;
      average: 'precision highp float;\n' +&#13;
        'uniform sampler2D uTexture;\n' +&#13;
        'varying vec2 vTexCoord;\n' +&#13;
        'void main() {\n' +&#13;
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +&#13;
          'float average = (color.r + color.b + color.g) / 3.0;\n' +&#13;
          'gl_FragColor = vec4(average, average, average, color.a);\n' +&#13;
        '}',&#13;
      lightness: 'precision highp float;\n' +&#13;
        'uniform sampler2D uTexture;\n' +&#13;
        'uniform int uMode;\n' +&#13;
        'varying vec2 vTexCoord;\n' +&#13;
        'void main() {\n' +&#13;
          'vec4 col = texture2D(uTexture, vTexCoord);\n' +&#13;
          'float average = (max(max(col.r, col.g),col.b) + min(min(col.r, col.g),col.b)) / 2.0;\n' +&#13;
          'gl_FragColor = vec4(average, average, average, col.a);\n' +&#13;
        '}',&#13;
      luminosity: 'precision highp float;\n' +&#13;
        'uniform sampler2D uTexture;\n' +&#13;
        'uniform int uMode;\n' +&#13;
        'varying vec2 vTexCoord;\n' +&#13;
        'void main() {\n' +&#13;
          'vec4 col = texture2D(uTexture, vTexCoord);\n' +&#13;
          'float average = 0.21 * col.r + 0.72 * col.g + 0.07 * col.b;\n' +&#13;
          'gl_FragColor = vec4(average, average, average, col.a);\n' +&#13;
        '}',&#13;
    },&#13;
&#13;
&#13;
    /**&#13;
     * Grayscale mode, between 'average', 'lightness', 'luminosity'&#13;
     * @param {String} type&#13;
     * @default&#13;
     */&#13;
    mode: 'average',&#13;
&#13;
    mainParameter: 'mode',&#13;
&#13;
    /**&#13;
     * Apply the Grayscale operation to a Uint8Array representing the pixels of an image.&#13;
     *&#13;
     * @param {Object} options&#13;
     * @param {ImageData} options.imageData The Uint8Array to be filtered.&#13;
     */&#13;
    applyTo2d: function(options) {&#13;
      var imageData = options.imageData,&#13;
          data = imageData.data, i,&#13;
          len = data.length, value,&#13;
          mode = this.mode;&#13;
      for (i = 0; i &lt; len; i += 4) {&#13;
        if (mode === 'average') {&#13;
          value = (data[i] + data[i + 1] + data[i + 2]) / 3;&#13;
        }&#13;
        else if (mode === 'lightness') {&#13;
          value = (Math.min(data[i], data[i + 1], data[i + 2]) +&#13;
            Math.max(data[i], data[i + 1], data[i + 2])) / 2;&#13;
        }&#13;
        else if (mode === 'luminosity') {&#13;
          value = 0.21 * data[i] + 0.72 * data[i + 1] + 0.07 * data[i + 2];&#13;
        }&#13;
        data[i] = value;&#13;
        data[i + 1] = value;&#13;
        data[i + 2] = value;&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Retrieves the cached shader.&#13;
     * @param {Object} options&#13;
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.&#13;
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.&#13;
     */&#13;
    retrieveShader: function(options) {&#13;
      var cacheKey = this.type + '_' + this.mode;&#13;
      if (!options.programCache.hasOwnProperty(cacheKey)) {&#13;
        var shaderSource = this.fragmentSource[this.mode];&#13;
        options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);&#13;
      }&#13;
      return options.programCache[cacheKey];&#13;
    },&#13;
&#13;
    /**&#13;
     * Return WebGL uniform locations for this filter's shader.&#13;
     *&#13;
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.&#13;
     * @param {WebGLShaderProgram} program This filter's compiled shader program.&#13;
     */&#13;
    getUniformLocations: function(gl, program) {&#13;
      return {&#13;
        uMode: gl.getUniformLocation(program, 'uMode'),&#13;
      };&#13;
    },&#13;
&#13;
    /**&#13;
     * Send data from this filter to its shader program's uniforms.&#13;
     *&#13;
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.&#13;
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects&#13;
     */&#13;
    sendUniformData: function(gl, uniformLocations) {&#13;
      // default average mode.&#13;
      var mode = 1;&#13;
      gl.uniform1i(uniformLocations.uMode, mode);&#13;
    },&#13;
  });&#13;
&#13;
  /**&#13;
   * Returns filter instance from an object representation&#13;
   * @static&#13;
   * @param {Object} object Object to create an instance from&#13;
   * @param {function} [callback] to be invoked after filter creation&#13;
   * @return {fabric.Image.filters.Grayscale} Instance of fabric.Image.filters.Grayscale&#13;
   */&#13;
  fabric.Image.filters.Grayscale.fromObject = fabric.Image.filters.BaseFilter.fromObject;&#13;
&#13;
})(typeof exports !== 'undefined' ? exports : this);&#13;
&#13;
&#13;
(function(global) {&#13;
&#13;
  'use strict';&#13;
&#13;
  var fabric  = global.fabric || (global.fabric = { }),&#13;
      filters = fabric.Image.filters,&#13;
      createClass = fabric.util.createClass;&#13;
&#13;
  /**&#13;
   * Invert filter class&#13;
   * @class fabric.Image.filters.Invert&#13;
   * @memberOf fabric.Image.filters&#13;
   * @extends fabric.Image.filters.BaseFilter&#13;
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}&#13;
   * @example&#13;
   * var filter = new fabric.Image.filters.Invert();&#13;
   * object.filters.push(filter);&#13;
   * object.applyFilters(canvas.renderAll.bind(canvas));&#13;
   */&#13;
  filters.Invert = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Invert.prototype */ {&#13;
&#13;
    /**&#13;
     * Filter type&#13;
     * @param {String} type&#13;
     * @default&#13;
     */&#13;
    type: 'Invert',&#13;
&#13;
    fragmentSource: 'precision highp float;\n' +&#13;
      'uniform sampler2D uTexture;\n' +&#13;
      'uniform int uInvert;\n' +&#13;
      'varying vec2 vTexCoord;\n' +&#13;
      'void main() {\n' +&#13;
        'vec4 color = texture2D(uTexture, vTexCoord);\n' +&#13;
        'if (uInvert == 1) {\n' +&#13;
          'gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,color.a);\n' +&#13;
        '} else {\n' +&#13;
          'gl_FragColor = color;\n' +&#13;
        '}\n' +&#13;
      '}',&#13;
&#13;
    /**&#13;
     * Filter invert. if false, does nothing&#13;
     * @param {Boolean} invert&#13;
     * @default&#13;
     */&#13;
    invert: true,&#13;
&#13;
    mainParameter: 'invert',&#13;
&#13;
    /**&#13;
     * Apply the Invert operation to a Uint8Array representing the pixels of an image.&#13;
     *&#13;
     * @param {Object} options&#13;
     * @param {ImageData} options.imageData The Uint8Array to be filtered.&#13;
     */&#13;
    applyTo2d: function(options) {&#13;
      if (!this.invert) {&#13;
        return;&#13;
      }&#13;
      var imageData = options.imageData,&#13;
          data = imageData.data, i,&#13;
          len = data.length;&#13;
      for (i = 0; i &lt; len; i += 4) {&#13;
        data[i] = 255 - data[i];&#13;
        data[i + 1] = 255 - data[i + 1];&#13;
        data[i + 2] = 255 - data[i + 2];&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Return WebGL uniform locations for this filter's shader.&#13;
     *&#13;
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.&#13;
     * @param {WebGLShaderProgram} program This filter's compiled shader program.&#13;
     */&#13;
    getUniformLocations: function(gl, program) {&#13;
      return {&#13;
        uInvert: gl.getUniformLocation(program, 'uInvert'),&#13;
      };&#13;
    },&#13;
&#13;
    /**&#13;
     * Send data from this filter to its shader program's uniforms.&#13;
     *&#13;
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.&#13;
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects&#13;
     */&#13;
    sendUniformData: function(gl, uniformLocations) {&#13;
      gl.uniform1i(uniformLocations.uInvert, this.invert);&#13;
    },&#13;
  });&#13;
&#13;
  /**&#13;
   * Returns filter instance from an object representation&#13;
   * @static&#13;
   * @param {Object} object Object to create an instance from&#13;
   * @param {function} [callback] to be invoked after filter creation&#13;
   * @return {fabric.Image.filters.Invert} Instance of fabric.Image.filters.Invert&#13;
   */&#13;
  fabric.Image.filters.Invert.fromObject = fabric.Image.filters.BaseFilter.fromObject;&#13;
&#13;
&#13;
})(typeof exports !== 'undefined' ? exports : this);&#13;
&#13;
&#13;
(function(global) {&#13;
&#13;
  'use strict';&#13;
&#13;
  var fabric  = global.fabric || (global.fabric = { }),&#13;
      extend = fabric.util.object.extend,&#13;
      filters = fabric.Image.filters,&#13;
      createClass = fabric.util.createClass;&#13;
&#13;
  /**&#13;
   * Noise filter class&#13;
   * @class fabric.Image.filters.Noise&#13;
   * @memberOf fabric.Image.filters&#13;
   * @extends fabric.Image.filters.BaseFilter&#13;
   * @see {@link fabric.Image.filters.Noise#initialize} for constructor definition&#13;
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}&#13;
   * @example&#13;
   * var filter = new fabric.Image.filters.Noise({&#13;
   *   noise: 700&#13;
   * });&#13;
   * object.filters.push(filter);&#13;
   * object.applyFilters();&#13;
   * canvas.renderAll();&#13;
   */&#13;
  filters.Noise = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Noise.prototype */ {&#13;
&#13;
    /**&#13;
     * Filter type&#13;
     * @param {String} type&#13;
     * @default&#13;
     */&#13;
    type: 'Noise',&#13;
&#13;
    /**&#13;
     * Fragment source for the noise program&#13;
     */&#13;
    fragmentSource: 'precision highp float;\n' +&#13;
      'uniform sampler2D uTexture;\n' +&#13;
      'uniform float uStepH;\n' +&#13;
      'uniform float uNoise;\n' +&#13;
      'uniform float uSeed;\n' +&#13;
      'varying vec2 vTexCoord;\n' +&#13;
      'float rand(vec2 co, float seed, float vScale) {\n' +&#13;
        'return fract(sin(dot(co.xy * vScale ,vec2(12.9898 , 78.233))) * 43758.5453 * (seed + 0.01) / 2.0);\n' +&#13;
      '}\n' +&#13;
      'void main() {\n' +&#13;
        'vec4 color = texture2D(uTexture, vTexCoord);\n' +&#13;
        'color.rgb += (0.5 - rand(vTexCoord, uSeed, 0.1 / uStepH)) * uNoise;\n' +&#13;
        'gl_FragColor = color;\n' +&#13;
      '}',&#13;
&#13;
    /**&#13;
     * Describe the property that is the filter parameter&#13;
     * @param {String} m&#13;
     * @default&#13;
     */&#13;
    mainParameter: 'noise',&#13;
&#13;
    /**&#13;
     * Noise value, from&#13;
     * @param {Number} noise&#13;
     * @default&#13;
     */&#13;
    noise: 0,&#13;
&#13;
    /**&#13;
     * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.&#13;
     *&#13;
     * @param {Object} options&#13;
     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.&#13;
     */&#13;
    applyTo2d: function(options) {&#13;
      if (this.noise === 0) {&#13;
        return;&#13;
      }&#13;
      var imageData = options.imageData,&#13;
          data = imageData.data, i, len = data.length,&#13;
          noise = this.noise, rand;&#13;
&#13;
      for (i = 0, len = data.length; i &lt; len; i += 4) {&#13;
&#13;
        rand = (0.5 - Math.random()) * noise;&#13;
&#13;
        data[i] += rand;&#13;
        data[i + 1] += rand;&#13;
        data[i + 2] += rand;&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Return WebGL uniform locations for this filter's shader.&#13;
     *&#13;
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.&#13;
     * @param {WebGLShaderProgram} program This filter's compiled shader program.&#13;
     */&#13;
    getUniformLocations: function(gl, program) {&#13;
      return {&#13;
        uNoise: gl.getUniformLocation(program, 'uNoise'),&#13;
        uSeed: gl.getUniformLocation(program, 'uSeed'),&#13;
      };&#13;
    },&#13;
&#13;
    /**&#13;
     * Send data from this filter to its shader program's uniforms.&#13;
     *&#13;
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.&#13;
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects&#13;
     */&#13;
    sendUniformData: function(gl, uniformLocations) {&#13;
      gl.uniform1f(uniformLocations.uNoise, this.noise / 255);&#13;
      gl.uniform1f(uniformLocations.uSeed, Math.random());&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns object representation of an instance&#13;
     * @return {Object} Object representation of an instance&#13;
     */&#13;
    toObject: function() {&#13;
      return extend(this.callSuper('toObject'), {&#13;
        noise: this.noise&#13;
      });&#13;
    }&#13;
  });&#13;
&#13;
  /**&#13;
   * Returns filter instance from an object representation&#13;
   * @static&#13;
   * @param {Object} object Object to create an instance from&#13;
   * @param {Function} [callback] to be invoked after filter creation&#13;
   * @return {fabric.Image.filters.Noise} Instance of fabric.Image.filters.Noise&#13;
   */&#13;
  fabric.Image.filters.Noise.fromObject = fabric.Image.filters.BaseFilter.fromObject;&#13;
&#13;
})(typeof exports !== 'undefined' ? exports : this);&#13;
&#13;
&#13;
(function(global) {&#13;
&#13;
  'use strict';&#13;
&#13;
  var fabric  = global.fabric || (global.fabric = { }),&#13;
      filters = fabric.Image.filters,&#13;
      createClass = fabric.util.createClass;&#13;
&#13;
  /**&#13;
   * Pixelate filter class&#13;
   * @class fabric.Image.filters.Pixelate&#13;
   * @memberOf fabric.Image.filters&#13;
   * @extends fabric.Image.filters.BaseFilter&#13;
   * @see {@link fabric.Image.filters.Pixelate#initialize} for constructor definition&#13;
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}&#13;
   * @example&#13;
   * var filter = new fabric.Image.filters.Pixelate({&#13;
   *   blocksize: 8&#13;
   * });&#13;
   * object.filters.push(filter);&#13;
   * object.applyFilters();&#13;
   */&#13;
  filters.Pixelate = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Pixelate.prototype */ {&#13;
&#13;
    /**&#13;
     * Filter type&#13;
     * @param {String} type&#13;
     * @default&#13;
     */&#13;
    type: 'Pixelate',&#13;
&#13;
    blocksize: 4,&#13;
&#13;
    mainParameter: 'blocksize',&#13;
&#13;
    /**&#13;
     * Fragment source for the Pixelate program&#13;
     */&#13;
    fragmentSource: 'precision highp float;\n' +&#13;
      'uniform sampler2D uTexture;\n' +&#13;
      'uniform float uBlocksize;\n' +&#13;
      'uniform float uStepW;\n' +&#13;
      'uniform float uStepH;\n' +&#13;
      'varying vec2 vTexCoord;\n' +&#13;
      'void main() {\n' +&#13;
        'float blockW = uBlocksize * uStepW;\n' +&#13;
        'float blockH = uBlocksize * uStepW;\n' +&#13;
        'int posX = int(vTexCoord.x / blockW);\n' +&#13;
        'int posY = int(vTexCoord.y / blockH);\n' +&#13;
        'float fposX = float(posX);\n' +&#13;
        'float fposY = float(posY);\n' +&#13;
        'vec2 squareCoords = vec2(fposX * blockW, fposY * blockH);\n' +&#13;
        'vec4 color = texture2D(uTexture, squareCoords);\n' +&#13;
        'gl_FragColor = color;\n' +&#13;
      '}',&#13;
&#13;
    /**&#13;
     * Apply the Pixelate operation to a Uint8ClampedArray representing the pixels of an image.&#13;
     *&#13;
     * @param {Object} options&#13;
     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.&#13;
     */&#13;
    applyTo2d: function(options) {&#13;
      if (this.blocksize === 1) {&#13;
        return;&#13;
      }&#13;
      var imageData = options.imageData,&#13;
          data = imageData.data,&#13;
          iLen = imageData.height,&#13;
          jLen = imageData.width,&#13;
          index, i, j, r, g, b, a,&#13;
          _i, _j, _iLen, _jLen;&#13;
&#13;
      for (i = 0; i &lt; iLen; i += this.blocksize) {&#13;
        for (j = 0; j &lt; jLen; j += this.blocksize) {&#13;
&#13;
          index = (i * 4) * jLen + (j * 4);&#13;
&#13;
          r = data[index];&#13;
          g = data[index + 1];&#13;
          b = data[index + 2];&#13;
          a = data[index + 3];&#13;
&#13;
          _iLen = Math.min(i + this.blocksize, iLen);&#13;
          _jLen = Math.min(j + this.blocksize, jLen);&#13;
          for (_i = i; _i &lt; _iLen; _i++) {&#13;
            for (_j = j; _j &lt; _jLen; _j++) {&#13;
              index = (_i * 4) * jLen + (_j * 4);&#13;
              data[index] = r;&#13;
              data[index + 1] = g;&#13;
              data[index + 2] = b;&#13;
              data[index + 3] = a;&#13;
            }&#13;
          }&#13;
        }&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Indicate when the filter is not gonna apply changes to the image&#13;
     **/&#13;
    isNeutralState: function() {&#13;
      return this.blocksize === 1;&#13;
    },&#13;
&#13;
    /**&#13;
     * Return WebGL uniform locations for this filter's shader.&#13;
     *&#13;
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.&#13;
     * @param {WebGLShaderProgram} program This filter's compiled shader program.&#13;
     */&#13;
    getUniformLocations: function(gl, program) {&#13;
      return {&#13;
        uBlocksize: gl.getUniformLocation(program, 'uBlocksize'),&#13;
        uStepW: gl.getUniformLocation(program, 'uStepW'),&#13;
        uStepH: gl.getUniformLocation(program, 'uStepH'),&#13;
      };&#13;
    },&#13;
&#13;
    /**&#13;
     * Send data from this filter to its shader program's uniforms.&#13;
     *&#13;
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.&#13;
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects&#13;
     */&#13;
    sendUniformData: function(gl, uniformLocations) {&#13;
      gl.uniform1f(uniformLocations.uBlocksize, this.blocksize);&#13;
    },&#13;
  });&#13;
&#13;
  /**&#13;
   * Returns filter instance from an object representation&#13;
   * @static&#13;
   * @param {Object} object Object to create an instance from&#13;
   * @param {Function} [callback] to be invoked after filter creation&#13;
   * @return {fabric.Image.filters.Pixelate} Instance of fabric.Image.filters.Pixelate&#13;
   */&#13;
  fabric.Image.filters.Pixelate.fromObject = fabric.Image.filters.BaseFilter.fromObject;&#13;
&#13;
})(typeof exports !== 'undefined' ? exports : this);&#13;
&#13;
&#13;
(function(global) {&#13;
&#13;
  'use strict';&#13;
&#13;
  var fabric  = global.fabric || (global.fabric = { }),&#13;
      extend = fabric.util.object.extend,&#13;
      filters = fabric.Image.filters,&#13;
      createClass = fabric.util.createClass;&#13;
&#13;
  /**&#13;
   * Remove white filter class&#13;
   * @class fabric.Image.filters.RemoveColor&#13;
   * @memberOf fabric.Image.filters&#13;
   * @extends fabric.Image.filters.BaseFilter&#13;
   * @see {@link fabric.Image.filters.RemoveColor#initialize} for constructor definition&#13;
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}&#13;
   * @example&#13;
   * var filter = new fabric.Image.filters.RemoveColor({&#13;
   *   threshold: 0.2,&#13;
   * });&#13;
   * object.filters.push(filter);&#13;
   * object.applyFilters();&#13;
   * canvas.renderAll();&#13;
   */&#13;
  filters.RemoveColor = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.RemoveColor.prototype */ {&#13;
&#13;
    /**&#13;
     * Filter type&#13;
     * @param {String} type&#13;
     * @default&#13;
     */&#13;
    type: 'RemoveColor',&#13;
&#13;
    /**&#13;
     * Color to remove, in any format understood by fabric.Color.&#13;
     * @param {String} type&#13;
     * @default&#13;
     */&#13;
    color: '#FFFFFF',&#13;
&#13;
    /**&#13;
     * Fragment source for the brightness program&#13;
     */&#13;
    fragmentSource: 'precision highp float;\n' +&#13;
      'uniform sampler2D uTexture;\n' +&#13;
      'uniform vec4 uLow;\n' +&#13;
      'uniform vec4 uHigh;\n' +&#13;
      'varying vec2 vTexCoord;\n' +&#13;
      'void main() {\n' +&#13;
        'gl_FragColor = texture2D(uTexture, vTexCoord);\n' +&#13;
        'if(all(greaterThan(gl_FragColor.rgb,uLow.rgb)) &amp;&amp; all(greaterThan(uHigh.rgb,gl_FragColor.rgb))) {\n' +&#13;
          'gl_FragColor.a = 0.0;\n' +&#13;
        '}\n' +&#13;
      '}',&#13;
&#13;
    /**&#13;
     * distance to actual color, as value up or down from each r,g,b&#13;
     * between 0 and 1&#13;
     **/&#13;
    distance: 0.02,&#13;
&#13;
    /**&#13;
     * For color to remove inside distance, use alpha channel for a smoother deletion&#13;
     * NOT IMPLEMENTED YET&#13;
     **/&#13;
    useAlpha: false,&#13;
&#13;
    /**&#13;
     * Constructor&#13;
     * @memberOf fabric.Image.filters.RemoveWhite.prototype&#13;
     * @param {Object} [options] Options object&#13;
     * @param {Number} [options.color=#RRGGBB] Threshold value&#13;
     * @param {Number} [options.distance=10] Distance value&#13;
     */&#13;
&#13;
    /**&#13;
     * Applies filter to canvas element&#13;
     * @param {Object} canvasEl Canvas element to apply filter to&#13;
     */&#13;
    applyTo2d: function(options) {&#13;
      var imageData = options.imageData,&#13;
          data = imageData.data, i,&#13;
          distance = this.distance * 255,&#13;
          r, g, b,&#13;
          source = new fabric.Color(this.color).getSource(),&#13;
          lowC = [&#13;
            source[0] - distance,&#13;
            source[1] - distance,&#13;
            source[2] - distance,&#13;
          ],&#13;
          highC = [&#13;
            source[0] + distance,&#13;
            source[1] + distance,&#13;
            source[2] + distance,&#13;
          ];&#13;
&#13;
&#13;
      for (i = 0; i &lt; data.length; i += 4) {&#13;
        r = data[i];&#13;
        g = data[i + 1];&#13;
        b = data[i + 2];&#13;
&#13;
        if (r &gt; lowC[0] &amp;&amp;&#13;
            g &gt; lowC[1] &amp;&amp;&#13;
            b &gt; lowC[2] &amp;&amp;&#13;
            r &lt; highC[0] &amp;&amp;&#13;
            g &lt; highC[1] &amp;&amp;&#13;
            b &lt; highC[2]) {&#13;
          data[i + 3] = 0;&#13;
        }&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Return WebGL uniform locations for this filter's shader.&#13;
     *&#13;
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.&#13;
     * @param {WebGLShaderProgram} program This filter's compiled shader program.&#13;
     */&#13;
    getUniformLocations: function(gl, program) {&#13;
      return {&#13;
        uLow: gl.getUniformLocation(program, 'uLow'),&#13;
        uHigh: gl.getUniformLocation(program, 'uHigh'),&#13;
      };&#13;
    },&#13;
&#13;
    /**&#13;
     * Send data from this filter to its shader program's uniforms.&#13;
     *&#13;
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.&#13;
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects&#13;
     */&#13;
    sendUniformData: function(gl, uniformLocations) {&#13;
      var source = new fabric.Color(this.color).getSource(),&#13;
          distance = parseFloat(this.distance),&#13;
          lowC = [&#13;
            0 + source[0] / 255 - distance,&#13;
            0 + source[1] / 255 - distance,&#13;
            0 + source[2] / 255 - distance,&#13;
            1&#13;
          ],&#13;
          highC = [&#13;
            source[0] / 255 + distance,&#13;
            source[1] / 255 + distance,&#13;
            source[2] / 255 + distance,&#13;
            1&#13;
          ];&#13;
      gl.uniform4fv(uniformLocations.uLow, lowC);&#13;
      gl.uniform4fv(uniformLocations.uHigh, highC);&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns object representation of an instance&#13;
     * @return {Object} Object representation of an instance&#13;
     */&#13;
    toObject: function() {&#13;
      return extend(this.callSuper('toObject'), {&#13;
        color: this.color,&#13;
        distance: this.distance&#13;
      });&#13;
    }&#13;
  });&#13;
&#13;
  /**&#13;
   * Returns filter instance from an object representation&#13;
   * @static&#13;
   * @param {Object} object Object to create an instance from&#13;
   * @param {Function} [callback] to be invoked after filter creation&#13;
   * @return {fabric.Image.filters.RemoveColor} Instance of fabric.Image.filters.RemoveWhite&#13;
   */&#13;
  fabric.Image.filters.RemoveColor.fromObject = fabric.Image.filters.BaseFilter.fromObject;&#13;
&#13;
})(typeof exports !== 'undefined' ? exports : this);&#13;
&#13;
&#13;
(function(global) {&#13;
&#13;
  'use strict';&#13;
&#13;
  var fabric  = global.fabric || (global.fabric = { }),&#13;
      filters = fabric.Image.filters,&#13;
      createClass = fabric.util.createClass;&#13;
&#13;
  var matrices = {&#13;
    Brownie: [&#13;
      0.59970,0.34553,-0.27082,0,0.186,&#13;
      -0.03770,0.86095,0.15059,0,-0.1449,&#13;
      0.24113,-0.07441,0.44972,0,-0.02965,&#13;
      0,0,0,1,0&#13;
    ],&#13;
    Vintage: [&#13;
      0.62793,0.32021,-0.03965,0,0.03784,&#13;
      0.02578,0.64411,0.03259,0,0.02926,&#13;
      0.04660,-0.08512,0.52416,0,0.02023,&#13;
      0,0,0,1,0&#13;
    ],&#13;
    Kodachrome: [&#13;
      1.12855,-0.39673,-0.03992,0,0.24991,&#13;
      -0.16404,1.08352,-0.05498,0,0.09698,&#13;
      -0.16786,-0.56034,1.60148,0,0.13972,&#13;
      0,0,0,1,0&#13;
    ],&#13;
    Technicolor: [&#13;
      1.91252,-0.85453,-0.09155,0,0.04624,&#13;
      -0.30878,1.76589,-0.10601,0,-0.27589,&#13;
      -0.23110,-0.75018,1.84759,0,0.12137,&#13;
      0,0,0,1,0&#13;
    ],&#13;
    Polaroid: [&#13;
      1.438,-0.062,-0.062,0,0,&#13;
      -0.122,1.378,-0.122,0,0,&#13;
      -0.016,-0.016,1.483,0,0,&#13;
      0,0,0,1,0&#13;
    ],&#13;
    Sepia: [&#13;
      0.393, 0.769, 0.189, 0, 0,&#13;
      0.349, 0.686, 0.168, 0, 0,&#13;
      0.272, 0.534, 0.131, 0, 0,&#13;
      0, 0, 0, 1, 0&#13;
    ],&#13;
    BlackWhite: [&#13;
      1.5, 1.5, 1.5, 0, -1,&#13;
      1.5, 1.5, 1.5, 0, -1,&#13;
      1.5, 1.5, 1.5, 0, -1,&#13;
      0, 0, 0, 1, 0,&#13;
    ]&#13;
  };&#13;
&#13;
  for (var key in matrices) {&#13;
    filters[key] = createClass(filters.ColorMatrix, /** @lends fabric.Image.filters.Sepia.prototype */ {&#13;
&#13;
      /**&#13;
       * Filter type&#13;
       * @param {String} type&#13;
       * @default&#13;
       */&#13;
      type: key,&#13;
&#13;
      /**&#13;
       * Colormatrix for the effect&#13;
       * array of 20 floats. Numbers in positions 4, 9, 14, 19 loose meaning&#13;
       * outside the -1, 1 range.&#13;
       * @param {Array} matrix array of 20 numbers.&#13;
       * @default&#13;
       */&#13;
      matrix: matrices[key],&#13;
&#13;
      /**&#13;
       * Lock the matrix export for this kind of static, parameter less filters.&#13;
       */&#13;
      mainParameter: false,&#13;
      /**&#13;
       * Lock the colormatrix on the color part, skipping alpha&#13;
       */&#13;
      colorsOnly: true,&#13;
&#13;
    });&#13;
    fabric.Image.filters[key].fromObject = fabric.Image.filters.BaseFilter.fromObject;&#13;
  }&#13;
})(typeof exports !== 'undefined' ? exports : this);&#13;
&#13;
&#13;
(function(global) {&#13;
  'use strict';&#13;
&#13;
  var fabric = global.fabric,&#13;
      filters = fabric.Image.filters,&#13;
      createClass = fabric.util.createClass;&#13;
&#13;
  /**&#13;
   * Color Blend filter class&#13;
   * @class fabric.Image.filter.BlendColor&#13;
   * @memberOf fabric.Image.filters&#13;
   * @extends fabric.Image.filters.BaseFilter&#13;
   * @example&#13;
   * var filter = new fabric.Image.filters.BlendColor({&#13;
   *  color: '#000',&#13;
   *  mode: 'multiply'&#13;
   * });&#13;
   *&#13;
   * var filter = new fabric.Image.filters.BlendImage({&#13;
   *  image: fabricImageObject,&#13;
   *  mode: 'multiply',&#13;
   *  alpha: 0.5&#13;
   * });&#13;
   * object.filters.push(filter);&#13;
   * object.applyFilters();&#13;
   * canvas.renderAll();&#13;
   */&#13;
&#13;
  filters.BlendColor = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Blend.prototype */ {&#13;
    type: 'BlendColor',&#13;
&#13;
    /**&#13;
     * Color to make the blend operation with. default to a reddish color since black or white&#13;
     * gives always strong result.&#13;
     **/&#13;
    color: '#F95C63',&#13;
&#13;
    /**&#13;
     * Blend mode for the filter: one of multiply, add, diff, screen, subtract,&#13;
     * darken, lighten, overlay, exclusion, tint.&#13;
     **/&#13;
    mode: 'multiply',&#13;
&#13;
    /**&#13;
     * alpha value. represent the strength of the blend color operation.&#13;
     **/&#13;
    alpha: 1,&#13;
&#13;
    /**&#13;
     * Fragment source for the Multiply program&#13;
     */&#13;
    fragmentSource: {&#13;
      multiply: 'precision highp float;\n' +&#13;
        'uniform sampler2D uTexture;\n' +&#13;
        'uniform vec4 uColor;\n' +&#13;
        'varying vec2 vTexCoord;\n' +&#13;
        'void main() {\n' +&#13;
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +&#13;
          'color.rgb *= uColor.rgb;\n' +&#13;
          'gl_FragColor = color;\n' +&#13;
        '}',&#13;
      screen: 'precision highp float;\n' +&#13;
        'uniform sampler2D uTexture;\n' +&#13;
        'uniform vec4 uColor;\n' +&#13;
        'varying vec2 vTexCoord;\n' +&#13;
        'void main() {\n' +&#13;
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +&#13;
          'color.rgb = 1.0 - (1.0 - color.rgb) * (1.0 - uColor.rgb);\n' +&#13;
          'gl_FragColor = color;\n' +&#13;
        '}',&#13;
      add: 'precision highp float;\n' +&#13;
        'uniform sampler2D uTexture;\n' +&#13;
        'uniform vec4 uColor;\n' +&#13;
        'varying vec2 vTexCoord;\n' +&#13;
        'void main() {\n' +&#13;
          'gl_FragColor = texture2D(uTexture, vTexCoord);\n' +&#13;
          'gl_FragColor.rgb += uColor.rgb;\n' +&#13;
        '}',&#13;
      diff: 'precision highp float;\n' +&#13;
        'uniform sampler2D uTexture;\n' +&#13;
        'uniform vec4 uColor;\n' +&#13;
        'varying vec2 vTexCoord;\n' +&#13;
        'void main() {\n' +&#13;
          'gl_FragColor = texture2D(uTexture, vTexCoord);\n' +&#13;
          'gl_FragColor.rgb = abs(gl_FragColor.rgb - uColor.rgb);\n' +&#13;
      '}',&#13;
      subtract: 'precision highp float;\n' +&#13;
        'uniform sampler2D uTexture;\n' +&#13;
        'uniform vec4 uColor;\n' +&#13;
        'varying vec2 vTexCoord;\n' +&#13;
        'void main() {\n' +&#13;
          'gl_FragColor = texture2D(uTexture, vTexCoord);\n' +&#13;
          'gl_FragColor.rgb -= uColor.rgb;\n' +&#13;
        '}',&#13;
      lighten: 'precision highp float;\n' +&#13;
        'uniform sampler2D uTexture;\n' +&#13;
        'uniform vec4 uColor;\n' +&#13;
        'varying vec2 vTexCoord;\n' +&#13;
        'void main() {\n' +&#13;
          'gl_FragColor = texture2D(uTexture, vTexCoord);\n' +&#13;
          'gl_FragColor.rgb = max(gl_FragColor.rgb, uColor.rgb);\n' +&#13;
        '}',&#13;
      darken: 'precision highp float;\n' +&#13;
        'uniform sampler2D uTexture;\n' +&#13;
        'uniform vec4 uColor;\n' +&#13;
        'varying vec2 vTexCoord;\n' +&#13;
        'void main() {\n' +&#13;
          'gl_FragColor = texture2D(uTexture, vTexCoord);\n' +&#13;
          'gl_FragColor.rgb = min(gl_FragColor.rgb, uColor.rgb);\n' +&#13;
        '}',&#13;
      exclusion: 'precision highp float;\n' +&#13;
        'uniform sampler2D uTexture;\n' +&#13;
        'uniform vec4 uColor;\n' +&#13;
        'varying vec2 vTexCoord;\n' +&#13;
        'void main() {\n' +&#13;
          'gl_FragColor = texture2D(uTexture, vTexCoord);\n' +&#13;
          'gl_FragColor.rgb += uColor.rgb - 2.0 * (uColor.rgb * gl_FragColor.rgb);\n' +&#13;
        '}',&#13;
      overlay: 'precision highp float;\n' +&#13;
        'uniform sampler2D uTexture;\n' +&#13;
        'uniform vec4 uColor;\n' +&#13;
        'varying vec2 vTexCoord;\n' +&#13;
        'void main() {\n' +&#13;
          'gl_FragColor = texture2D(uTexture, vTexCoord);\n' +&#13;
          'if (uColor.r &lt; 0.5) {\n' +&#13;
            'gl_FragColor.r *= 2.0 * uColor.r;\n' +&#13;
          '} else {\n' +&#13;
            'gl_FragColor.r = 1.0 - 2.0 * (1.0 - gl_FragColor.r) * (1.0 - uColor.r);\n' +&#13;
          '}\n' +&#13;
          'if (uColor.g &lt; 0.5) {\n' +&#13;
            'gl_FragColor.g *= 2.0 * uColor.g;\n' +&#13;
          '} else {\n' +&#13;
            'gl_FragColor.g = 1.0 - 2.0 * (1.0 - gl_FragColor.g) * (1.0 - uColor.g);\n' +&#13;
          '}\n' +&#13;
          'if (uColor.b &lt; 0.5) {\n' +&#13;
            'gl_FragColor.b *= 2.0 * uColor.b;\n' +&#13;
          '} else {\n' +&#13;
            'gl_FragColor.b = 1.0 - 2.0 * (1.0 - gl_FragColor.b) * (1.0 - uColor.b);\n' +&#13;
          '}\n' +&#13;
        '}',&#13;
      tint: 'precision highp float;\n' +&#13;
        'uniform sampler2D uTexture;\n' +&#13;
        'uniform vec4 uColor;\n' +&#13;
        'varying vec2 vTexCoord;\n' +&#13;
        'void main() {\n' +&#13;
          'gl_FragColor = texture2D(uTexture, vTexCoord);\n' +&#13;
          'gl_FragColor.rgb *= (1.0 - uColor.a);\n' +&#13;
          'gl_FragColor.rgb += uColor.rgb;\n' +&#13;
        '}'&#13;
    },&#13;
&#13;
    /**&#13;
     * Retrieves the cached shader.&#13;
     * @param {Object} options&#13;
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.&#13;
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.&#13;
     */&#13;
    retrieveShader: function(options) {&#13;
      var cacheKey = this.type + '_' + this.mode;&#13;
      var shaderSource = this.fragmentSource[this.mode];&#13;
      if (!options.programCache.hasOwnProperty(cacheKey)) {&#13;
        options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);&#13;
      }&#13;
      return options.programCache[cacheKey];&#13;
    },&#13;
&#13;
    /**&#13;
     * Apply the Blend operation to a Uint8ClampedArray representing the pixels of an image.&#13;
     *&#13;
     * @param {Object} options&#13;
     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.&#13;
     */&#13;
    applyTo2d: function(options) {&#13;
      var imageData = options.imageData,&#13;
          data = imageData.data, iLen = data.length,&#13;
          tr, tg, tb,&#13;
          r, g, b,&#13;
          source, alpha1 = 1 - this.alpha;&#13;
&#13;
      source = new fabric.Color(this.color).getSource();&#13;
      tr = source[0] * this.alpha;&#13;
      tg = source[1] * this.alpha;&#13;
      tb = source[2] * this.alpha;&#13;
&#13;
      for (var i = 0; i &lt; iLen; i += 4) {&#13;
&#13;
        r = data[i];&#13;
        g = data[i + 1];&#13;
        b = data[i + 2];&#13;
&#13;
        switch (this.mode) {&#13;
          case 'multiply':&#13;
            data[i] = r * tr / 255;&#13;
            data[i + 1] = g * tg / 255;&#13;
            data[i + 2] = b * tb / 255;&#13;
            break;&#13;
          case 'screen':&#13;
            data[i] = 255 - (255 - r) * (255 - tr) / 255;&#13;
            data[i + 1] = 255 - (255 - g) * (255 - tg) / 255;&#13;
            data[i + 2] = 255 - (255 - b) * (255 - tb) / 255;&#13;
            break;&#13;
          case 'add':&#13;
            data[i] = r + tr;&#13;
            data[i + 1] = g + tg;&#13;
            data[i + 2] = b + tb;&#13;
            break;&#13;
          case 'diff':&#13;
          case 'difference':&#13;
            data[i] = Math.abs(r - tr);&#13;
            data[i + 1] = Math.abs(g - tg);&#13;
            data[i + 2] = Math.abs(b - tb);&#13;
            break;&#13;
          case 'subtract':&#13;
            data[i] = r - tr;&#13;
            data[i + 1] = g - tg;&#13;
            data[i + 2] = b - tb;&#13;
            break;&#13;
          case 'darken':&#13;
            data[i] = Math.min(r, tr);&#13;
            data[i + 1] = Math.min(g, tg);&#13;
            data[i + 2] = Math.min(b, tb);&#13;
            break;&#13;
          case 'lighten':&#13;
            data[i] = Math.max(r, tr);&#13;
            data[i + 1] = Math.max(g, tg);&#13;
            data[i + 2] = Math.max(b, tb);&#13;
            break;&#13;
          case 'overlay':&#13;
            data[i] = tr &lt; 128 ? (2 * r * tr / 255) : (255 - 2 * (255 - r) * (255 - tr) / 255);&#13;
            data[i + 1] = tg &lt; 128 ? (2 * g * tg / 255) : (255 - 2 * (255 - g) * (255 - tg) / 255);&#13;
            data[i + 2] = tb &lt; 128 ? (2 * b * tb / 255) : (255 - 2 * (255 - b) * (255 - tb) / 255);&#13;
            break;&#13;
          case 'exclusion':&#13;
            data[i] = tr + r - ((2 * tr * r) / 255);&#13;
            data[i + 1] = tg + g - ((2 * tg * g) / 255);&#13;
            data[i + 2] = tb + b - ((2 * tb * b) / 255);&#13;
            break;&#13;
          case 'tint':&#13;
            data[i] = tr + r * alpha1;&#13;
            data[i + 1] = tg + g * alpha1;&#13;
            data[i + 2] = tb + b * alpha1;&#13;
        }&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Return WebGL uniform locations for this filter's shader.&#13;
     *&#13;
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.&#13;
     * @param {WebGLShaderProgram} program This filter's compiled shader program.&#13;
     */&#13;
    getUniformLocations: function(gl, program) {&#13;
      return {&#13;
        uColor: gl.getUniformLocation(program, 'uColor'),&#13;
      };&#13;
    },&#13;
&#13;
    /**&#13;
     * Send data from this filter to its shader program's uniforms.&#13;
     *&#13;
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.&#13;
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects&#13;
     */&#13;
    sendUniformData: function(gl, uniformLocations) {&#13;
      var source = new fabric.Color(this.color).getSource();&#13;
      source[0] = this.alpha * source[0] / 255;&#13;
      source[1] = this.alpha * source[1] / 255;&#13;
      source[2] = this.alpha * source[2] / 255;&#13;
      source[3] = this.alpha;&#13;
      gl.uniform4fv(uniformLocations.uColor, source);&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns object representation of an instance&#13;
     * @return {Object} Object representation of an instance&#13;
     */&#13;
    toObject: function() {&#13;
      return {&#13;
        type: this.type,&#13;
        color: this.color,&#13;
        mode: this.mode,&#13;
        alpha: this.alpha&#13;
      };&#13;
    }&#13;
  });&#13;
&#13;
  /**&#13;
   * Returns filter instance from an object representation&#13;
   * @static&#13;
   * @param {Object} object Object to create an instance from&#13;
   * @param {function} [callback] to be invoked after filter creation&#13;
   * @return {fabric.Image.filters.BlendColor} Instance of fabric.Image.filters.BlendColor&#13;
   */&#13;
  fabric.Image.filters.BlendColor.fromObject = fabric.Image.filters.BaseFilter.fromObject;&#13;
&#13;
})(typeof exports !== 'undefined' ? exports : this);&#13;
&#13;
&#13;
(function(global) {&#13;
  'use strict';&#13;
&#13;
  var fabric = global.fabric,&#13;
      filters = fabric.Image.filters,&#13;
      createClass = fabric.util.createClass;&#13;
&#13;
  /**&#13;
   * Image Blend filter class&#13;
   * @class fabric.Image.filter.BlendImage&#13;
   * @memberOf fabric.Image.filters&#13;
   * @extends fabric.Image.filters.BaseFilter&#13;
   * @example&#13;
   * var filter = new fabric.Image.filters.BlendColor({&#13;
   *  color: '#000',&#13;
   *  mode: 'multiply'&#13;
   * });&#13;
   *&#13;
   * var filter = new fabric.Image.filters.BlendImage({&#13;
   *  image: fabricImageObject,&#13;
   *  mode: 'multiply',&#13;
   *  alpha: 0.5&#13;
   * });&#13;
   * object.filters.push(filter);&#13;
   * object.applyFilters();&#13;
   * canvas.renderAll();&#13;
   */&#13;
&#13;
  filters.BlendImage = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.BlendImage.prototype */ {&#13;
    type: 'BlendImage',&#13;
&#13;
    /**&#13;
     * Color to make the blend operation with. default to a reddish color since black or white&#13;
     * gives always strong result.&#13;
     **/&#13;
    image: null,&#13;
&#13;
    /**&#13;
     * Blend mode for the filter: one of multiply, add, diff, screen, subtract,&#13;
     * darken, lighten, overlay, exclusion, tint.&#13;
     **/&#13;
    mode: 'multiply',&#13;
&#13;
    /**&#13;
     * alpha value. represent the strength of the blend color operation.&#13;
     **/&#13;
    alpha: 1,&#13;
&#13;
    vertexSource: 'attribute vec2 aPosition;\n' +&#13;
      'attribute vec2 aTexCoord;\n' +&#13;
      'varying vec2 vTexCoord;\n' +&#13;
      'varying vec2 vTexCoord2;\n' +&#13;
      'uniform mat3 uTransformMatrix;\n' +&#13;
      'void main() {\n' +&#13;
        'vTexCoord = aTexCoord;\n' +&#13;
        'vTexCoord2 = (uTransformMatrix * vec3(aTexCoord, 1.0)).xy;\n' +&#13;
        'gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\n' +&#13;
      '}',&#13;
&#13;
    /**&#13;
     * Fragment source for the Multiply program&#13;
     */&#13;
    fragmentSource: {&#13;
      multiply: 'precision highp float;\n' +&#13;
        'uniform sampler2D uTexture;\n' +&#13;
        'uniform sampler2D uImage;\n' +&#13;
        'uniform vec4 uColor;\n' +&#13;
        'varying vec2 vTexCoord;\n' +&#13;
        'varying vec2 vTexCoord2;\n' +&#13;
        'void main() {\n' +&#13;
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +&#13;
          'vec4 color2 = texture2D(uImage, vTexCoord2);\n' +&#13;
          'color.rgba *= color2.rgba;\n' +&#13;
          'gl_FragColor = color;\n' +&#13;
        '}',&#13;
      mask: 'precision highp float;\n' +&#13;
        'uniform sampler2D uTexture;\n' +&#13;
        'uniform sampler2D uImage;\n' +&#13;
        'uniform vec4 uColor;\n' +&#13;
        'varying vec2 vTexCoord;\n' +&#13;
        'varying vec2 vTexCoord2;\n' +&#13;
        'void main() {\n' +&#13;
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +&#13;
          'vec4 color2 = texture2D(uImage, vTexCoord2);\n' +&#13;
          'color.a = color2.a;\n' +&#13;
          'gl_FragColor = color;\n' +&#13;
        '}',&#13;
    },&#13;
&#13;
    /**&#13;
     * Retrieves the cached shader.&#13;
     * @param {Object} options&#13;
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.&#13;
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.&#13;
     */&#13;
    retrieveShader: function(options) {&#13;
      var cacheKey = this.type + '_' + this.mode;&#13;
      var shaderSource = this.fragmentSource[this.mode];&#13;
      if (!options.programCache.hasOwnProperty(cacheKey)) {&#13;
        options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);&#13;
      }&#13;
      return options.programCache[cacheKey];&#13;
    },&#13;
&#13;
    applyToWebGL: function(options) {&#13;
      // load texture to blend.&#13;
      var gl = options.context,&#13;
          texture = this.createTexture(options.filterBackend, this.image);&#13;
      this.bindAdditionalTexture(gl, texture, gl.TEXTURE1);&#13;
      this.callSuper('applyToWebGL', options);&#13;
      this.unbindAdditionalTexture(gl, gl.TEXTURE1);&#13;
    },&#13;
&#13;
    createTexture: function(backend, image) {&#13;
      return backend.getCachedTexture(image.cacheKey, image._element);&#13;
    },&#13;
&#13;
    /**&#13;
     * Calculate a transformMatrix to adapt the image to blend over&#13;
     * @param {Object} options&#13;
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.&#13;
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.&#13;
     */&#13;
    calculateMatrix: function() {&#13;
      var image = this.image,&#13;
          width = image._element.width,&#13;
          height = image._element.height;&#13;
      return [&#13;
        1 / image.scaleX, 0, 0,&#13;
        0, 1 / image.scaleY, 0,&#13;
        -image.left / width, -image.top / height, 1&#13;
      ];&#13;
    },&#13;
&#13;
    /**&#13;
     * Apply the Blend operation to a Uint8ClampedArray representing the pixels of an image.&#13;
     *&#13;
     * @param {Object} options&#13;
     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.&#13;
     */&#13;
    applyTo2d: function(options) {&#13;
      var imageData = options.imageData,&#13;
          resources = options.filterBackend.resources,&#13;
          data = imageData.data, iLen = data.length,&#13;
          width = options.imageData.width,&#13;
          height = options.imageData.height,&#13;
          tr, tg, tb, ta,&#13;
          r, g, b, a,&#13;
          canvas1, context, image = this.image, blendData;&#13;
&#13;
      if (!resources.blendImage) {&#13;
        resources.blendImage = document.createElement('canvas');&#13;
      }&#13;
      canvas1 = resources.blendImage;&#13;
      if (canvas1.width !== width || canvas1.height !== height) {&#13;
        canvas1.width = width;&#13;
        canvas1.height = height;&#13;
      }&#13;
      context = canvas1.getContext('2d');&#13;
      context.setTransform(image.scaleX, 0, 0, image.scaleY, image.left, image.top);&#13;
      context.drawImage(image._element, 0, 0, width, height);&#13;
      blendData = context.getImageData(0, 0, width, height).data;&#13;
      for (var i = 0; i &lt; iLen; i += 4) {&#13;
&#13;
        r = data[i];&#13;
        g = data[i + 1];&#13;
        b = data[i + 2];&#13;
        a = data[i + 3];&#13;
&#13;
        tr = blendData[i];&#13;
        tg = blendData[i + 1];&#13;
        tb = blendData[i + 2];&#13;
        ta = blendData[i + 3];&#13;
&#13;
        switch (this.mode) {&#13;
          case 'multiply':&#13;
            data[i] = r * tr / 255;&#13;
            data[i + 1] = g * tg / 255;&#13;
            data[i + 2] = b * tb / 255;&#13;
            data[i + 3] = a * ta / 255;&#13;
            break;&#13;
          case 'mask':&#13;
            data[i + 3] = ta;&#13;
            break;&#13;
        }&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Return WebGL uniform locations for this filter's shader.&#13;
     *&#13;
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.&#13;
     * @param {WebGLShaderProgram} program This filter's compiled shader program.&#13;
     */&#13;
    getUniformLocations: function(gl, program) {&#13;
      return {&#13;
        uTransformMatrix: gl.getUniformLocation(program, 'uTransformMatrix'),&#13;
        uImage: gl.getUniformLocation(program, 'uImage'),&#13;
      };&#13;
    },&#13;
&#13;
    /**&#13;
     * Send data from this filter to its shader program's uniforms.&#13;
     *&#13;
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.&#13;
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects&#13;
     */&#13;
    sendUniformData: function(gl, uniformLocations) {&#13;
      var matrix = this.calculateMatrix();&#13;
      gl.uniform1i(uniformLocations.uImage, 1); // texture unit 1.&#13;
      gl.uniformMatrix3fv(uniformLocations.uTransformMatrix, false, matrix);&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns object representation of an instance&#13;
     * @return {Object} Object representation of an instance&#13;
     */&#13;
    toObject: function() {&#13;
      return {&#13;
        type: this.type,&#13;
        image: this.image &amp;&amp; this.image.toObject(),&#13;
        mode: this.mode,&#13;
        alpha: this.alpha&#13;
      };&#13;
    }&#13;
  });&#13;
&#13;
  /**&#13;
   * Returns filter instance from an object representation&#13;
   * @static&#13;
   * @param {Object} object Object to create an instance from&#13;
   * @param {function} callback to be invoked after filter creation&#13;
   * @return {fabric.Image.filters.BlendImage} Instance of fabric.Image.filters.BlendImage&#13;
   */&#13;
  fabric.Image.filters.BlendImage.fromObject = function(object, callback) {&#13;
    fabric.Image.fromObject(object.image, function(image) {&#13;
      var options = fabric.util.object.clone(object);&#13;
      options.image = image;&#13;
      callback(new fabric.Image.filters.BlendImage(options));&#13;
    });&#13;
  };&#13;
&#13;
})(typeof exports !== 'undefined' ? exports : this);&#13;
&#13;
&#13;
(function(global) {&#13;
&#13;
  'use strict';&#13;
&#13;
  var fabric  = global.fabric || (global.fabric = { }), pow = Math.pow, floor = Math.floor,&#13;
      sqrt = Math.sqrt, abs = Math.abs, round = Math.round, sin = Math.sin,&#13;
      ceil = Math.ceil,&#13;
      filters = fabric.Image.filters,&#13;
      createClass = fabric.util.createClass;&#13;
&#13;
  /**&#13;
   * Resize image filter class&#13;
   * @class fabric.Image.filters.Resize&#13;
   * @memberOf fabric.Image.filters&#13;
   * @extends fabric.Image.filters.BaseFilter&#13;
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}&#13;
   * @example&#13;
   * var filter = new fabric.Image.filters.Resize();&#13;
   * object.filters.push(filter);&#13;
   * object.applyFilters(canvas.renderAll.bind(canvas));&#13;
   */&#13;
  filters.Resize = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Resize.prototype */ {&#13;
&#13;
    /**&#13;
     * Filter type&#13;
     * @param {String} type&#13;
     * @default&#13;
     */&#13;
    type: 'Resize',&#13;
&#13;
    /**&#13;
     * Resize type&#13;
     * @param {String} resizeType&#13;
     * @default&#13;
     */&#13;
    resizeType: 'hermite',&#13;
&#13;
    /**&#13;
     * Scale factor for resizing, x axis&#13;
     * @param {Number} scaleX&#13;
     * @default&#13;
     */&#13;
    scaleX: 0,&#13;
&#13;
    /**&#13;
     * Scale factor for resizing, y axis&#13;
     * @param {Number} scaleY&#13;
     * @default&#13;
     */&#13;
    scaleY: 0,&#13;
&#13;
    /**&#13;
     * LanczosLobes parameter for lanczos filter&#13;
     * @param {Number} lanczosLobes&#13;
     * @default&#13;
     */&#13;
    lanczosLobes: 3,&#13;
&#13;
&#13;
    /**&#13;
     * Return WebGL uniform locations for this filter's shader.&#13;
     *&#13;
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.&#13;
     * @param {WebGLShaderProgram} program This filter's compiled shader program.&#13;
     */&#13;
    getUniformLocations: function(gl, program) {&#13;
      return {&#13;
        uDelta: gl.getUniformLocation(program, 'uDelta'),&#13;
        uTaps: gl.getUniformLocation(program, 'uTaps'),&#13;
      };&#13;
    },&#13;
&#13;
    /**&#13;
     * Send data from this filter to its shader program's uniforms.&#13;
     *&#13;
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.&#13;
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects&#13;
     */&#13;
    sendUniformData: function(gl, uniformLocations) {&#13;
      gl.uniform2fv(uniformLocations.uDelta, this.horizontal ? [1 / this.width, 0] : [0, 1 / this.height]);&#13;
      gl.uniform1fv(uniformLocations.uTaps, this.taps);&#13;
    },&#13;
&#13;
    /**&#13;
     * Retrieves the cached shader.&#13;
     * @param {Object} options&#13;
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.&#13;
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.&#13;
     */&#13;
    retrieveShader: function(options) {&#13;
      var filterWindow = this.getFilterWindow(), cacheKey = this.type + '_' + filterWindow;&#13;
      if (!options.programCache.hasOwnProperty(cacheKey)) {&#13;
        var fragmentShader = this.generateShader(filterWindow);&#13;
        options.programCache[cacheKey] = this.createProgram(options.context, fragmentShader);&#13;
      }&#13;
      return options.programCache[cacheKey];&#13;
    },&#13;
&#13;
    getFilterWindow: function() {&#13;
      var scale = this.tempScale;&#13;
      return Math.ceil(this.lanczosLobes / scale);&#13;
    },&#13;
&#13;
    getTaps: function() {&#13;
      var lobeFunction = this.lanczosCreate(this.lanczosLobes), scale = this.tempScale,&#13;
          filterWindow = this.getFilterWindow(), taps = new Array(filterWindow);&#13;
      for (var i = 1; i &lt;= filterWindow; i++) {&#13;
        taps[i - 1] = lobeFunction(i * scale);&#13;
      }&#13;
      return taps;&#13;
    },&#13;
&#13;
    /**&#13;
     * Generate vertex and shader sources from the necessary steps numbers&#13;
     * @param {Number} filterWindow&#13;
     */&#13;
    generateShader: function(filterWindow) {&#13;
      var offsets = new Array(filterWindow),&#13;
          fragmentShader = this.fragmentSourceTOP, filterWindow;&#13;
&#13;
      for (var i = 1; i &lt;= filterWindow; i++) {&#13;
        offsets[i - 1] = i + '.0 * uDelta';&#13;
      }&#13;
&#13;
      fragmentShader += 'uniform float uTaps[' + filterWindow + '];\n';&#13;
      fragmentShader += 'void main() {\n';&#13;
      fragmentShader += '  vec4 color = texture2D(uTexture, vTexCoord);\n';&#13;
      fragmentShader += '  float sum = 1.0;\n';&#13;
&#13;
      offsets.forEach(function(offset, i) {&#13;
        fragmentShader += '  color += texture2D(uTexture, vTexCoord + ' + offset + ') * uTaps[' + i + '];\n';&#13;
        fragmentShader += '  color += texture2D(uTexture, vTexCoord - ' + offset + ') * uTaps[' + i + '];\n';&#13;
        fragmentShader += '  sum += 2.0 * uTaps[' + i + '];\n';&#13;
      });&#13;
      fragmentShader += '  gl_FragColor = color / sum;\n';&#13;
      fragmentShader += '}';&#13;
      return fragmentShader;&#13;
    },&#13;
&#13;
    fragmentSourceTOP: 'precision highp float;\n' +&#13;
      'uniform sampler2D uTexture;\n' +&#13;
      'uniform vec2 uDelta;\n' +&#13;
      'varying vec2 vTexCoord;\n',&#13;
&#13;
    /**&#13;
     * Apply the resize filter to the image&#13;
     * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.&#13;
     *&#13;
     * @param {Object} options&#13;
     * @param {Number} options.passes The number of filters remaining to be executed&#13;
     * @param {Boolean} options.webgl Whether to use webgl to render the filter.&#13;
     * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.&#13;
     * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.&#13;
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.&#13;
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.&#13;
     */&#13;
    applyTo: function(options) {&#13;
      if (options.webgl) {&#13;
        if (options.passes &gt; 1 &amp;&amp; this.isNeutralState(options)) {&#13;
          // avoid doing something that we do not need&#13;
          return;&#13;
        }&#13;
        options.passes++;&#13;
        this.width = options.sourceWidth;&#13;
        this.horizontal = true;&#13;
        this.dW = Math.round(this.width * this.scaleX);&#13;
        this.dH = options.sourceHeight;&#13;
        this.tempScale = this.dW / this.width;&#13;
        this.taps = this.getTaps();&#13;
        options.destinationWidth = this.dW;&#13;
        this._setupFrameBuffer(options);&#13;
        this.applyToWebGL(options);&#13;
        this._swapTextures(options);&#13;
        options.sourceWidth = options.destinationWidth;&#13;
&#13;
        this.height = options.sourceHeight;&#13;
        this.horizontal = false;&#13;
        this.dH = Math.round(this.height * this.scaleY);&#13;
        this.tempScale = this.dH / this.height;&#13;
        this.taps = this.getTaps();&#13;
        options.destinationHeight = this.dH;&#13;
        this._setupFrameBuffer(options);&#13;
        this.applyToWebGL(options);&#13;
        this._swapTextures(options);&#13;
        options.sourceHeight = options.destinationHeight;&#13;
      }&#13;
      else if (!this.isNeutralState(options)) {&#13;
        this.applyTo2d(options);&#13;
      }&#13;
    },&#13;
&#13;
    isNeutralState: function(options) {&#13;
      var scaleX = options.scaleX || this.scaleX,&#13;
          scaleY = options.scaleY || this.scaleY;&#13;
      return scaleX === 1 &amp;&amp; scaleY === 1;&#13;
    },&#13;
&#13;
    lanczosCreate: function(lobes) {&#13;
      return function(x) {&#13;
        if (x &gt;= lobes || x &lt;= -lobes) {&#13;
          return 0.0;&#13;
        }&#13;
        if (x &lt; 1.19209290E-07 &amp;&amp; x &gt; -1.19209290E-07) {&#13;
          return 1.0;&#13;
        }&#13;
        x *= Math.PI;&#13;
        var xx = x / lobes;&#13;
        return (sin(x) / x) * sin(xx) / xx;&#13;
      };&#13;
    },&#13;
&#13;
    /**&#13;
     * Applies filter to canvas element&#13;
     * @memberOf fabric.Image.filters.Resize.prototype&#13;
     * @param {Object} canvasEl Canvas element to apply filter to&#13;
     * @param {Number} scaleX&#13;
     * @param {Number} scaleY&#13;
     */&#13;
    applyTo2d: function(options) {&#13;
      var imageData = options.imageData,&#13;
          scaleX = this.scaleX,&#13;
          scaleY = this.scaleY;&#13;
&#13;
      this.rcpScaleX = 1 / scaleX;&#13;
      this.rcpScaleY = 1 / scaleY;&#13;
&#13;
      var oW = imageData.width, oH = imageData.height,&#13;
          dW = round(oW * scaleX), dH = round(oH * scaleY),&#13;
          newData;&#13;
&#13;
      if (this.resizeType === 'sliceHack') {&#13;
        newData = this.sliceByTwo(options, oW, oH, dW, dH);&#13;
      }&#13;
      else if (this.resizeType === 'hermite') {&#13;
        newData = this.hermiteFastResize(options, oW, oH, dW, dH);&#13;
      }&#13;
      else if (this.resizeType === 'bilinear') {&#13;
        newData = this.bilinearFiltering(options, oW, oH, dW, dH);&#13;
      }&#13;
      else if (this.resizeType === 'lanczos') {&#13;
        newData = this.lanczosResize(options, oW, oH, dW, dH);&#13;
      }&#13;
      options.imageData = newData;&#13;
    },&#13;
&#13;
    /**&#13;
     * Filter sliceByTwo&#13;
     * @param {Object} canvasEl Canvas element to apply filter to&#13;
     * @param {Number} oW Original Width&#13;
     * @param {Number} oH Original Height&#13;
     * @param {Number} dW Destination Width&#13;
     * @param {Number} dH Destination Height&#13;
     * @returns {ImageData}&#13;
     */&#13;
    sliceByTwo: function(options, oW, oH, dW, dH) {&#13;
      var imageData = options.imageData,&#13;
          mult = 0.5, doneW = false, doneH = false, stepW = oW * mult,&#13;
          stepH = oH * mult, resources = fabric.filterBackend.resources,&#13;
          tmpCanvas, ctx, sX = 0, sY = 0, dX = oW, dY = 0;&#13;
      if (!resources.sliceByTwo) {&#13;
        resources.sliceByTwo = document.createElement('canvas');&#13;
      }&#13;
      tmpCanvas = resources.sliceByTwo;&#13;
      if (tmpCanvas.width &lt; oW * 1.5 || tmpCanvas.height &lt; oH) {&#13;
        tmpCanvas.width = oW * 1.5;&#13;
        tmpCanvas.height = oH;&#13;
      }&#13;
      ctx = tmpCanvas.getContext('2d');&#13;
      ctx.clearRect(0, 0, oW * 1.5, oH);&#13;
      ctx.putImageData(imageData, 0, 0);&#13;
&#13;
      dW = floor(dW);&#13;
      dH = floor(dH);&#13;
&#13;
      while (!doneW || !doneH) {&#13;
        oW = stepW;&#13;
        oH = stepH;&#13;
        if (dW &lt; floor(stepW * mult)) {&#13;
          stepW = floor(stepW * mult);&#13;
        }&#13;
        else {&#13;
          stepW = dW;&#13;
          doneW = true;&#13;
        }&#13;
        if (dH &lt; floor(stepH * mult)) {&#13;
          stepH = floor(stepH * mult);&#13;
        }&#13;
        else {&#13;
          stepH = dH;&#13;
          doneH = true;&#13;
        }&#13;
        ctx.drawImage(tmpCanvas, sX, sY, oW, oH, dX, dY, stepW, stepH);&#13;
        sX = dX;&#13;
        sY = dY;&#13;
        dY += stepH;&#13;
      }&#13;
      return ctx.getImageData(sX, sY, dW, dH);&#13;
    },&#13;
&#13;
    /**&#13;
     * Filter lanczosResize&#13;
     * @param {Object} canvasEl Canvas element to apply filter to&#13;
     * @param {Number} oW Original Width&#13;
     * @param {Number} oH Original Height&#13;
     * @param {Number} dW Destination Width&#13;
     * @param {Number} dH Destination Height&#13;
     * @returns {ImageData}&#13;
     */&#13;
    lanczosResize: function(options, oW, oH, dW, dH) {&#13;
&#13;
      function process(u) {&#13;
        var v, i, weight, idx, a, red, green,&#13;
            blue, alpha, fX, fY;&#13;
        center.x = (u + 0.5) * ratioX;&#13;
        icenter.x = floor(center.x);&#13;
        for (v = 0; v &lt; dH; v++) {&#13;
          center.y = (v + 0.5) * ratioY;&#13;
          icenter.y = floor(center.y);&#13;
          a = 0; red = 0; green = 0; blue = 0; alpha = 0;&#13;
          for (i = icenter.x - range2X; i &lt;= icenter.x + range2X; i++) {&#13;
            if (i &lt; 0 || i &gt;= oW) {&#13;
              continue;&#13;
            }&#13;
            fX = floor(1000 * abs(i - center.x));&#13;
            if (!cacheLanc[fX]) {&#13;
              cacheLanc[fX] = { };&#13;
            }&#13;
            for (var j = icenter.y - range2Y; j &lt;= icenter.y + range2Y; j++) {&#13;
              if (j &lt; 0 || j &gt;= oH) {&#13;
                continue;&#13;
              }&#13;
              fY = floor(1000 * abs(j - center.y));&#13;
              if (!cacheLanc[fX][fY]) {&#13;
                cacheLanc[fX][fY] = lanczos(sqrt(pow(fX * rcpRatioX, 2) + pow(fY * rcpRatioY, 2)) / 1000);&#13;
              }&#13;
              weight = cacheLanc[fX][fY];&#13;
              if (weight &gt; 0) {&#13;
                idx = (j * oW + i) * 4;&#13;
                a += weight;&#13;
                red += weight * srcData[idx];&#13;
                green += weight * srcData[idx + 1];&#13;
                blue += weight * srcData[idx + 2];&#13;
                alpha += weight * srcData[idx + 3];&#13;
              }&#13;
            }&#13;
          }&#13;
          idx = (v * dW + u) * 4;&#13;
          destData[idx] = red / a;&#13;
          destData[idx + 1] = green / a;&#13;
          destData[idx + 2] = blue / a;&#13;
          destData[idx + 3] = alpha / a;&#13;
        }&#13;
&#13;
        if (++u &lt; dW) {&#13;
          return process(u);&#13;
        }&#13;
        else {&#13;
          return destImg;&#13;
        }&#13;
      }&#13;
&#13;
      var srcData = options.imageData.data,&#13;
          destImg = options.ctx.createImageData(dW, dH),&#13;
          destData = destImg.data,&#13;
          lanczos = this.lanczosCreate(this.lanczosLobes),&#13;
          ratioX = this.rcpScaleX, ratioY = this.rcpScaleY,&#13;
          rcpRatioX = 2 / this.rcpScaleX, rcpRatioY = 2 / this.rcpScaleY,&#13;
          range2X = ceil(ratioX * this.lanczosLobes / 2),&#13;
          range2Y = ceil(ratioY * this.lanczosLobes / 2),&#13;
          cacheLanc = { }, center = { }, icenter = { };&#13;
&#13;
      return process(0);&#13;
    },&#13;
&#13;
    /**&#13;
     * bilinearFiltering&#13;
     * @param {Object} canvasEl Canvas element to apply filter to&#13;
     * @param {Number} oW Original Width&#13;
     * @param {Number} oH Original Height&#13;
     * @param {Number} dW Destination Width&#13;
     * @param {Number} dH Destination Height&#13;
     * @returns {ImageData}&#13;
     */&#13;
    bilinearFiltering: function(options, oW, oH, dW, dH) {&#13;
      var a, b, c, d, x, y, i, j, xDiff, yDiff, chnl,&#13;
          color, offset = 0, origPix, ratioX = this.rcpScaleX,&#13;
          ratioY = this.rcpScaleY,&#13;
          w4 = 4 * (oW - 1), img = options.imageData,&#13;
          pixels = img.data, destImage = options.ctx.createImageData(dW, dH),&#13;
          destPixels = destImage.data;&#13;
      for (i = 0; i &lt; dH; i++) {&#13;
        for (j = 0; j &lt; dW; j++) {&#13;
          x = floor(ratioX * j);&#13;
          y = floor(ratioY * i);&#13;
          xDiff = ratioX * j - x;&#13;
          yDiff = ratioY * i - y;&#13;
          origPix = 4 * (y * oW + x);&#13;
&#13;
          for (chnl = 0; chnl &lt; 4; chnl++) {&#13;
            a = pixels[origPix + chnl];&#13;
            b = pixels[origPix + 4 + chnl];&#13;
            c = pixels[origPix + w4 + chnl];&#13;
            d = pixels[origPix + w4 + 4 + chnl];&#13;
            color = a * (1 - xDiff) * (1 - yDiff) + b * xDiff * (1 - yDiff) +&#13;
                    c * yDiff * (1 - xDiff) + d * xDiff * yDiff;&#13;
            destPixels[offset++] = color;&#13;
          }&#13;
        }&#13;
      }&#13;
      return destImage;&#13;
    },&#13;
&#13;
    /**&#13;
     * hermiteFastResize&#13;
     * @param {Object} canvasEl Canvas element to apply filter to&#13;
     * @param {Number} oW Original Width&#13;
     * @param {Number} oH Original Height&#13;
     * @param {Number} dW Destination Width&#13;
     * @param {Number} dH Destination Height&#13;
     * @returns {ImageData}&#13;
     */&#13;
    hermiteFastResize: function(options, oW, oH, dW, dH) {&#13;
      var ratioW = this.rcpScaleX, ratioH = this.rcpScaleY,&#13;
          ratioWHalf = ceil(ratioW / 2),&#13;
          ratioHHalf = ceil(ratioH / 2),&#13;
          img = options.imageData, data = img.data,&#13;
          img2 = options.ctx.createImageData(dW, dH), data2 = img2.data;&#13;
      for (var j = 0; j &lt; dH; j++) {&#13;
        for (var i = 0; i &lt; dW; i++) {&#13;
          var x2 = (i + j * dW) * 4, weight = 0, weights = 0, weightsAlpha = 0,&#13;
              gxR = 0, gxG = 0, gxB = 0, gxA = 0, centerY = (j + 0.5) * ratioH;&#13;
          for (var yy = floor(j * ratioH); yy &lt; (j + 1) * ratioH; yy++) {&#13;
            var dy = abs(centerY - (yy + 0.5)) / ratioHHalf,&#13;
                centerX = (i + 0.5) * ratioW, w0 = dy * dy;&#13;
            for (var xx = floor(i * ratioW); xx &lt; (i + 1) * ratioW; xx++) {&#13;
              var dx = abs(centerX - (xx + 0.5)) / ratioWHalf,&#13;
                  w = sqrt(w0 + dx * dx);&#13;
              /* eslint-disable max-depth */&#13;
              if (w &gt; 1 &amp;&amp; w &lt; -1) {&#13;
                continue;&#13;
              }&#13;
              //hermite filter&#13;
              weight = 2 * w * w * w - 3 * w * w + 1;&#13;
              if (weight &gt; 0) {&#13;
                dx = 4 * (xx + yy * oW);&#13;
                //alpha&#13;
                gxA += weight * data[dx + 3];&#13;
                weightsAlpha += weight;&#13;
                //colors&#13;
                if (data[dx + 3] &lt; 255) {&#13;
                  weight = weight * data[dx + 3] / 250;&#13;
                }&#13;
                gxR += weight * data[dx];&#13;
                gxG += weight * data[dx + 1];&#13;
                gxB += weight * data[dx + 2];&#13;
                weights += weight;&#13;
              }&#13;
              /* eslint-enable max-depth */&#13;
            }&#13;
          }&#13;
          data2[x2] = gxR / weights;&#13;
          data2[x2 + 1] = gxG / weights;&#13;
          data2[x2 + 2] = gxB / weights;&#13;
          data2[x2 + 3] = gxA / weightsAlpha;&#13;
        }&#13;
      }&#13;
      return img2;&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns object representation of an instance&#13;
     * @return {Object} Object representation of an instance&#13;
     */&#13;
    toObject: function() {&#13;
      return {&#13;
        type: this.type,&#13;
        scaleX: this.scaleX,&#13;
        scaleY: this.scaleY,&#13;
        resizeType: this.resizeType,&#13;
        lanczosLobes: this.lanczosLobes&#13;
      };&#13;
    }&#13;
  });&#13;
&#13;
  /**&#13;
   * Returns filter instance from an object representation&#13;
   * @static&#13;
   * @param {Object} object Object to create an instance from&#13;
   * @param {Function} [callback] to be invoked after filter creation&#13;
   * @return {fabric.Image.filters.Resize} Instance of fabric.Image.filters.Resize&#13;
   */&#13;
  fabric.Image.filters.Resize.fromObject = fabric.Image.filters.BaseFilter.fromObject;&#13;
&#13;
})(typeof exports !== 'undefined' ? exports : this);&#13;
&#13;
&#13;
(function(global) {&#13;
&#13;
  'use strict';&#13;
&#13;
  var fabric  = global.fabric || (global.fabric = { }),&#13;
      filters = fabric.Image.filters,&#13;
      createClass = fabric.util.createClass;&#13;
&#13;
  /**&#13;
   * Contrast filter class&#13;
   * @class fabric.Image.filters.Contrast&#13;
   * @memberOf fabric.Image.filters&#13;
   * @extends fabric.Image.filters.BaseFilter&#13;
   * @see {@link fabric.Image.filters.Contrast#initialize} for constructor definition&#13;
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}&#13;
   * @example&#13;
   * var filter = new fabric.Image.filters.Contrast({&#13;
   *   contrast: 40&#13;
   * });&#13;
   * object.filters.push(filter);&#13;
   * object.applyFilters();&#13;
   */&#13;
  filters.Contrast = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Contrast.prototype */ {&#13;
&#13;
    /**&#13;
     * Filter type&#13;
     * @param {String} type&#13;
     * @default&#13;
     */&#13;
    type: 'Contrast',&#13;
&#13;
    fragmentSource: 'precision highp float;\n' +&#13;
      'uniform sampler2D uTexture;\n' +&#13;
      'uniform float uContrast;\n' +&#13;
      'varying vec2 vTexCoord;\n' +&#13;
      'void main() {\n' +&#13;
        'vec4 color = texture2D(uTexture, vTexCoord);\n' +&#13;
        'float contrastF = 1.015 * (uContrast + 1.0) / (1.0 * (1.015 - uContrast));\n' +&#13;
        'color.rgb = contrastF * (color.rgb - 0.5) + 0.5;\n' +&#13;
        'gl_FragColor = color;\n' +&#13;
      '}',&#13;
&#13;
    contrast: 0,&#13;
&#13;
    mainParameter: 'contrast',&#13;
&#13;
    /**&#13;
     * Constructor&#13;
     * @memberOf fabric.Image.filters.Contrast.prototype&#13;
     * @param {Object} [options] Options object&#13;
     * @param {Number} [options.contrast=0] Value to contrast the image up (-1...1)&#13;
     */&#13;
&#13;
    /**&#13;
      * Apply the Contrast operation to a Uint8Array representing the pixels of an image.&#13;
      *&#13;
      * @param {Object} options&#13;
      * @param {ImageData} options.imageData The Uint8Array to be filtered.&#13;
      */&#13;
    applyTo2d: function(options) {&#13;
      if (this.contrast === 0) {&#13;
        return;&#13;
      }&#13;
      var imageData = options.imageData, i, len,&#13;
          data = imageData.data, len = data.length,&#13;
          contrast = Math.floor(this.contrast * 255),&#13;
          contrastF = 259 * (contrast + 255) / (255 * (259 - contrast));&#13;
&#13;
      for (i = 0; i &lt; len; i += 4) {&#13;
        data[i] = contrastF * (data[i] - 128) + 128;&#13;
        data[i + 1] = contrastF * (data[i + 1] - 128) + 128;&#13;
        data[i + 2] = contrastF * (data[i + 2] - 128) + 128;&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Return WebGL uniform locations for this filter's shader.&#13;
     *&#13;
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.&#13;
     * @param {WebGLShaderProgram} program This filter's compiled shader program.&#13;
     */&#13;
    getUniformLocations: function(gl, program) {&#13;
      return {&#13;
        uContrast: gl.getUniformLocation(program, 'uContrast'),&#13;
      };&#13;
    },&#13;
&#13;
    /**&#13;
     * Send data from this filter to its shader program's uniforms.&#13;
     *&#13;
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.&#13;
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects&#13;
     */&#13;
    sendUniformData: function(gl, uniformLocations) {&#13;
      gl.uniform1f(uniformLocations.uContrast, this.contrast);&#13;
    },&#13;
  });&#13;
&#13;
  /**&#13;
   * Returns filter instance from an object representation&#13;
   * @static&#13;
   * @param {Object} object Object to create an instance from&#13;
   * @param {function} [callback] to be invoked after filter creation&#13;
   * @return {fabric.Image.filters.Contrast} Instance of fabric.Image.filters.Contrast&#13;
   */&#13;
  fabric.Image.filters.Contrast.fromObject = fabric.Image.filters.BaseFilter.fromObject;&#13;
&#13;
})(typeof exports !== 'undefined' ? exports : this);&#13;
&#13;
&#13;
(function(global) {&#13;
&#13;
  'use strict';&#13;
&#13;
  var fabric  = global.fabric || (global.fabric = { }),&#13;
      filters = fabric.Image.filters,&#13;
      createClass = fabric.util.createClass;&#13;
&#13;
  /**&#13;
   * Saturate filter class&#13;
   * @class fabric.Image.filters.Saturation&#13;
   * @memberOf fabric.Image.filters&#13;
   * @extends fabric.Image.filters.BaseFilter&#13;
   * @see {@link fabric.Image.filters.Saturation#initialize} for constructor definition&#13;
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}&#13;
   * @example&#13;
   * var filter = new fabric.Image.filters.Saturation({&#13;
   *   saturation: 100&#13;
   * });&#13;
   * object.filters.push(filter);&#13;
   * object.applyFilters();&#13;
   */&#13;
  filters.Saturation = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Saturation.prototype */ {&#13;
&#13;
    /**&#13;
     * Filter type&#13;
     * @param {String} type&#13;
     * @default&#13;
     */&#13;
    type: 'Saturation',&#13;
&#13;
    fragmentSource: 'precision highp float;\n' +&#13;
      'uniform sampler2D uTexture;\n' +&#13;
      'uniform float uSaturation;\n' +&#13;
      'varying vec2 vTexCoord;\n' +&#13;
      'void main() {\n' +&#13;
        'vec4 color = texture2D(uTexture, vTexCoord);\n' +&#13;
        'float rgMax = max(color.r, color.g);\n' +&#13;
        'float rgbMax = max(rgMax, color.b);\n' +&#13;
        'color.r += rgbMax != color.r ? (rgbMax - color.r) * uSaturation : 0.00;\n' +&#13;
        'color.g += rgbMax != color.g ? (rgbMax - color.g) * uSaturation : 0.00;\n' +&#13;
        'color.b += rgbMax != color.b ? (rgbMax - color.b) * uSaturation : 0.00;\n' +&#13;
        'gl_FragColor = color;\n' +&#13;
      '}',&#13;
&#13;
    saturation: 0,&#13;
&#13;
    mainParameter: 'saturation',&#13;
&#13;
    /**&#13;
     * Constructor&#13;
     * @memberOf fabric.Image.filters.Saturate.prototype&#13;
     * @param {Object} [options] Options object&#13;
     * @param {Number} [options.saturate=0] Value to saturate the image (-1...1)&#13;
     */&#13;
&#13;
    /**&#13;
     * Apply the Saturation operation to a Uint8ClampedArray representing the pixels of an image.&#13;
     *&#13;
     * @param {Object} options&#13;
     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.&#13;
     */&#13;
    applyTo2d: function(options) {&#13;
      if (this.saturation === 0) {&#13;
        return;&#13;
      }&#13;
      var imageData = options.imageData,&#13;
          data = imageData.data, len = data.length,&#13;
          adjust = -this.saturation, i, max;&#13;
&#13;
      for (i = 0; i &lt; len; i += 4) {&#13;
        max = Math.max(data[i], data[i + 1], data[i + 2]);&#13;
        data[i] += max !== data[i] ? (max - data[i]) * adjust : 0;&#13;
        data[i + 1] += max !== data[i + 1] ? (max - data[i + 1]) * adjust : 0;&#13;
        data[i + 2] += max !== data[i + 2] ? (max - data[i + 2]) * adjust : 0;&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Return WebGL uniform locations for this filter's shader.&#13;
     *&#13;
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.&#13;
     * @param {WebGLShaderProgram} program This filter's compiled shader program.&#13;
     */&#13;
    getUniformLocations: function(gl, program) {&#13;
      return {&#13;
        uSaturation: gl.getUniformLocation(program, 'uSaturation'),&#13;
      };&#13;
    },&#13;
&#13;
    /**&#13;
     * Send data from this filter to its shader program's uniforms.&#13;
     *&#13;
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.&#13;
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects&#13;
     */&#13;
    sendUniformData: function(gl, uniformLocations) {&#13;
      gl.uniform1f(uniformLocations.uSaturation, -this.saturation);&#13;
    },&#13;
  });&#13;
&#13;
  /**&#13;
   * Returns filter instance from an object representation&#13;
   * @static&#13;
   * @param {Object} object Object to create an instance from&#13;
   * @param {Function} [callback] to be invoked after filter creation&#13;
   * @return {fabric.Image.filters.Saturation} Instance of fabric.Image.filters.Saturate&#13;
   */&#13;
  fabric.Image.filters.Saturation.fromObject = fabric.Image.filters.BaseFilter.fromObject;&#13;
&#13;
})(typeof exports !== 'undefined' ? exports : this);&#13;
&#13;
&#13;
(function(global) {&#13;
&#13;
  'use strict';&#13;
&#13;
  var fabric  = global.fabric || (global.fabric = { }),&#13;
      filters = fabric.Image.filters,&#13;
      createClass = fabric.util.createClass;&#13;
&#13;
  /**&#13;
   * Blur filter class&#13;
   * @class fabric.Image.filters.Blur&#13;
   * @memberOf fabric.Image.filters&#13;
   * @extends fabric.Image.filters.BaseFilter&#13;
   * @see {@link fabric.Image.filters.Blur#initialize} for constructor definition&#13;
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}&#13;
   * @example&#13;
   * var filter = new fabric.Image.filters.Blur({&#13;
   *   blur: 0.5&#13;
   * });&#13;
   * object.filters.push(filter);&#13;
   * object.applyFilters();&#13;
   * canvas.renderAll();&#13;
   */&#13;
  filters.Blur = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Blur.prototype */ {&#13;
&#13;
    type: 'Blur',&#13;
&#13;
    /*&#13;
'gl_FragColor = vec4(0.0);',&#13;
'gl_FragColor += texture2D(texture, vTexCoord + -7 * uDelta)*0.0044299121055113265;',&#13;
'gl_FragColor += texture2D(texture, vTexCoord + -6 * uDelta)*0.00895781211794;',&#13;
'gl_FragColor += texture2D(texture, vTexCoord + -5 * uDelta)*0.0215963866053;',&#13;
'gl_FragColor += texture2D(texture, vTexCoord + -4 * uDelta)*0.0443683338718;',&#13;
'gl_FragColor += texture2D(texture, vTexCoord + -3 * uDelta)*0.0776744219933;',&#13;
'gl_FragColor += texture2D(texture, vTexCoord + -2 * uDelta)*0.115876621105;',&#13;
'gl_FragColor += texture2D(texture, vTexCoord + -1 * uDelta)*0.147308056121;',&#13;
'gl_FragColor += texture2D(texture, vTexCoord              )*0.159576912161;',&#13;
'gl_FragColor += texture2D(texture, vTexCoord + 1 * uDelta)*0.147308056121;',&#13;
'gl_FragColor += texture2D(texture, vTexCoord + 2 * uDelta)*0.115876621105;',&#13;
'gl_FragColor += texture2D(texture, vTexCoord + 3 * uDelta)*0.0776744219933;',&#13;
'gl_FragColor += texture2D(texture, vTexCoord + 4 * uDelta)*0.0443683338718;',&#13;
'gl_FragColor += texture2D(texture, vTexCoord + 5 * uDelta)*0.0215963866053;',&#13;
'gl_FragColor += texture2D(texture, vTexCoord + 6 * uDelta)*0.00895781211794;',&#13;
'gl_FragColor += texture2D(texture, vTexCoord + 7 * uDelta)*0.0044299121055113265;',&#13;
*/&#13;
&#13;
    /* eslint-disable max-len */&#13;
    fragmentSource: 'precision highp float;\n' +&#13;
      'uniform sampler2D uTexture;\n' +&#13;
      'uniform vec2 uDelta;\n' +&#13;
      'varying vec2 vTexCoord;\n' +&#13;
      'const float nSamples = 15.0;\n' +&#13;
      'vec3 v3offset = vec3(12.9898, 78.233, 151.7182);\n' +&#13;
      'float random(vec3 scale) {\n' +&#13;
        /* use the fragment position for a different seed per-pixel */&#13;
        'return fract(sin(dot(gl_FragCoord.xyz, scale)) * 43758.5453);\n' +&#13;
      '}\n' +&#13;
      'void main() {\n' +&#13;
        'vec4 color = vec4(0.0);\n' +&#13;
        'float total = 0.0;\n' +&#13;
        'float offset = random(v3offset);\n' +&#13;
        'for (float t = -nSamples; t &lt;= nSamples; t++) {\n' +&#13;
          'float percent = (t + offset - 0.5) / nSamples;\n' +&#13;
          'float weight = 1.0 - abs(percent);\n' +&#13;
          'color += texture2D(uTexture, vTexCoord + uDelta * percent) * weight;\n' +&#13;
          'total += weight;\n' +&#13;
        '}\n' +&#13;
        'gl_FragColor = color / total;\n' +&#13;
      '}',&#13;
    /* eslint-enable max-len */&#13;
&#13;
    /**&#13;
     * blur value, in percentage of image dimensions.&#13;
     * specific to keep the image blur constant at different resolutions&#13;
     * range bewteen 0 and 1.&#13;
     */&#13;
    blur: 0,&#13;
&#13;
    mainParameter: 'blur',&#13;
&#13;
    applyTo: function(options) {&#13;
      if (options.webgl) {&#13;
        // this aspectRatio is used to give the same blur to vertical and horizontal&#13;
        this.aspectRatio = options.sourceWidth / options.sourceHeight;&#13;
        options.passes++;&#13;
        this._setupFrameBuffer(options);&#13;
        this.horizontal = true;&#13;
        this.applyToWebGL(options);&#13;
        this._swapTextures(options);&#13;
        this._setupFrameBuffer(options);&#13;
        this.horizontal = false;&#13;
        this.applyToWebGL(options);&#13;
        this._swapTextures(options);&#13;
      }&#13;
      else {&#13;
        this.applyTo2d(options);&#13;
      }&#13;
    },&#13;
&#13;
    applyTo2d: function(options) {&#13;
      // paint canvasEl with current image data.&#13;
      //options.ctx.putImageData(options.imageData, 0, 0);&#13;
      options.imageData = this.simpleBlur(options);&#13;
    },&#13;
&#13;
    simpleBlur: function(options) {&#13;
      var resources = options.filterBackend.resources, canvas1, canvas2,&#13;
          width = options.imageData.width,&#13;
          height = options.imageData.height;&#13;
&#13;
      if (!resources.blurLayer1) {&#13;
        resources.blurLayer1 = document.createElement('canvas');&#13;
        resources.blurLayer2 = document.createElement('canvas');&#13;
      }&#13;
      canvas1 = resources.blurLayer1;&#13;
      canvas2 = resources.blurLayer2;&#13;
      if (canvas1.width !== width || canvas1.height !== height) {&#13;
        canvas2.width = canvas1.width = width;&#13;
        canvas2.height = canvas1.height = height;&#13;
      }&#13;
      var ctx1 = canvas1.getContext('2d'),&#13;
          ctx2 = canvas2.getContext('2d'),&#13;
          nSamples = 15,&#13;
          random, percent, j, i,&#13;
          blur = this.blur * 0.06 * 0.5;&#13;
&#13;
      // load first canvas&#13;
      ctx1.putImageData(options.imageData, 0, 0);&#13;
      ctx2.clearRect(0, 0, width, height);&#13;
&#13;
      for (i = -nSamples; i &lt;= nSamples; i++) {&#13;
        random = (Math.random() - 0.5) / 4;&#13;
        percent = i / nSamples;&#13;
        j = blur * percent * width + random;&#13;
        ctx2.globalAlpha = 1 - Math.abs(percent);&#13;
        ctx2.drawImage(canvas1, j, random);&#13;
        ctx1.drawImage(canvas2, 0, 0);&#13;
        ctx2.globalAlpha = 1;&#13;
        ctx2.clearRect(0, 0, canvas2.width, canvas2.height);&#13;
      }&#13;
      for (i = -nSamples; i &lt;= nSamples; i++) {&#13;
        random = (Math.random() - 0.5) / 4;&#13;
        percent = i / nSamples;&#13;
        j = blur * percent * height + random;&#13;
        ctx2.globalAlpha = 1 - Math.abs(percent);&#13;
        ctx2.drawImage(canvas1, random, j);&#13;
        ctx1.drawImage(canvas2, 0, 0);&#13;
        ctx2.globalAlpha = 1;&#13;
        ctx2.clearRect(0, 0, canvas2.width, canvas2.height);&#13;
      }&#13;
      options.ctx.drawImage(canvas1, 0, 0);&#13;
      var newImageData = options.ctx.getImageData(0, 0, canvas1.width, canvas1.height);&#13;
      ctx1.globalAlpha = 1;&#13;
      ctx1.clearRect(0, 0, canvas1.width, canvas1.height);&#13;
      return newImageData;&#13;
    },&#13;
&#13;
    /**&#13;
     * Return WebGL uniform locations for this filter's shader.&#13;
     *&#13;
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.&#13;
     * @param {WebGLShaderProgram} program This filter's compiled shader program.&#13;
     */&#13;
    getUniformLocations: function(gl, program) {&#13;
      return {&#13;
        delta: gl.getUniformLocation(program, 'uDelta'),&#13;
      };&#13;
    },&#13;
&#13;
    /**&#13;
     * Send data from this filter to its shader program's uniforms.&#13;
     *&#13;
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.&#13;
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects&#13;
     */&#13;
    sendUniformData: function(gl, uniformLocations) {&#13;
      var delta = this.chooseRightDelta();&#13;
      gl.uniform2fv(uniformLocations.delta, delta);&#13;
    },&#13;
&#13;
    /**&#13;
     * choose right value of image percentage to blur with&#13;
     * @returns {Array} a numeric array with delta values&#13;
     */&#13;
    chooseRightDelta: function() {&#13;
      var blurScale = 1, delta = [0, 0], blur;&#13;
      if (this.horizontal) {&#13;
        if (this.aspectRatio &gt; 1) {&#13;
          // image is wide, i want to shrink radius horizontal&#13;
          blurScale = 1 / this.aspectRatio;&#13;
        }&#13;
      }&#13;
      else {&#13;
        if (this.aspectRatio &lt; 1) {&#13;
          // image is tall, i want to shrink radius vertical&#13;
          blurScale = this.aspectRatio;&#13;
        }&#13;
      }&#13;
      blur = blurScale * this.blur * 0.12;&#13;
      if (this.horizontal) {&#13;
        delta[0] = blur;&#13;
      }&#13;
      else {&#13;
        delta[1] = blur;&#13;
      }&#13;
      return delta;&#13;
    },&#13;
  });&#13;
&#13;
  /**&#13;
   * Deserialize a JSON definition of a BlurFilter into a concrete instance.&#13;
   */&#13;
  filters.Blur.fromObject = fabric.Image.filters.BaseFilter.fromObject;&#13;
&#13;
})(typeof exports !== 'undefined' ? exports : this);&#13;
&#13;
&#13;
(function(global) {&#13;
&#13;
  'use strict';&#13;
&#13;
  var fabric  = global.fabric || (global.fabric = { }),&#13;
      filters = fabric.Image.filters,&#13;
      createClass = fabric.util.createClass;&#13;
&#13;
  /**&#13;
   * Gamma filter class&#13;
   * @class fabric.Image.filters.Gamma&#13;
   * @memberOf fabric.Image.filters&#13;
   * @extends fabric.Image.filters.BaseFilter&#13;
   * @see {@link fabric.Image.filters.Gamma#initialize} for constructor definition&#13;
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}&#13;
   * @example&#13;
   * var filter = new fabric.Image.filters.Gamma({&#13;
   *   brightness: 200&#13;
   * });&#13;
   * object.filters.push(filter);&#13;
   * object.applyFilters();&#13;
   */&#13;
  filters.Gamma = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Gamma.prototype */ {&#13;
&#13;
    /**&#13;
     * Filter type&#13;
     * @param {String} type&#13;
     * @default&#13;
     */&#13;
    type: 'Gamma',&#13;
&#13;
    fragmentSource: 'precision highp float;\n' +&#13;
      'uniform sampler2D uTexture;\n' +&#13;
      'uniform vec3 uGamma;\n' +&#13;
      'varying vec2 vTexCoord;\n' +&#13;
      'void main() {\n' +&#13;
        'vec4 color = texture2D(uTexture, vTexCoord);\n' +&#13;
        'vec3 correction = (1.0 / uGamma);\n' +&#13;
        'color.r = pow(color.r, correction.r);\n' +&#13;
        'color.g = pow(color.g, correction.g);\n' +&#13;
        'color.b = pow(color.b, correction.b);\n' +&#13;
        'gl_FragColor = color;\n' +&#13;
        'gl_FragColor.rgb *= color.a;\n' +&#13;
      '}',&#13;
&#13;
    /**&#13;
     * Gamma array value, from 0.01 to 2.2.&#13;
     * @param {Array} gamma&#13;
     * @default&#13;
     */&#13;
    gamma: [1, 1, 1],&#13;
&#13;
    /**&#13;
     * Describe the property that is the filter parameter&#13;
     * @param {String} m&#13;
     * @default&#13;
     */&#13;
    mainParameter: 'gamma',&#13;
&#13;
    /**&#13;
     * Apply the Gamma operation to a Uint8Array representing the pixels of an image.&#13;
     *&#13;
     * @param {Object} options&#13;
     * @param {ImageData} options.imageData The Uint8Array to be filtered.&#13;
     */&#13;
    applyTo2d: function(options) {&#13;
      var imageData = options.imageData, data = imageData.data,&#13;
          gamma = this.gamma, len = data.length,&#13;
          rInv = 1 / gamma[0], gInv = 1 / gamma[1],&#13;
          bInv = 1 / gamma[2], i;&#13;
&#13;
      if (!this.rVals) {&#13;
        // eslint-disable-next-line&#13;
        this.rVals = new Uint8Array(256);&#13;
        // eslint-disable-next-line&#13;
        this.gVals = new Uint8Array(256);&#13;
        // eslint-disable-next-line&#13;
        this.bVals = new Uint8Array(256);&#13;
      }&#13;
&#13;
      // This is an optimization - pre-compute a look-up table for each color channel&#13;
      // instead of performing these pow calls for each pixel in the image.&#13;
      for (i = 0, len = 256; i &lt; len; i++) {&#13;
        this.rVals[i] = Math.pow(i / 255, rInv) * 255;&#13;
        this.gVals[i] = Math.pow(i / 255, gInv) * 255;&#13;
        this.bVals[i] = Math.pow(i / 255, bInv) * 255;&#13;
      }&#13;
      for (i = 0, len = data.length; i &lt; len; i += 4) {&#13;
        data[i] = this.rVals[data[i]];&#13;
        data[i + 1] = this.gVals[data[i + 1]];&#13;
        data[i + 2] = this.bVals[data[i + 2]];&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Return WebGL uniform locations for this filter's shader.&#13;
     *&#13;
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.&#13;
     * @param {WebGLShaderProgram} program This filter's compiled shader program.&#13;
     */&#13;
    getUniformLocations: function(gl, program) {&#13;
      return {&#13;
        uGamma: gl.getUniformLocation(program, 'uGamma'),&#13;
      };&#13;
    },&#13;
&#13;
    /**&#13;
     * Send data from this filter to its shader program's uniforms.&#13;
     *&#13;
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.&#13;
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects&#13;
     */&#13;
    sendUniformData: function(gl, uniformLocations) {&#13;
      gl.uniform3fv(uniformLocations.uGamma, this.gamma);&#13;
    },&#13;
  });&#13;
&#13;
  /**&#13;
   * Returns filter instance from an object representation&#13;
   * @static&#13;
   * @param {Object} object Object to create an instance from&#13;
   * @param {function} [callback] to be invoked after filter creation&#13;
   * @return {fabric.Image.filters.Gamma} Instance of fabric.Image.filters.Gamma&#13;
   */&#13;
  fabric.Image.filters.Gamma.fromObject = fabric.Image.filters.BaseFilter.fromObject;&#13;
&#13;
})(typeof exports !== 'undefined' ? exports : this);&#13;
&#13;
&#13;
(function(global) {&#13;
&#13;
  'use strict';&#13;
&#13;
  var fabric  = global.fabric || (global.fabric = { }),&#13;
      filters = fabric.Image.filters,&#13;
      createClass = fabric.util.createClass;&#13;
&#13;
  /**&#13;
   * A container class that knows how to apply a sequence of filters to an input image.&#13;
   */&#13;
  filters.Composed = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Composed.prototype */ {&#13;
&#13;
    type: 'Composed',&#13;
&#13;
    /**&#13;
     * A non sparse array of filters to apply&#13;
     */&#13;
    subFilters: [],&#13;
&#13;
    /**&#13;
     * Constructor&#13;
     * @param {Object} [options] Options object&#13;
     */&#13;
    initialize: function(options) {&#13;
      this.callSuper('initialize', options);&#13;
      // create a new array instead mutating the prototype with push&#13;
      this.subFilters = this.subFilters.slice(0);&#13;
    },&#13;
&#13;
    /**&#13;
     * Apply this container's filters to the input image provided.&#13;
     *&#13;
     * @param {Object} options&#13;
     * @param {Number} options.passes The number of filters remaining to be applied.&#13;
     */&#13;
    applyTo: function(options) {&#13;
      options.passes += this.subFilters.length - 1;&#13;
      this.subFilters.forEach(function(filter) {&#13;
        filter.applyTo(options);&#13;
      });&#13;
    },&#13;
&#13;
    /**&#13;
     * Serialize this filter into JSON.&#13;
     *&#13;
     * @returns {Object} A JSON representation of this filter.&#13;
     */&#13;
    toObject: function() {&#13;
      return fabric.util.object.extend(this.callSuper('toObject'), {&#13;
        subFilters: this.subFilters.map(function(filter) { return filter.toObject(); }),&#13;
      });&#13;
    },&#13;
  });&#13;
&#13;
  /**&#13;
   * Deserialize a JSON definition of a ComposedFilter into a concrete instance.&#13;
   */&#13;
  fabric.Image.filters.Composed.fromObject = function(object, callback) {&#13;
    var filters = object.subFilters || [],&#13;
        subFilters = filters.map(function(filter) {&#13;
          return new fabric.Image.filters[filter.type](filter);&#13;
        }),&#13;
        instance = new fabric.Image.filters.Composed({ subFilters: subFilters });&#13;
    callback &amp;&amp; callback(instance);&#13;
    return instance;&#13;
  };&#13;
})(typeof exports !== 'undefined' ? exports : this);&#13;
&#13;
&#13;
(function(global) {&#13;
&#13;
  'use strict';&#13;
&#13;
  var fabric  = global.fabric || (global.fabric = { }),&#13;
      filters = fabric.Image.filters,&#13;
      createClass = fabric.util.createClass;&#13;
&#13;
  /**&#13;
   * HueRotation filter class&#13;
   * @class fabric.Image.filters.HueRotation&#13;
   * @memberOf fabric.Image.filters&#13;
   * @extends fabric.Image.filters.BaseFilter&#13;
   * @see {@link fabric.Image.filters.HueRotation#initialize} for constructor definition&#13;
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}&#13;
   * @example&#13;
   * var filter = new fabric.Image.filters.HueRotation({&#13;
   *   rotation: -0.5&#13;
   * });&#13;
   * object.filters.push(filter);&#13;
   * object.applyFilters();&#13;
   */&#13;
  filters.HueRotation = createClass(filters.ColorMatrix, /** @lends fabric.Image.filters.HueRotation.prototype */ {&#13;
&#13;
    /**&#13;
     * Filter type&#13;
     * @param {String} type&#13;
     * @default&#13;
     */&#13;
    type: 'HueRotation',&#13;
&#13;
    /**&#13;
     * HueRotation value, from -1 to 1.&#13;
     * the unit is radians&#13;
     * @param {Number} myParameter&#13;
     * @default&#13;
     */&#13;
    rotation: 0,&#13;
&#13;
    /**&#13;
     * Describe the property that is the filter parameter&#13;
     * @param {String} m&#13;
     * @default&#13;
     */&#13;
    mainParameter: 'rotation',&#13;
&#13;
    calculateMatrix: function() {&#13;
      var rad = this.rotation * Math.PI, cos = Math.cos(rad), sin = Math.sin(rad),&#13;
          aThird = 1 / 3, aThirdSqtSin = Math.sqrt(aThird) * sin, OneMinusCos = 1 - cos;&#13;
      this.matrix = [&#13;
        1, 0, 0, 0, 0,&#13;
        0, 1, 0, 0, 0,&#13;
        0, 0, 1, 0, 0,&#13;
        0, 0, 0, 1, 0&#13;
      ];&#13;
      this.matrix[0] = cos + OneMinusCos / 3;&#13;
      this.matrix[1] = aThird * OneMinusCos - aThirdSqtSin;&#13;
      this.matrix[2] = aThird * OneMinusCos + aThirdSqtSin;&#13;
      this.matrix[5] = aThird * OneMinusCos + aThirdSqtSin;&#13;
      this.matrix[6] = cos + aThird * OneMinusCos;&#13;
      this.matrix[7] = aThird * OneMinusCos - aThirdSqtSin;&#13;
      this.matrix[10] = aThird * OneMinusCos - aThirdSqtSin;&#13;
      this.matrix[11] = aThird * OneMinusCos + aThirdSqtSin;&#13;
      this.matrix[12] = cos + aThird * OneMinusCos;&#13;
    },&#13;
&#13;
    /**&#13;
     * Apply this filter to the input image data provided.&#13;
     *&#13;
     * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.&#13;
     *&#13;
     * @param {Object} options&#13;
     * @param {Number} options.passes The number of filters remaining to be executed&#13;
     * @param {Boolean} options.webgl Whether to use webgl to render the filter.&#13;
     * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.&#13;
     * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.&#13;
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.&#13;
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.&#13;
     */&#13;
    applyTo: function(options) {&#13;
      this.calculateMatrix();&#13;
      fabric.Image.filters.BaseFilter.prototype.applyTo.call(this, options);&#13;
    },&#13;
&#13;
  });&#13;
&#13;
  /**&#13;
   * Returns filter instance from an object representation&#13;
   * @static&#13;
   * @param {Object} object Object to create an instance from&#13;
   * @param {function} [callback] to be invoked after filter creation&#13;
   * @return {fabric.Image.filters.HueRotation} Instance of fabric.Image.filters.HueRotation&#13;
   */&#13;
  fabric.Image.filters.HueRotation.fromObject = fabric.Image.filters.BaseFilter.fromObject;&#13;
&#13;
})(typeof exports !== 'undefined' ? exports : this);&#13;
&#13;
&#13;
(function(global) {&#13;
&#13;
  'use strict';&#13;
&#13;
  var fabric = global.fabric || (global.fabric = { }),&#13;
      clone = fabric.util.object.clone,&#13;
      MIN_TEXT_WIDTH = 2,&#13;
      CACHE_FONT_SIZE = 200;&#13;
&#13;
  if (fabric.Text) {&#13;
    fabric.warn('fabric.Text is already defined');&#13;
    return;&#13;
  }&#13;
&#13;
  /**&#13;
   * Text class&#13;
   * @class fabric.Text&#13;
   * @extends fabric.Object&#13;
   * @return {fabric.Text} thisArg&#13;
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#text}&#13;
   * @see {@link fabric.Text#initialize} for constructor definition&#13;
   */&#13;
  fabric.Text = fabric.util.createClass(fabric.Object, /** @lends fabric.Text.prototype */ {&#13;
&#13;
    /**&#13;
     * Properties which when set cause object to change dimensions&#13;
     * @type Object&#13;
     * @private&#13;
     */&#13;
    _dimensionAffectingProps: [&#13;
      'fontSize',&#13;
      'fontWeight',&#13;
      'fontFamily',&#13;
      'fontStyle',&#13;
      'lineHeight',&#13;
      'text',&#13;
      'charSpacing',&#13;
      'textAlign',&#13;
      'styles',&#13;
    ],&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _reNewline: /\r?\n/,&#13;
&#13;
    /**&#13;
     * Use this regular expression to filter for whitespaces that is not a new line.&#13;
     * Mostly used when text is 'justify' aligned.&#13;
     * @private&#13;
     */&#13;
    _reSpacesAndTabs: /[ \t\r]/g,&#13;
&#13;
    /**&#13;
     * Use this regular expression to filter for whitespace that is not a new line.&#13;
     * Mostly used when text is 'justify' aligned.&#13;
     * @private&#13;
     */&#13;
    _reSpaceAndTab: /[ \t\r]/,&#13;
&#13;
    /**&#13;
     * Use this regular expression to filter consecutive groups of non spaces.&#13;
     * Mostly used when text is 'justify' aligned.&#13;
     * @private&#13;
     */&#13;
    _reWords: /\S+/g,&#13;
&#13;
    /**&#13;
     * Type of an object&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    type:                 'text',&#13;
&#13;
    /**&#13;
     * Font size (in pixels)&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    fontSize:             40,&#13;
&#13;
    /**&#13;
     * Font weight (e.g. bold, normal, 400, 600, 800)&#13;
     * @type {(Number|String)}&#13;
     * @default&#13;
     */&#13;
    fontWeight:           'normal',&#13;
&#13;
    /**&#13;
     * Font family&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    fontFamily:           'Times New Roman',&#13;
&#13;
    /**&#13;
     * Text decoration underline.&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    underline:       false,&#13;
&#13;
    /**&#13;
     * Text decoration overline.&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    overline:       false,&#13;
&#13;
    /**&#13;
     * Text decoration linethrough.&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    linethrough:       false,&#13;
&#13;
    /**&#13;
     * Text alignment. Possible values: "left", "center", "right", "justify",&#13;
     * "justify-left", "justify-center" or "justify-right".&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    textAlign:            'left',&#13;
&#13;
    /**&#13;
     * Font style . Possible values: "", "normal", "italic" or "oblique".&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    fontStyle:            'normal',&#13;
&#13;
    /**&#13;
     * Line height&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    lineHeight:           1.16,&#13;
&#13;
    /**&#13;
     * Background color of text lines&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    textBackgroundColor:  '',&#13;
&#13;
    /**&#13;
     * List of properties to consider when checking if&#13;
     * state of an object is changed ({@link fabric.Object#hasStateChanged})&#13;
     * as well as for history (undo/redo) purposes&#13;
     * @type Array&#13;
     */&#13;
    stateProperties: fabric.Object.prototype.stateProperties.concat('fontFamily',&#13;
      'fontWeight',&#13;
      'fontSize',&#13;
      'text',&#13;
      'underline',&#13;
      'overline',&#13;
      'linethrough',&#13;
      'textAlign',&#13;
      'fontStyle',&#13;
      'lineHeight',&#13;
      'textBackgroundColor',&#13;
      'charSpacing',&#13;
      'styles'),&#13;
&#13;
    /**&#13;
     * List of properties to consider when checking if cache needs refresh&#13;
     * @type Array&#13;
     */&#13;
    cacheProperties: fabric.Object.prototype.cacheProperties.concat('fontFamily',&#13;
      'fontWeight',&#13;
      'fontSize',&#13;
      'text',&#13;
      'underline',&#13;
      'overline',&#13;
      'linethrough',&#13;
      'textAlign',&#13;
      'fontStyle',&#13;
      'lineHeight',&#13;
      'textBackgroundColor',&#13;
      'charSpacing',&#13;
      'styles'),&#13;
&#13;
    /**&#13;
     * When defined, an object is rendered via stroke and this property specifies its color.&#13;
     * &lt;b&gt;Backwards incompatibility note:&lt;/b&gt; This property was named "strokeStyle" until v1.1.6&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    stroke:               null,&#13;
&#13;
    /**&#13;
     * Shadow object representing shadow of this shape.&#13;
     * &lt;b&gt;Backwards incompatibility note:&lt;/b&gt; This property was named "textShadow" (String) until v1.2.11&#13;
     * @type fabric.Shadow&#13;
     * @default&#13;
     */&#13;
    shadow:               null,&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _fontSizeFraction: 0.222,&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    offsets: {&#13;
      underline: 0.10,&#13;
      linethrough: -0.315,&#13;
      overline: -0.88&#13;
    },&#13;
&#13;
    /**&#13;
     * Text Line proportion to font Size (in pixels)&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    _fontSizeMult:             1.13,&#13;
&#13;
    /**&#13;
     * additional space between characters&#13;
     * expressed in thousands of em unit&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    charSpacing:             0,&#13;
&#13;
    /**&#13;
     * Object containing character styles&#13;
     * (where top-level properties corresponds to line number and 2nd-level properties -- to char number in a line)&#13;
     * @type Object&#13;
     * @default&#13;
     */&#13;
    styles: null,&#13;
&#13;
    /**&#13;
     * Reference to a context to measure text char or couple of chars&#13;
     * the cacheContext of the canvas will be used or a freshly created one if the object is not on canvas&#13;
     * once created it will be referenced on fabric._measuringContext to avoide creating a canvas for every&#13;
     * text object created.&#13;
     * @type {CanvasRenderingContext2D}&#13;
     * @default&#13;
     */&#13;
    _measuringContext: null,&#13;
&#13;
    /**&#13;
     * Array of properties that define a style unit.&#13;
     * @type {Array}&#13;
     * @default&#13;
     */&#13;
    _styleProperties: [&#13;
      'stroke',&#13;
      'strokeWidth',&#13;
      'fill',&#13;
      'fontFamily',&#13;
      'fontSize',&#13;
      'fontWeight',&#13;
      'fontStyle',&#13;
      'underline',&#13;
      'overline',&#13;
      'linethrough',&#13;
      'textBackgroundColor',&#13;
    ],&#13;
&#13;
    /**&#13;
     * contains characters bounding boxes&#13;
     */&#13;
    __charBounds: [],&#13;
&#13;
    /**&#13;
     * Constructor&#13;
     * @param {String} text Text string&#13;
     * @param {Object} [options] Options object&#13;
     * @return {fabric.Text} thisArg&#13;
     */&#13;
    initialize: function(text, options) {&#13;
      this.styles = options ? (options.styles || { }) : { };&#13;
      this.text = text;&#13;
      this.__skipDimension = true;&#13;
      this.callSuper('initialize', options);&#13;
      this.__skipDimension = false;&#13;
      this.initDimensions();&#13;
      this.setCoords();&#13;
      this.setupState({ propertySet: '_dimensionAffectingProps' });&#13;
    },&#13;
&#13;
    /**&#13;
     * Return a contex for measurement of text string.&#13;
     * if created it gets stored for reuse&#13;
     * @param {String} text Text string&#13;
     * @param {Object} [options] Options object&#13;
     * @return {fabric.Text} thisArg&#13;
     */&#13;
    getMeasuringContext: function() {&#13;
      // if we did not return we have to measure something.&#13;
      if (!fabric._measuringContext) {&#13;
        fabric._measuringContext = this.canvas &amp;&amp; this.canvas.contextCache ||&#13;
          fabric.util.createCanvasElement().getContext('2d');&#13;
      }&#13;
      return fabric._measuringContext;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * Divides text into lines of text and lines of graphemes.&#13;
     */&#13;
    _splitText: function() {&#13;
      var newLines = this._splitTextIntoLines(this.text);&#13;
      this.textLines = newLines.lines;&#13;
      this._textLines = newLines.graphemeLines;&#13;
      this._unwrappedTextLines = newLines._unwrappedLines;&#13;
      this._text = newLines.graphemeText;&#13;
      return newLines;&#13;
    },&#13;
&#13;
    /**&#13;
     * Initialize or update text dimensions.&#13;
     * Updates this.width and this.height with the proper values.&#13;
     * Does not return dimensions.&#13;
     */&#13;
    initDimensions: function() {&#13;
      if (this.__skipDimension) {&#13;
        return;&#13;
      }&#13;
      this._splitText();&#13;
      this._clearCache();&#13;
      this.width = this.calcTextWidth() || this.cursorWidth || MIN_TEXT_WIDTH;&#13;
      if (this.textAlign.indexOf('justify') !== -1) {&#13;
        // once text is measured we need to make space fatter to make justified text.&#13;
        this.enlargeSpaces();&#13;
      }&#13;
      this.height = this.calcTextHeight();&#13;
      this.saveState({ propertySet: '_dimensionAffectingProps' });&#13;
    },&#13;
&#13;
    /**&#13;
     * Enlarge space boxes and shift the others&#13;
     */&#13;
    enlargeSpaces: function() {&#13;
      var diffSpace, currentLineWidth, numberOfSpaces, accumulatedSpace, line, charBound, spaces;&#13;
      for (var i = 0, len = this._textLines.length; i &lt; len; i++) {&#13;
        if (this.textAlign !== 'justify' &amp;&amp; (i === len - 1 || this.isEndOfWrapping(i))) {&#13;
          continue;&#13;
        }&#13;
        accumulatedSpace = 0;&#13;
        line = this._textLines[i];&#13;
        currentLineWidth = this.getLineWidth(i);&#13;
        if (currentLineWidth &lt; this.width &amp;&amp; (spaces = this.textLines[i].match(this._reSpacesAndTabs))) {&#13;
          numberOfSpaces = spaces.length;&#13;
          diffSpace = (this.width - currentLineWidth) / numberOfSpaces;&#13;
          for (var j = 0, jlen = line.length; j &lt;= jlen; j++) {&#13;
            charBound = this.__charBounds[i][j];&#13;
            if (this._reSpaceAndTab.test(line[j])) {&#13;
              charBound.width += diffSpace;&#13;
              charBound.kernedWidth += diffSpace;&#13;
              charBound.left += accumulatedSpace;&#13;
              accumulatedSpace += diffSpace;&#13;
            }&#13;
            else {&#13;
              charBound.left += accumulatedSpace;&#13;
            }&#13;
          }&#13;
        }&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Detect if the text line is ended with an hard break&#13;
     * text and itext do not have wrapping, return false&#13;
     * @return {Boolean}&#13;
     */&#13;
    isEndOfWrapping: function(lineIndex) {&#13;
      return lineIndex === this._textLines.length - 1;&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns string representation of an instance&#13;
     * @return {String} String representation of text object&#13;
     */&#13;
    toString: function() {&#13;
      return '#&lt;fabric.Text (' + this.complexity() +&#13;
        '): { "text": "' + this.text + '", "fontFamily": "' + this.fontFamily + '" }&gt;';&#13;
    },&#13;
&#13;
    /**&#13;
     * Return the dimension and the zoom level needed to create a cache canvas&#13;
     * big enough to host the object to be cached.&#13;
     * @private&#13;
     * @param {Object} dim.x width of object to be cached&#13;
     * @param {Object} dim.y height of object to be cached&#13;
     * @return {Object}.width width of canvas&#13;
     * @return {Object}.height height of canvas&#13;
     * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache&#13;
     * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache&#13;
     */&#13;
    _getCacheCanvasDimensions: function() {&#13;
      var dims = this.callSuper('_getCacheCanvasDimensions');&#13;
      var fontSize = this.fontSize;&#13;
      dims.width += fontSize * dims.zoomX;&#13;
      dims.height += fontSize * dims.zoomY;&#13;
      return dims;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     */&#13;
    _render: function(ctx) {&#13;
      this._setTextStyles(ctx);&#13;
      this._renderTextLinesBackground(ctx);&#13;
      this._renderTextDecoration(ctx, 'underline');&#13;
      this._renderText(ctx);&#13;
      this._renderTextDecoration(ctx, 'overline');&#13;
      this._renderTextDecoration(ctx, 'linethrough');&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     */&#13;
    _renderText: function(ctx) {&#13;
      if (this.paintFirst === 'stroke') {&#13;
        this._renderTextStroke(ctx);&#13;
        this._renderTextFill(ctx);&#13;
      }&#13;
      else {&#13;
        this._renderTextFill(ctx);&#13;
        this._renderTextStroke(ctx);&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Set the font parameter of the context with the object properties or with charStyle&#13;
     * @private&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     * @param {Object} [charStyle] object with font style properties&#13;
     * @param {String} [charStyle.fontFamily] Font Family&#13;
     * @param {Number} [charStyle.fontSize] Font size in pixels. ( without px suffix )&#13;
     * @param {String} [charStyle.fontWeight] Font weight&#13;
     * @param {String} [charStyle.fontStyle] Font style (italic|normal)&#13;
     */&#13;
    _setTextStyles: function(ctx, charStyle, forMeasuring) {&#13;
      ctx.textBaseline = 'alphabetic';&#13;
      ctx.font = this._getFontDeclaration(charStyle, forMeasuring);&#13;
    },&#13;
&#13;
    /**&#13;
     * calculate and return the text Width measuring each line.&#13;
     * @private&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     * @return {Number} Maximum width of fabric.Text object&#13;
     */&#13;
    calcTextWidth: function() {&#13;
      var maxWidth = this.getLineWidth(0);&#13;
&#13;
      for (var i = 1, len = this._textLines.length; i &lt; len; i++) {&#13;
        var currentLineWidth = this.getLineWidth(i);&#13;
        if (currentLineWidth &gt; maxWidth) {&#13;
          maxWidth = currentLineWidth;&#13;
        }&#13;
      }&#13;
      return maxWidth;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {String} method Method name ("fillText" or "strokeText")&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     * @param {String} line Text to render&#13;
     * @param {Number} left Left position of text&#13;
     * @param {Number} top Top position of text&#13;
     * @param {Number} lineIndex Index of a line in a text&#13;
     */&#13;
    _renderTextLine: function(method, ctx, line, left, top, lineIndex) {&#13;
      this._renderChars(method, ctx, line, left, top, lineIndex);&#13;
    },&#13;
&#13;
    /**&#13;
     * Renders the text background for lines, taking care of style&#13;
     * @private&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     */&#13;
    _renderTextLinesBackground: function(ctx) {&#13;
      if (!this.textBackgroundColor &amp;&amp; !this.styleHas('textBackgroundColor')) {&#13;
        return;&#13;
      }&#13;
      var lineTopOffset = 0, heightOfLine,&#13;
          lineLeftOffset, originalFill = ctx.fillStyle,&#13;
          line, lastColor,&#13;
          leftOffset = this._getLeftOffset(),&#13;
          topOffset = this._getTopOffset(),&#13;
          boxStart = 0, boxWidth = 0, charBox, currentColor;&#13;
&#13;
      for (var i = 0, len = this._textLines.length; i &lt; len; i++) {&#13;
        heightOfLine = this.getHeightOfLine(i);&#13;
        if (!this.textBackgroundColor &amp;&amp; !this.styleHas('textBackgroundColor', i)) {&#13;
          lineTopOffset += heightOfLine;&#13;
          continue;&#13;
        }&#13;
        line = this._textLines[i];&#13;
        lineLeftOffset = this._getLineLeftOffset(i);&#13;
        boxWidth = 0;&#13;
        boxStart = 0;&#13;
        lastColor = this.getValueOfPropertyAt(i, 0, 'textBackgroundColor');&#13;
        for (var j = 0, jlen = line.length; j &lt; jlen; j++) {&#13;
          charBox = this.__charBounds[i][j];&#13;
          currentColor = this.getValueOfPropertyAt(i, j, 'textBackgroundColor');&#13;
          if (currentColor !== lastColor) {&#13;
            ctx.fillStyle = lastColor;&#13;
            lastColor &amp;&amp; ctx.fillRect(&#13;
              leftOffset + lineLeftOffset + boxStart,&#13;
              topOffset + lineTopOffset,&#13;
              boxWidth,&#13;
              heightOfLine / this.lineHeight&#13;
            );&#13;
            boxStart = charBox.left;&#13;
            boxWidth = charBox.width;&#13;
            lastColor = currentColor;&#13;
          }&#13;
          else {&#13;
            boxWidth += charBox.kernedWidth;&#13;
          }&#13;
        }&#13;
        if (currentColor) {&#13;
          ctx.fillStyle = currentColor;&#13;
          ctx.fillRect(&#13;
            leftOffset + lineLeftOffset + boxStart,&#13;
            topOffset + lineTopOffset,&#13;
            boxWidth,&#13;
            heightOfLine / this.lineHeight&#13;
          );&#13;
        }&#13;
        lineTopOffset += heightOfLine;&#13;
      }&#13;
      ctx.fillStyle = originalFill;&#13;
      // if there is text background color no&#13;
      // other shadows should be casted&#13;
      this._removeShadow(ctx);&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Object} decl style declaration for cache&#13;
     * @param {String} decl.fontFamily fontFamily&#13;
     * @param {String} decl.fontStyle fontStyle&#13;
     * @param {String} decl.fontWeight fontWeight&#13;
     * @return {Object} reference to cache&#13;
     */&#13;
    getFontCache: function(decl) {&#13;
      var fontFamily = decl.fontFamily.toLowerCase();&#13;
      if (!fabric.charWidthsCache[fontFamily]) {&#13;
        fabric.charWidthsCache[fontFamily] = { };&#13;
      }&#13;
      var cache = fabric.charWidthsCache[fontFamily],&#13;
          cacheProp = decl.fontStyle.toLowerCase() + '_' + (decl.fontWeight + '').toLowerCase();&#13;
      if (!cache[cacheProp]) {&#13;
        cache[cacheProp] = { };&#13;
      }&#13;
      return cache[cacheProp];&#13;
    },&#13;
&#13;
    /**&#13;
     * apply all the character style to canvas for rendering&#13;
     * @private&#13;
     * @param {String} _char&#13;
     * @param {Number} lineIndex&#13;
     * @param {Number} charIndex&#13;
     * @param {Object} [decl]&#13;
     */&#13;
    _applyCharStyles: function(method, ctx, lineIndex, charIndex, styleDeclaration) {&#13;
&#13;
      this._setFillStyles(ctx, styleDeclaration);&#13;
      this._setStrokeStyles(ctx, styleDeclaration);&#13;
&#13;
      ctx.font = this._getFontDeclaration(styleDeclaration);&#13;
    },&#13;
&#13;
    /**&#13;
     * measure and return the width of a single character.&#13;
     * possibly overridden to accommodate different measure logic or&#13;
     * to hook some external lib for character measurement&#13;
     * @private&#13;
     * @param {String} char to be measured&#13;
     * @param {Object} charStyle style of char to be measured&#13;
     * @param {String} [previousChar] previous char&#13;
     * @param {Object} [prevCharStyle] style of previous char&#13;
     */&#13;
    _measureChar: function(_char, charStyle, previousChar, prevCharStyle) {&#13;
      // first i try to return from cache&#13;
      var fontCache = this.getFontCache(charStyle), fontDeclaration = this._getFontDeclaration(charStyle),&#13;
          previousFontDeclaration = this._getFontDeclaration(prevCharStyle), couple = previousChar + _char,&#13;
          stylesAreEqual = fontDeclaration === previousFontDeclaration, width, coupleWidth, previousWidth,&#13;
          fontMultiplier = charStyle.fontSize / CACHE_FONT_SIZE, kernedWidth;&#13;
&#13;
      if (previousChar &amp;&amp; fontCache[previousChar]) {&#13;
        previousWidth = fontCache[previousChar];&#13;
      }&#13;
      if (fontCache[_char]) {&#13;
        kernedWidth = width = fontCache[_char];&#13;
      }&#13;
      if (stylesAreEqual &amp;&amp; fontCache[couple]) {&#13;
        coupleWidth = fontCache[couple];&#13;
        kernedWidth = coupleWidth - previousWidth;&#13;
      }&#13;
      if (!width || !previousWidth || !coupleWidth) {&#13;
        var ctx = this.getMeasuringContext();&#13;
        // send a TRUE to specify measuring font size CACHE_FONT_SIZE&#13;
        this._setTextStyles(ctx, charStyle, true);&#13;
      }&#13;
      if (!width) {&#13;
        kernedWidth = width = ctx.measureText(_char).width;&#13;
        fontCache[_char] = width;&#13;
      }&#13;
      if (!previousWidth &amp;&amp; stylesAreEqual &amp;&amp; previousChar) {&#13;
        previousWidth = ctx.measureText(previousChar).width;&#13;
        fontCache[previousChar] = previousWidth;&#13;
      }&#13;
      if (stylesAreEqual &amp;&amp; !coupleWidth) {&#13;
        // we can measure the kerning couple and subtract the width of the previous character&#13;
        coupleWidth = ctx.measureText(couple).width;&#13;
        fontCache[couple] = coupleWidth;&#13;
        kernedWidth = coupleWidth - previousWidth;&#13;
        // try to fix a MS browsers oddity&#13;
        if (kernedWidth &gt; width) {&#13;
          var diff = kernedWidth - width;&#13;
          fontCache[_char] = kernedWidth;&#13;
          fontCache[couple] += diff;&#13;
          width = kernedWidth;&#13;
        }&#13;
      }&#13;
      return { width: width * fontMultiplier, kernedWidth: kernedWidth * fontMultiplier };&#13;
    },&#13;
&#13;
    /**&#13;
     * return height of char in fontSize for a character at lineIndex, charIndex&#13;
     * @param {Number} l line Index&#13;
     * @param {Number} c char index&#13;
     * @return {Number} fontSize of that character&#13;
     */&#13;
    getHeightOfChar: function(l, c) {&#13;
      return this.getValueOfPropertyAt(l, c, 'fontSize');&#13;
    },&#13;
&#13;
    /**&#13;
     * measure a text line measuring all characters.&#13;
     * @param {Number} lineIndex line number&#13;
     * @return {Number} Line width&#13;
     */&#13;
    measureLine: function(lineIndex) {&#13;
      var lineInfo = this._measureLine(lineIndex);&#13;
      if (this.charSpacing !== 0) {&#13;
        lineInfo.width -= this._getWidthOfCharSpacing();&#13;
      }&#13;
      if (lineInfo.width &lt; 0) {&#13;
        lineInfo.width = 0;&#13;
      }&#13;
      return lineInfo;&#13;
    },&#13;
&#13;
    /**&#13;
     * measure every grapheme of a line, populating __charBounds&#13;
     * @param {Number} lineIndex&#13;
     * @return {Object} object.width total width of characters&#13;
     * @return {Object} object.widthOfSpaces length of chars that match this._reSpacesAndTabs&#13;
     */&#13;
    _measureLine: function(lineIndex) {&#13;
      var width = 0, i, grapheme, line = this._textLines[lineIndex], prevGrapheme,&#13;
          graphemeInfo, numOfSpaces = 0, lineBounds = new Array(line.length);&#13;
&#13;
      this.__charBounds[lineIndex] = lineBounds;&#13;
      for (i = 0; i &lt; line.length; i++) {&#13;
        grapheme = line[i];&#13;
        graphemeInfo = this._getGraphemeBox(grapheme, lineIndex, i, prevGrapheme);&#13;
        lineBounds[i] = graphemeInfo;&#13;
        width += graphemeInfo.kernedWidth;&#13;
        prevGrapheme = grapheme;&#13;
      }&#13;
      // this latest bound box represent the last character of the line&#13;
      // to simplify cursor handling in interactive mode.&#13;
      lineBounds[i] = {&#13;
        left: graphemeInfo ? graphemeInfo.left + graphemeInfo.width : 0,&#13;
        width: 0,&#13;
        kernedWidth: 0,&#13;
        height: this.fontSize&#13;
      };&#13;
      return { width: width, numOfSpaces: numOfSpaces };&#13;
    },&#13;
&#13;
    /**&#13;
     * Measure and return the info of a single grapheme.&#13;
     * needs the the info of previous graphemes already filled&#13;
     * @private&#13;
     * @param {String} grapheme to be measured&#13;
     * @param {Number} lineIndex index of the line where the char is&#13;
     * @param {Number} charIndex position in the line&#13;
     * @param {String} [previousChar] character preceding the one to be measured&#13;
     */&#13;
    _getGraphemeBox: function(grapheme, lineIndex, charIndex, previousGrapheme, skipLeft) {&#13;
      var charStyle = this.getCompleteStyleDeclaration(lineIndex, charIndex),&#13;
          prevCharStyle = previousGrapheme ? this.getCompleteStyleDeclaration(lineIndex, charIndex - 1) : { },&#13;
          info = this._measureChar(grapheme, charStyle, previousGrapheme, prevCharStyle),&#13;
          kernedWidth = info.kernedWidth, width = info.width;&#13;
&#13;
      if (this.charSpacing !== 0) {&#13;
        width += this._getWidthOfCharSpacing();&#13;
        kernedWidth += this._getWidthOfCharSpacing();&#13;
      }&#13;
      var box = {&#13;
        width: width,&#13;
        left: 0,&#13;
        height: charStyle.fontSize,&#13;
        kernedWidth: kernedWidth,&#13;
      };&#13;
      if (charIndex &gt; 0 &amp;&amp; !skipLeft) {&#13;
        var previousBox = this.__charBounds[lineIndex][charIndex - 1];&#13;
        box.left = previousBox.left + previousBox.width + info.kernedWidth - info.width;&#13;
      }&#13;
      return box;&#13;
    },&#13;
&#13;
    /**&#13;
     * Calculate height of chosen line&#13;
     * height of line is based mainly on fontSize&#13;
     * @private&#13;
     * @param {Number} lineIndex index of the line to calculate&#13;
     */&#13;
    getHeightOfLine: function(lineIndex) {&#13;
      if (this.__lineHeights[lineIndex]) {&#13;
        return this.__lineHeights[lineIndex];&#13;
      }&#13;
&#13;
      var line = this._textLines[lineIndex],&#13;
          maxHeight = this.getHeightOfChar(lineIndex, 0);&#13;
&#13;
      for (var i = 1, len = line.length; i &lt; len; i++) {&#13;
        var currentCharHeight = this.getHeightOfChar(lineIndex, i);&#13;
        if (currentCharHeight &gt; maxHeight) {&#13;
          maxHeight = currentCharHeight;&#13;
        }&#13;
      }&#13;
      this.__lineHeights[lineIndex] = maxHeight * this.lineHeight * this._fontSizeMult;&#13;
      return this.__lineHeights[lineIndex];&#13;
    },&#13;
&#13;
    /**&#13;
     * calculate text box height&#13;
     * @private&#13;
     */&#13;
    calcTextHeight: function() {&#13;
      var lineHeight, height = 0;&#13;
      for (var i = 0, len = this._textLines.length; i &lt; len; i++) {&#13;
        lineHeight = this.getHeightOfLine(i);&#13;
        height += (i === len - 1 ? lineHeight / this.lineHeight : lineHeight);&#13;
      }&#13;
      return height;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @return {Number} Left offset&#13;
     */&#13;
    _getLeftOffset: function() {&#13;
      return -this.width / 2;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @return {Number} Top offset&#13;
     */&#13;
    _getTopOffset: function() {&#13;
      return -this.height / 2;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     * @param {String} method Method name ("fillText" or "strokeText")&#13;
     */&#13;
    _renderTextCommon: function(ctx, method) {&#13;
      ctx.save();&#13;
      var lineHeights = 0, left = this._getLeftOffset(), top = this._getTopOffset(),&#13;
          offsets = this._applyPatternGradientTransform(ctx, method === 'fillText' ? this.fill : this.stroke);&#13;
      for (var i = 0, len = this._textLines.length; i &lt; len; i++) {&#13;
        var heightOfLine = this.getHeightOfLine(i),&#13;
            maxHeight = heightOfLine / this.lineHeight,&#13;
            leftOffset = this._getLineLeftOffset(i);&#13;
        this._renderTextLine(&#13;
          method,&#13;
          ctx,&#13;
          this._textLines[i],&#13;
          left + leftOffset - offsets.offsetX,&#13;
          top + lineHeights + maxHeight - offsets.offsetY,&#13;
          i&#13;
        );&#13;
        lineHeights += heightOfLine;&#13;
      }&#13;
      ctx.restore();&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     */&#13;
    _renderTextFill: function(ctx) {&#13;
      if (!this.fill &amp;&amp; !this.styleHas('fill')) {&#13;
        return;&#13;
      }&#13;
&#13;
      this._renderTextCommon(ctx, 'fillText');&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     */&#13;
    _renderTextStroke: function(ctx) {&#13;
      if ((!this.stroke || this.strokeWidth === 0) &amp;&amp; this.isEmptyStyles()) {&#13;
        return;&#13;
      }&#13;
&#13;
      if (this.shadow &amp;&amp; !this.shadow.affectStroke) {&#13;
        this._removeShadow(ctx);&#13;
      }&#13;
&#13;
      ctx.save();&#13;
      this._setLineDash(ctx, this.strokeDashArray);&#13;
      ctx.beginPath();&#13;
      this._renderTextCommon(ctx, 'strokeText');&#13;
      ctx.closePath();&#13;
      ctx.restore();&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {String} method&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     * @param {String} line Content of the line&#13;
     * @param {Number} left&#13;
     * @param {Number} top&#13;
     * @param {Number} lineIndex&#13;
     * @param {Number} charOffset&#13;
     */&#13;
    _renderChars: function(method, ctx, line, left, top, lineIndex) {&#13;
      // set proper line offset&#13;
      var lineHeight = this.getHeightOfLine(lineIndex),&#13;
          isJustify = this.textAlign.indexOf('justify') !== -1,&#13;
          actualStyle,&#13;
          nextStyle,&#13;
          charsToRender = '',&#13;
          charBox,&#13;
          boxWidth = 0,&#13;
          timeToRender,&#13;
          shortCut = !isJustify &amp;&amp; this.isEmptyStyles(lineIndex);&#13;
&#13;
      ctx.save();&#13;
      top -= lineHeight * this._fontSizeFraction / this.lineHeight;&#13;
      if (shortCut) {&#13;
        // render all the line in one pass without checking&#13;
        this._renderChar(method, ctx, lineIndex, 0, this.textLines[lineIndex], left, top, lineHeight);&#13;
        ctx.restore();&#13;
        return;&#13;
      }&#13;
      for (var i = 0, len = line.length - 1; i &lt;= len; i++) {&#13;
        timeToRender = i === len || this.charSpacing;&#13;
        charsToRender += line[i];&#13;
        charBox = this.__charBounds[lineIndex][i];&#13;
        if (boxWidth === 0) {&#13;
          left += charBox.kernedWidth - charBox.width;&#13;
          boxWidth += charBox.width;&#13;
        }&#13;
        else {&#13;
          boxWidth += charBox.kernedWidth;&#13;
        }&#13;
        if (isJustify &amp;&amp; !timeToRender) {&#13;
          if (this._reSpaceAndTab.test(line[i])) {&#13;
            timeToRender = true;&#13;
          }&#13;
        }&#13;
        if (!timeToRender) {&#13;
          // if we have charSpacing, we render char by char&#13;
          actualStyle = actualStyle || this.getCompleteStyleDeclaration(lineIndex, i);&#13;
          nextStyle = this.getCompleteStyleDeclaration(lineIndex, i + 1);&#13;
          timeToRender = this._hasStyleChanged(actualStyle, nextStyle);&#13;
        }&#13;
        if (timeToRender) {&#13;
          this._renderChar(method, ctx, lineIndex, i, charsToRender, left, top, lineHeight);&#13;
          charsToRender = '';&#13;
          actualStyle = nextStyle;&#13;
          left += boxWidth;&#13;
          boxWidth = 0;&#13;
        }&#13;
      }&#13;
      ctx.restore();&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {String} method&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     * @param {Number} lineIndex&#13;
     * @param {Number} charIndex&#13;
     * @param {String} _char&#13;
     * @param {Number} left Left coordinate&#13;
     * @param {Number} top Top coordinate&#13;
     * @param {Number} lineHeight Height of the line&#13;
     */&#13;
    _renderChar: function(method, ctx, lineIndex, charIndex, _char, left, top) {&#13;
      var decl = this._getStyleDeclaration(lineIndex, charIndex),&#13;
          fullDecl = this.getCompleteStyleDeclaration(lineIndex, charIndex),&#13;
          shouldFill = method === 'fillText' &amp;&amp; fullDecl.fill,&#13;
          shouldStroke = method === 'strokeText' &amp;&amp; fullDecl.stroke &amp;&amp; fullDecl.strokeWidth;&#13;
&#13;
      if (!shouldStroke &amp;&amp; !shouldFill) {&#13;
        return;&#13;
      }&#13;
      decl &amp;&amp; ctx.save();&#13;
&#13;
      this._applyCharStyles(method, ctx, lineIndex, charIndex, fullDecl);&#13;
&#13;
      if (decl &amp;&amp; decl.textBackgroundColor) {&#13;
        this._removeShadow(ctx);&#13;
      }&#13;
      shouldFill &amp;&amp; ctx.fillText(_char, left, top);&#13;
      shouldStroke &amp;&amp; ctx.strokeText(_char, left, top);&#13;
      decl &amp;&amp; ctx.restore();&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Object} prevStyle&#13;
     * @param {Object} thisStyle&#13;
     */&#13;
    _hasStyleChanged: function(prevStyle, thisStyle) {&#13;
      return prevStyle.fill !== thisStyle.fill ||&#13;
              prevStyle.stroke !== thisStyle.stroke ||&#13;
              prevStyle.strokeWidth !== thisStyle.strokeWidth ||&#13;
              prevStyle.fontSize !== thisStyle.fontSize ||&#13;
              prevStyle.fontFamily !== thisStyle.fontFamily ||&#13;
              prevStyle.fontWeight !== thisStyle.fontWeight ||&#13;
              prevStyle.fontStyle !== thisStyle.fontStyle;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Object} prevStyle&#13;
     * @param {Object} thisStyle&#13;
     */&#13;
    _hasStyleChangedForSvg: function(prevStyle, thisStyle) {&#13;
      return this._hasStyleChanged(prevStyle, thisStyle) ||&#13;
        prevStyle.overline !== thisStyle.overline ||&#13;
        prevStyle.underline !== thisStyle.underline ||&#13;
        prevStyle.linethrough !== thisStyle.linethrough;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Number} lineIndex index text line&#13;
     * @return {Number} Line left offset&#13;
     */&#13;
    _getLineLeftOffset: function(lineIndex) {&#13;
      var lineWidth = this.getLineWidth(lineIndex);&#13;
      if (this.textAlign === 'center') {&#13;
        return (this.width - lineWidth) / 2;&#13;
      }&#13;
      if (this.textAlign === 'right') {&#13;
        return this.width - lineWidth;&#13;
      }&#13;
      if (this.textAlign === 'justify-center' &amp;&amp; this.isEndOfWrapping(lineIndex)) {&#13;
        return (this.width - lineWidth) / 2;&#13;
      }&#13;
      if (this.textAlign === 'justify-right' &amp;&amp; this.isEndOfWrapping(lineIndex)) {&#13;
        return this.width - lineWidth;&#13;
      }&#13;
      return 0;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _clearCache: function() {&#13;
      this.__lineWidths = [];&#13;
      this.__lineHeights = [];&#13;
      this.__charBounds = [];&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _shouldClearDimensionCache: function() {&#13;
      var shouldClear = this._forceClearCache;&#13;
      shouldClear || (shouldClear = this.hasStateChanged('_dimensionAffectingProps'));&#13;
      if (shouldClear) {&#13;
        this.dirty = true;&#13;
        this._forceClearCache = false;&#13;
      }&#13;
      return shouldClear;&#13;
    },&#13;
&#13;
    /**&#13;
     * Measure a single line given its index. Used to calculate the initial&#13;
     * text bounding box. The values are calculated and stored in __lineWidths cache.&#13;
     * @private&#13;
     * @param {Number} lineIndex line number&#13;
     * @return {Number} Line width&#13;
     */&#13;
    getLineWidth: function(lineIndex) {&#13;
      if (this.__lineWidths[lineIndex]) {&#13;
        return this.__lineWidths[lineIndex];&#13;
      }&#13;
&#13;
      var width, line = this._textLines[lineIndex], lineInfo;&#13;
&#13;
      if (line === '') {&#13;
        width = 0;&#13;
      }&#13;
      else {&#13;
        lineInfo = this.measureLine(lineIndex);&#13;
        width = lineInfo.width;&#13;
      }&#13;
      this.__lineWidths[lineIndex] = width;&#13;
      return width;&#13;
    },&#13;
&#13;
    _getWidthOfCharSpacing: function() {&#13;
      if (this.charSpacing !== 0) {&#13;
        return this.fontSize * this.charSpacing / 1000;&#13;
      }&#13;
      return 0;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Number} LineIndex&#13;
     * @param {Number} charIndex&#13;
     * @param {String} property&#13;
&#13;
     */&#13;
    getValueOfPropertyAt: function(lineIndex, charIndex, property) {&#13;
      var charStyle = this._getStyleDeclaration(lineIndex, charIndex),&#13;
          styleDecoration = charStyle &amp;&amp; typeof charStyle[property] !== 'undefined';&#13;
      return styleDecoration ? charStyle[property] : this[property];&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     */&#13;
    _renderTextDecoration: function(ctx, type) {&#13;
      if (!this[type] &amp;&amp; !this.styleHas(type)) {&#13;
        return;&#13;
      }&#13;
      var heightOfLine,&#13;
          lineLeftOffset,&#13;
          line, lastDecoration,&#13;
          leftOffset = this._getLeftOffset(),&#13;
          topOffset = this._getTopOffset(),&#13;
          boxStart, boxWidth, charBox, currentDecoration,&#13;
          maxHeight, currentFill, lastFill;&#13;
&#13;
      for (var i = 0, len = this._textLines.length; i &lt; len; i++) {&#13;
        heightOfLine = this.getHeightOfLine(i);&#13;
        if (!this[type] &amp;&amp; !this.styleHas(type, i)) {&#13;
          topOffset += heightOfLine;&#13;
          continue;&#13;
        }&#13;
        line = this._textLines[i];&#13;
        maxHeight = heightOfLine / this.lineHeight;&#13;
        lineLeftOffset = this._getLineLeftOffset(i);&#13;
        boxStart = 0;&#13;
        boxWidth = 0;&#13;
        lastDecoration = this.getValueOfPropertyAt(i, 0, type);&#13;
        lastFill = this.getValueOfPropertyAt(i, 0, 'fill');&#13;
        for (var j = 0, jlen = line.length; j &lt; jlen; j++) {&#13;
          charBox = this.__charBounds[i][j];&#13;
          currentDecoration = this.getValueOfPropertyAt(i, j, type);&#13;
          currentFill = this.getValueOfPropertyAt(i, j, 'fill');&#13;
          if ((currentDecoration !== lastDecoration || currentFill !== lastFill) &amp;&amp; boxWidth &gt; 0) {&#13;
            ctx.fillStyle = lastFill;&#13;
            lastDecoration &amp;&amp; lastFill &amp;&amp; ctx.fillRect(&#13;
              leftOffset + lineLeftOffset + boxStart,&#13;
              topOffset + maxHeight * (1 - this._fontSizeFraction) + this.offsets[type] * this.fontSize,&#13;
              boxWidth,&#13;
              this.fontSize / 15);&#13;
            boxStart = charBox.left;&#13;
            boxWidth = charBox.width;&#13;
            lastDecoration = currentDecoration;&#13;
            lastFill = currentFill;&#13;
          }&#13;
          else {&#13;
            boxWidth += charBox.kernedWidth;&#13;
          }&#13;
        }&#13;
        ctx.fillStyle = currentFill;&#13;
        currentDecoration &amp;&amp; currentFill &amp;&amp; ctx.fillRect(&#13;
          leftOffset + lineLeftOffset + boxStart,&#13;
          topOffset + maxHeight * (1 - this._fontSizeFraction) + this.offsets[type] * this.fontSize,&#13;
          boxWidth,&#13;
          this.fontSize / 15&#13;
        );&#13;
        topOffset += heightOfLine;&#13;
      }&#13;
      // if there is text background color no&#13;
      // other shadows should be casted&#13;
      this._removeShadow(ctx);&#13;
    },&#13;
&#13;
    /**&#13;
     * return font declaration string for canvas context&#13;
     * @param {Object} [styleObject] object&#13;
     * @returns {String} font declaration formatted for canvas context.&#13;
     */&#13;
    _getFontDeclaration: function(styleObject, forMeasuring) {&#13;
      var style = styleObject || this;&#13;
      return [&#13;
        // node-canvas needs "weight style", while browsers need "style weight"&#13;
        (fabric.isLikelyNode ? style.fontWeight : style.fontStyle),&#13;
        (fabric.isLikelyNode ? style.fontStyle : style.fontWeight),&#13;
        forMeasuring ? CACHE_FONT_SIZE + 'px' : style.fontSize + 'px',&#13;
        (fabric.isLikelyNode ? ('"' + style.fontFamily + '"') : style.fontFamily)&#13;
      ].join(' ');&#13;
    },&#13;
&#13;
    /**&#13;
     * Renders text instance on a specified context&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     */&#13;
    render: function(ctx) {&#13;
      // do not render if object is not visible&#13;
      if (!this.visible) {&#13;
        return;&#13;
      }&#13;
      if (this.canvas &amp;&amp; this.canvas.skipOffscreen &amp;&amp; !this.group &amp;&amp; !this.isOnScreen()) {&#13;
        return;&#13;
      }&#13;
      if (this._shouldClearDimensionCache()) {&#13;
        this.initDimensions();&#13;
      }&#13;
      this.callSuper('render', ctx);&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns the text as an array of lines.&#13;
     * @param {String} text text to split&#13;
     * @returns {Array} Lines in the text&#13;
     */&#13;
    _splitTextIntoLines: function(text) {&#13;
      var lines = text.split(this._reNewline),&#13;
          newLines = new Array(lines.length),&#13;
          newLine = ['\n'],&#13;
          newText = [];&#13;
      for (var i = 0; i &lt; lines.length; i++) {&#13;
        newLines[i] = fabric.util.string.graphemeSplit(lines[i]);&#13;
        newText = newText.concat(newLines[i], newLine);&#13;
      }&#13;
      newText.pop();&#13;
      return { _unwrappedLines: newLines, lines: lines, graphemeText: newText, graphemeLines: newLines };&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns object representation of an instance&#13;
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output&#13;
     * @return {Object} Object representation of an instance&#13;
     */&#13;
    toObject: function(propertiesToInclude) {&#13;
      var additionalProperties = [&#13;
        'text',&#13;
        'fontSize',&#13;
        'fontWeight',&#13;
        'fontFamily',&#13;
        'fontStyle',&#13;
        'lineHeight',&#13;
        'underline',&#13;
        'overline',&#13;
        'linethrough',&#13;
        'textAlign',&#13;
        'textBackgroundColor',&#13;
        'charSpacing',&#13;
      ].concat(propertiesToInclude);&#13;
      var obj = this.callSuper('toObject', additionalProperties);&#13;
      obj.styles = clone(this.styles, true);&#13;
      return obj;&#13;
    },&#13;
&#13;
    /**&#13;
     * Sets property to a given value. When changing position/dimension -related properties (left, top, scale, angle, etc.) `set` does not update position of object's borders/controls. If you need to update those, call `setCoords()`.&#13;
     * @param {String|Object} key Property name or object (if object, iterate over the object properties)&#13;
     * @param {Object|Function} value Property value (if function, the value is passed into it and its return value is used as a new one)&#13;
     * @return {fabric.Object} thisArg&#13;
     * @chainable&#13;
     */&#13;
    set: function(key, value) {&#13;
      this.callSuper('set', key, value);&#13;
      var needsDims = false;&#13;
      if (typeof key === 'object') {&#13;
        for (var _key in key) {&#13;
          needsDims = needsDims || this._dimensionAffectingProps.indexOf(_key) !== -1;&#13;
        }&#13;
      }&#13;
      else {&#13;
        needsDims = this._dimensionAffectingProps.indexOf(key) !== -1;&#13;
      }&#13;
      if (needsDims) {&#13;
        this.initDimensions();&#13;
        this.setCoords();&#13;
      }&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns complexity of an instance&#13;
     * @return {Number} complexity&#13;
     */&#13;
    complexity: function() {&#13;
      return 1;&#13;
    }&#13;
  });&#13;
&#13;
  /* _FROM_SVG_START_ */&#13;
  /**&#13;
   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Text.fromElement})&#13;
   * @static&#13;
   * @memberOf fabric.Text&#13;
   * @see: http://www.w3.org/TR/SVG/text.html#TextElement&#13;
   */&#13;
  fabric.Text.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(&#13;
    'x y dx dy font-family font-style font-weight font-size text-decoration text-anchor'.split(' '));&#13;
&#13;
  /**&#13;
   * Default SVG font size&#13;
   * @static&#13;
   * @memberOf fabric.Text&#13;
   */&#13;
  fabric.Text.DEFAULT_SVG_FONT_SIZE = 16;&#13;
&#13;
  /**&#13;
   * Returns fabric.Text instance from an SVG element (&lt;b&gt;not yet implemented&lt;/b&gt;)&#13;
   * @static&#13;
   * @memberOf fabric.Text&#13;
   * @param {SVGElement} element Element to parse&#13;
   * @param {Function} callback callback function invoked after parsing&#13;
   * @param {Object} [options] Options object&#13;
   */&#13;
  fabric.Text.fromElement = function(element, callback, options) {&#13;
    if (!element) {&#13;
      return callback(null);&#13;
    }&#13;
&#13;
    var parsedAttributes = fabric.parseAttributes(element, fabric.Text.ATTRIBUTE_NAMES),&#13;
        parsedAnchor = parsedAttributes.textAnchor || 'left';&#13;
    options = fabric.util.object.extend((options ? clone(options) : { }), parsedAttributes);&#13;
&#13;
    options.top = options.top || 0;&#13;
    options.left = options.left || 0;&#13;
    if (parsedAttributes.textDecoration) {&#13;
      var textDecoration = parsedAttributes.textDecoration;&#13;
      if (textDecoration.indexOf('underline') !== -1) {&#13;
        options.underline = true;&#13;
      }&#13;
      if (textDecoration.indexOf('overline') !== -1) {&#13;
        options.overline = true;&#13;
      }&#13;
      if (textDecoration.indexOf('line-through') !== -1) {&#13;
        options.linethrough = true;&#13;
      }&#13;
      delete options.textDecoration;&#13;
    }&#13;
    if ('dx' in parsedAttributes) {&#13;
      options.left += parsedAttributes.dx;&#13;
    }&#13;
    if ('dy' in parsedAttributes) {&#13;
      options.top += parsedAttributes.dy;&#13;
    }&#13;
    if (!('fontSize' in options)) {&#13;
      options.fontSize = fabric.Text.DEFAULT_SVG_FONT_SIZE;&#13;
    }&#13;
&#13;
    var textContent = '';&#13;
&#13;
    // The XML is not properly parsed in IE9 so a workaround to get&#13;
    // textContent is through firstChild.data. Another workaround would be&#13;
    // to convert XML loaded from a file to be converted using DOMParser (same way loadSVGFromString() does)&#13;
    if (!('textContent' in element)) {&#13;
      if ('firstChild' in element &amp;&amp; element.firstChild !== null) {&#13;
        if ('data' in element.firstChild &amp;&amp; element.firstChild.data !== null) {&#13;
          textContent = element.firstChild.data;&#13;
        }&#13;
      }&#13;
    }&#13;
    else {&#13;
      textContent = element.textContent;&#13;
    }&#13;
&#13;
    textContent = textContent.replace(/^\s+|\s+$|\n+/g, '').replace(/\s+/g, ' ');&#13;
&#13;
    var text = new fabric.Text(textContent, options),&#13;
        textHeightScaleFactor = text.getScaledHeight() / text.height,&#13;
        lineHeightDiff = (text.height + text.strokeWidth) * text.lineHeight - text.height,&#13;
        scaledDiff = lineHeightDiff * textHeightScaleFactor,&#13;
        textHeight = text.getScaledHeight() + scaledDiff,&#13;
        offX = 0;&#13;
    /*&#13;
      Adjust positioning:&#13;
        x/y attributes in SVG correspond to the bottom-left corner of text bounding box&#13;
        fabric output by default at top, left.&#13;
    */&#13;
    if (parsedAnchor === 'center') {&#13;
      offX = text.getScaledWidth() / 2;&#13;
    }&#13;
    if (parsedAnchor === 'right') {&#13;
      offX = text.getScaledWidth();&#13;
    }&#13;
    text.set({&#13;
      left: text.left - offX,&#13;
      top: text.top - (textHeight - text.fontSize * (0.18 + text._fontSizeFraction)) / text.lineHeight&#13;
    });&#13;
    callback(text);&#13;
  };&#13;
  /* _FROM_SVG_END_ */&#13;
&#13;
  /**&#13;
   * Returns fabric.Text instance from an object representation&#13;
   * @static&#13;
   * @memberOf fabric.Text&#13;
   * @param {Object} object Object to create an instance from&#13;
   * @param {Function} [callback] Callback to invoke when an fabric.Text instance is created&#13;
   */&#13;
  fabric.Text.fromObject = function(object, callback) {&#13;
    return fabric.Object._fromObject('Text', object, callback, 'text');&#13;
  };&#13;
&#13;
  fabric.util.createAccessors &amp;&amp; fabric.util.createAccessors(fabric.Text);&#13;
&#13;
})(typeof exports !== 'undefined' ? exports : this);&#13;
&#13;
&#13;
(function() {&#13;
  fabric.util.object.extend(fabric.Text.prototype, /** @lends fabric.Text.prototype */ {&#13;
    /**&#13;
     * Returns true if object has no styling or no styling in a line&#13;
     * @param {Number} lineIndex&#13;
     * @return {Boolean}&#13;
     */&#13;
    isEmptyStyles: function(lineIndex) {&#13;
      if (!this.styles) {&#13;
        return true;&#13;
      }&#13;
      if (typeof lineIndex !== 'undefined' &amp;&amp; !this.styles[lineIndex]) {&#13;
        return true;&#13;
      }&#13;
      var obj = typeof lineIndex === 'undefined' ? this.styles : { line: this.styles[lineIndex] };&#13;
      for (var p1 in obj) {&#13;
        for (var p2 in obj[p1]) {&#13;
          // eslint-disable-next-line no-unused-vars&#13;
          for (var p3 in obj[p1][p2]) {&#13;
            return false;&#13;
          }&#13;
        }&#13;
      }&#13;
      return true;&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns true if object has a style property or has it ina specified line&#13;
     * @param {Number} lineIndex&#13;
     * @return {Boolean}&#13;
     */&#13;
    styleHas: function(property, lineIndex) {&#13;
      if (!this.styles || !property || property === '') {&#13;
        return false;&#13;
      }&#13;
      if (typeof lineIndex !== 'undefined' &amp;&amp; !this.styles[lineIndex]) {&#13;
        return false;&#13;
      }&#13;
      var obj = typeof lineIndex === 'undefined' ? this.styles : { line: this.styles[lineIndex] };&#13;
      // eslint-disable-next-line&#13;
      for (var p1 in obj) {&#13;
        // eslint-disable-next-line&#13;
        for (var p2 in obj[p1]) {&#13;
          if (typeof obj[p1][p2][property] !== 'undefined') {&#13;
            return true;&#13;
          }&#13;
        }&#13;
      }&#13;
      return false;&#13;
    },&#13;
&#13;
    /**&#13;
     * Check if characters in a text have a value for a property&#13;
     * whose value matches the textbox's value for that property.  If so,&#13;
     * the character-level property is deleted.  If the character&#13;
     * has no other properties, then it is also deleted.  Finally,&#13;
     * if the line containing that character has no other characters&#13;
     * then it also is deleted.&#13;
     *&#13;
     * @param {string} property The property to compare between characters and text.&#13;
     */&#13;
    cleanStyle: function(property) {&#13;
      if (!this.styles || !property || property === '') {&#13;
        return false;&#13;
      }&#13;
      var obj = this.styles, stylesCount = 0, letterCount, foundStyle = false, style,&#13;
          canBeSwapped = true, graphemeCount = 0;&#13;
      // eslint-disable-next-line&#13;
      for (var p1 in obj) {&#13;
        letterCount = 0;&#13;
        // eslint-disable-next-line&#13;
        for (var p2 in obj[p1]) {&#13;
          stylesCount++;&#13;
          if (!foundStyle) {&#13;
            style = obj[p1][p2][property];&#13;
            foundStyle = true;&#13;
          }&#13;
          else if (obj[p1][p2][property] !== style) {&#13;
            canBeSwapped = false;&#13;
          }&#13;
          if (obj[p1][p2][property] === this[property]) {&#13;
            delete obj[p1][p2][property];&#13;
          }&#13;
          if (Object.keys(obj[p1][p2]).length !== 0) {&#13;
            letterCount++;&#13;
          }&#13;
          else {&#13;
            delete obj[p1][p2];&#13;
          }&#13;
        }&#13;
        if (letterCount === 0) {&#13;
          delete obj[p1];&#13;
        }&#13;
      }&#13;
      // if every grapheme has the same style set then&#13;
      // delete those styles and set it on the parent&#13;
      for (var i = 0; i &lt; this._textLines.length; i++) {&#13;
        graphemeCount += this._textLines[i].length;&#13;
      }&#13;
      if (canBeSwapped &amp;&amp; stylesCount === graphemeCount) {&#13;
        this[property] = style;&#13;
        this.removeStyle(property);&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Remove a style property or properties from all individual character styles&#13;
     * in a text object.  Deletes the character style object if it contains no other style&#13;
     * props.  Deletes a line style object if it contains no other character styles.&#13;
     *&#13;
     * @param {String} props The property to remove from character styles.&#13;
     */&#13;
    removeStyle: function(property) {&#13;
      if (!this.styles || !property || property === '') {&#13;
        return;&#13;
      }&#13;
      var obj = this.styles, line, lineNum, charNum;&#13;
      for (lineNum in obj) {&#13;
        line = obj[lineNum];&#13;
        for (charNum in line) {&#13;
          delete line[charNum][property];&#13;
          if (Object.keys(line[charNum]).length === 0) {&#13;
            delete line[charNum];&#13;
          }&#13;
        }&#13;
        if (Object.keys(line).length === 0) {&#13;
          delete obj[lineNum];&#13;
        }&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _extendStyles: function(index, styles) {&#13;
      var loc = this.get2DCursorLocation(index);&#13;
&#13;
      if (!this._getLineStyle(loc.lineIndex)) {&#13;
        this._setLineStyle(loc.lineIndex, {});&#13;
      }&#13;
&#13;
      if (!this._getStyleDeclaration(loc.lineIndex, loc.charIndex)) {&#13;
        this._setStyleDeclaration(loc.lineIndex, loc.charIndex, {});&#13;
      }&#13;
&#13;
      fabric.util.object.extend(this._getStyleDeclaration(loc.lineIndex, loc.charIndex), styles);&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns 2d representation (lineIndex and charIndex) of cursor (or selection start)&#13;
     * @param {Number} [selectionStart] Optional index. When not given, current selectionStart is used.&#13;
     * @param {Boolean} [skipWrapping] consider the location for unwrapped lines. usefull to manage styles.&#13;
     */&#13;
    get2DCursorLocation: function(selectionStart, skipWrapping) {&#13;
      if (typeof selectionStart === 'undefined') {&#13;
        selectionStart = this.selectionStart;&#13;
      }&#13;
      var lines = skipWrapping ? this._unwrappedTextLines : this._textLines;&#13;
      var len = lines.length;&#13;
      for (var i = 0; i &lt; len; i++) {&#13;
        if (selectionStart &lt;= lines[i].length) {&#13;
          return {&#13;
            lineIndex: i,&#13;
            charIndex: selectionStart&#13;
          };&#13;
        }&#13;
        selectionStart -= lines[i].length + 1;&#13;
      }&#13;
      return {&#13;
        lineIndex: i - 1,&#13;
        charIndex: lines[i - 1].length &lt; selectionStart ? lines[i - 1].length : selectionStart&#13;
      };&#13;
    },&#13;
&#13;
    /**&#13;
     * Gets style of a current selection/cursor (at the start position)&#13;
     * if startIndex or endIndex are not provided, slectionStart or selectionEnd will be used.&#13;
     * @param {Number} [startIndex] Start index to get styles at&#13;
     * @param {Number} [endIndex] End index to get styles at, if not specified selectionEnd or startIndex + 1&#13;
     * @param {Boolean} [complete] get full style or not&#13;
     * @return {Array} styles an array with one, zero or more Style objects&#13;
     */&#13;
    getSelectionStyles: function(startIndex, endIndex, complete) {&#13;
      if (typeof startIndex === 'undefined') {&#13;
        startIndex = this.selectionStart || 0;&#13;
      }&#13;
      if (typeof endIndex === 'undefined') {&#13;
        endIndex = this.selectionEnd || startIndex;&#13;
      }&#13;
      var styles = [];&#13;
      for (var i = startIndex; i &lt; endIndex; i++) {&#13;
        styles.push(this.getStyleAtPosition(i, complete));&#13;
      }&#13;
      return styles;&#13;
    },&#13;
&#13;
    /**&#13;
     * Gets style of a current selection/cursor position&#13;
     * @param {Number} position  to get styles at&#13;
     * @param {Boolean} [complete] full style if true&#13;
     * @return {Object} style Style object at a specified index&#13;
     * @private&#13;
     */&#13;
    getStyleAtPosition: function(position, complete) {&#13;
      var loc = this.get2DCursorLocation(position),&#13;
          style = complete ? this.getCompleteStyleDeclaration(loc.lineIndex, loc.charIndex) :&#13;
            this._getStyleDeclaration(loc.lineIndex, loc.charIndex);&#13;
      return style || {};&#13;
    },&#13;
&#13;
    /**&#13;
     * Sets style of a current selection, if no selection exist, do not set anything.&#13;
     * @param {Object} [styles] Styles object&#13;
     * @param {Number} [startIndex] Start index to get styles at&#13;
     * @param {Number} [endIndex] End index to get styles at, if not specified selectionEnd or startIndex + 1&#13;
     * @return {fabric.IText} thisArg&#13;
     * @chainable&#13;
     */&#13;
    setSelectionStyles: function(styles, startIndex, endIndex) {&#13;
      if (typeof startIndex === 'undefined') {&#13;
        startIndex = this.selectionStart || 0;&#13;
      }&#13;
      if (typeof endIndex === 'undefined') {&#13;
        endIndex = this.selectionEnd || startIndex;&#13;
      }&#13;
      for (var i = startIndex; i &lt; endIndex; i++) {&#13;
        this._extendStyles(i, styles);&#13;
      }&#13;
      /* not included in _extendStyles to avoid clearing cache more than once */&#13;
      this._forceClearCache = true;&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * get the reference, not a clone, of the style object for a given character&#13;
     * @param {Number} lineIndex&#13;
     * @param {Number} charIndex&#13;
     * @return {Object} style object&#13;
     */&#13;
    _getStyleDeclaration: function(lineIndex, charIndex) {&#13;
      var lineStyle = this.styles &amp;&amp; this.styles[lineIndex];&#13;
      if (!lineStyle) {&#13;
        return null;&#13;
      }&#13;
      return lineStyle[charIndex];&#13;
    },&#13;
&#13;
    /**&#13;
     * return a new object that contains all the style property for a character&#13;
     * the object returned is newly created&#13;
     * @param {Number} lineIndex of the line where the character is&#13;
     * @param {Number} charIndex position of the character on the line&#13;
     * @return {Object} style object&#13;
     */&#13;
    getCompleteStyleDeclaration: function(lineIndex, charIndex) {&#13;
      var style = this._getStyleDeclaration(lineIndex, charIndex) || { },&#13;
          styleObject = { }, prop;&#13;
      for (var i = 0; i &lt; this._styleProperties.length; i++) {&#13;
        prop = this._styleProperties[i];&#13;
        styleObject[prop] = typeof style[prop] === 'undefined' ? this[prop] : style[prop];&#13;
      }&#13;
      return styleObject;&#13;
    },&#13;
&#13;
    /**&#13;
     * @param {Number} lineIndex&#13;
     * @param {Number} charIndex&#13;
     * @param {Object} style&#13;
     * @private&#13;
     */&#13;
    _setStyleDeclaration: function(lineIndex, charIndex, style) {&#13;
      this.styles[lineIndex][charIndex] = style;&#13;
    },&#13;
&#13;
    /**&#13;
     *&#13;
     * @param {Number} lineIndex&#13;
     * @param {Number} charIndex&#13;
     * @private&#13;
     */&#13;
    _deleteStyleDeclaration: function(lineIndex, charIndex) {&#13;
      delete this.styles[lineIndex][charIndex];&#13;
    },&#13;
&#13;
    /**&#13;
     * @param {Number} lineIndex&#13;
     * @private&#13;
     */&#13;
    _getLineStyle: function(lineIndex) {&#13;
      return this.styles[lineIndex];&#13;
    },&#13;
&#13;
    /**&#13;
     * @param {Number} lineIndex&#13;
     * @param {Object} style&#13;
     * @private&#13;
     */&#13;
    _setLineStyle: function(lineIndex, style) {&#13;
      this.styles[lineIndex] = style;&#13;
    },&#13;
&#13;
    /**&#13;
     * @param {Number} lineIndex&#13;
     * @private&#13;
     */&#13;
    _deleteLineStyle: function(lineIndex) {&#13;
      delete this.styles[lineIndex];&#13;
    }&#13;
  });&#13;
})();&#13;
&#13;
&#13;
(function() {&#13;
&#13;
  function parseDecoration(object) {&#13;
    if (object.textDecoration) {&#13;
      object.textDecoration.indexOf('underline') &gt; -1 &amp;&amp; (object.underline = true);&#13;
      object.textDecoration.indexOf('line-through') &gt; -1 &amp;&amp; (object.linethrough = true);&#13;
      object.textDecoration.indexOf('overline') &gt; -1 &amp;&amp; (object.overline = true);&#13;
      delete object.textDecoration;&#13;
    }&#13;
  }&#13;
&#13;
  /**&#13;
   * IText class (introduced in &lt;b&gt;v1.4&lt;/b&gt;) Events are also fired with "text:"&#13;
   * prefix when observing canvas.&#13;
   * @class fabric.IText&#13;
   * @extends fabric.Text&#13;
   * @mixes fabric.Observable&#13;
   *&#13;
   * @fires changed&#13;
   * @fires selection:changed&#13;
   * @fires editing:entered&#13;
   * @fires editing:exited&#13;
   *&#13;
   * @return {fabric.IText} thisArg&#13;
   * @see {@link fabric.IText#initialize} for constructor definition&#13;
   *&#13;
   * &lt;p&gt;Supported key combinations:&lt;/p&gt;&#13;
   * &lt;pre&gt;&#13;
   *   Move cursor:                    left, right, up, down&#13;
   *   Select character:               shift + left, shift + right&#13;
   *   Select text vertically:         shift + up, shift + down&#13;
   *   Move cursor by word:            alt + left, alt + right&#13;
   *   Select words:                   shift + alt + left, shift + alt + right&#13;
   *   Move cursor to line start/end:  cmd + left, cmd + right or home, end&#13;
   *   Select till start/end of line:  cmd + shift + left, cmd + shift + right or shift + home, shift + end&#13;
   *   Jump to start/end of text:      cmd + up, cmd + down&#13;
   *   Select till start/end of text:  cmd + shift + up, cmd + shift + down or shift + pgUp, shift + pgDown&#13;
   *   Delete character:               backspace&#13;
   *   Delete word:                    alt + backspace&#13;
   *   Delete line:                    cmd + backspace&#13;
   *   Forward delete:                 delete&#13;
   *   Copy text:                      ctrl/cmd + c&#13;
   *   Paste text:                     ctrl/cmd + v&#13;
   *   Cut text:                       ctrl/cmd + x&#13;
   *   Select entire text:             ctrl/cmd + a&#13;
   *   Quit editing                    tab or esc&#13;
   * &lt;/pre&gt;&#13;
   *&#13;
   * &lt;p&gt;Supported mouse/touch combination&lt;/p&gt;&#13;
   * &lt;pre&gt;&#13;
   *   Position cursor:                click/touch&#13;
   *   Create selection:               click/touch &amp; drag&#13;
   *   Create selection:               click &amp; shift + click&#13;
   *   Select word:                    double click&#13;
   *   Select line:                    triple click&#13;
   * &lt;/pre&gt;&#13;
   */&#13;
  fabric.IText = fabric.util.createClass(fabric.Text, fabric.Observable, /** @lends fabric.IText.prototype */ {&#13;
&#13;
    /**&#13;
     * Type of an object&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    type: 'i-text',&#13;
&#13;
    /**&#13;
     * Index where text selection starts (or where cursor is when there is no selection)&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    selectionStart: 0,&#13;
&#13;
    /**&#13;
     * Index where text selection ends&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    selectionEnd: 0,&#13;
&#13;
    /**&#13;
     * Color of text selection&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    selectionColor: 'rgba(17,119,255,0.3)',&#13;
&#13;
    /**&#13;
     * Indicates whether text is in editing mode&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    isEditing: false,&#13;
&#13;
    /**&#13;
     * Indicates whether a text can be edited&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    editable: true,&#13;
&#13;
    /**&#13;
     * Border color of text object while it's in editing mode&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    editingBorderColor: 'rgba(102,153,255,0.25)',&#13;
&#13;
    /**&#13;
     * Width of cursor (in px)&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    cursorWidth: 2,&#13;
&#13;
    /**&#13;
     * Color of default cursor (when not overwritten by character style)&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    cursorColor: '#333',&#13;
&#13;
    /**&#13;
     * Delay between cursor blink (in ms)&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    cursorDelay: 1000,&#13;
&#13;
    /**&#13;
     * Duration of cursor fadein (in ms)&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    cursorDuration: 600,&#13;
&#13;
    /**&#13;
     * Indicates whether internal text char widths can be cached&#13;
     * @type Boolean&#13;
     * @default&#13;
     */&#13;
    caching: true,&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _reSpace: /\s|\n/,&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _currentCursorOpacity: 0,&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _selectionDirection: null,&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _abortCursorAnimation: false,&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    __widthOfSpace: [],&#13;
&#13;
    /**&#13;
     * Helps determining when the text is in composition, so that the cursor&#13;
     * rendering is altered.&#13;
     */&#13;
    inCompositionMode: false,&#13;
&#13;
    /**&#13;
     * Constructor&#13;
     * @param {String} text Text string&#13;
     * @param {Object} [options] Options object&#13;
     * @return {fabric.IText} thisArg&#13;
     */&#13;
    initialize: function(text, options) {&#13;
      this.callSuper('initialize', text, options);&#13;
      this.initBehavior();&#13;
    },&#13;
&#13;
    /**&#13;
     * Sets selection start (left boundary of a selection)&#13;
     * @param {Number} index Index to set selection start to&#13;
     */&#13;
    setSelectionStart: function(index) {&#13;
      index = Math.max(index, 0);&#13;
      this._updateAndFire('selectionStart', index);&#13;
    },&#13;
&#13;
    /**&#13;
     * Sets selection end (right boundary of a selection)&#13;
     * @param {Number} index Index to set selection end to&#13;
     */&#13;
    setSelectionEnd: function(index) {&#13;
      index = Math.min(index, this.text.length);&#13;
      this._updateAndFire('selectionEnd', index);&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {String} property 'selectionStart' or 'selectionEnd'&#13;
     * @param {Number} index new position of property&#13;
     */&#13;
    _updateAndFire: function(property, index) {&#13;
      if (this[property] !== index) {&#13;
        this._fireSelectionChanged();&#13;
        this[property] = index;&#13;
      }&#13;
      this._updateTextarea();&#13;
    },&#13;
&#13;
    /**&#13;
     * Fires the even of selection changed&#13;
     * @private&#13;
     */&#13;
    _fireSelectionChanged: function() {&#13;
      this.fire('selection:changed');&#13;
      this.canvas &amp;&amp; this.canvas.fire('text:selection:changed', { target: this });&#13;
    },&#13;
&#13;
    /**&#13;
     * Initialize text dimensions. Render all text on given context&#13;
     * or on a offscreen canvas to get the text width with measureText.&#13;
     * Updates this.width and this.height with the proper values.&#13;
     * Does not return dimensions.&#13;
     * @private&#13;
     */&#13;
    initDimensions: function() {&#13;
      this.isEditing &amp;&amp; this.initDelayedCursor();&#13;
      this.clearContextTop();&#13;
      this.callSuper('initDimensions');&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     */&#13;
    render: function(ctx) {&#13;
      this.clearContextTop();&#13;
      this.callSuper('render', ctx);&#13;
      // clear the cursorOffsetCache, so we ensure to calculate once per renderCursor&#13;
      // the correct position but not at every cursor animation.&#13;
      this.cursorOffsetCache = { };&#13;
      this.renderCursorOrSelection();&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {CanvasRenderingContext2D} ctx Context to render on&#13;
     */&#13;
    _render: function(ctx) {&#13;
      this.callSuper('_render', ctx);&#13;
    },&#13;
&#13;
    /**&#13;
     * Prepare and clean the contextTop&#13;
     */&#13;
    clearContextTop: function(skipRestore) {&#13;
      if (!this.isEditing) {&#13;
        return;&#13;
      }&#13;
      if (this.canvas &amp;&amp; this.canvas.contextTop) {&#13;
        var ctx = this.canvas.contextTop, v = this.canvas.viewportTransform;&#13;
        ctx.save();&#13;
        ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);&#13;
        this.transform(ctx);&#13;
        this.transformMatrix &amp;&amp; ctx.transform.apply(ctx, this.transformMatrix);&#13;
        this._clearTextArea(ctx);&#13;
        skipRestore || ctx.restore();&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Renders cursor or selection (depending on what exists)&#13;
     */&#13;
    renderCursorOrSelection: function() {&#13;
      if (!this.isEditing || !this.canvas) {&#13;
        return;&#13;
      }&#13;
      var boundaries = this._getCursorBoundaries(), ctx;&#13;
      if (this.canvas &amp;&amp; this.canvas.contextTop) {&#13;
        ctx = this.canvas.contextTop;&#13;
        this.clearContextTop(true);&#13;
      }&#13;
      else {&#13;
        ctx = this.canvas.contextContainer;&#13;
        ctx.save();&#13;
      }&#13;
      if (this.selectionStart === this.selectionEnd) {&#13;
        this.renderCursor(boundaries, ctx);&#13;
      }&#13;
      else {&#13;
        this.renderSelection(boundaries, ctx);&#13;
      }&#13;
      ctx.restore();&#13;
    },&#13;
&#13;
    _clearTextArea: function(ctx) {&#13;
      // we add 4 pixel, to be sure to do not leave any pixel out&#13;
      var width = this.width + 4, height = this.height + 4;&#13;
      ctx.clearRect(-width / 2, -height / 2, width, height);&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns cursor boundaries (left, top, leftOffset, topOffset)&#13;
     * @private&#13;
     * @param {Array} chars Array of characters&#13;
     * @param {String} typeOfBoundaries&#13;
     */&#13;
    _getCursorBoundaries: function(position) {&#13;
&#13;
      // left/top are left/top of entire text box&#13;
      // leftOffset/topOffset are offset from that left/top point of a text box&#13;
&#13;
      if (typeof position === 'undefined') {&#13;
        position = this.selectionStart;&#13;
      }&#13;
&#13;
      var left = this._getLeftOffset(),&#13;
          top = this._getTopOffset(),&#13;
          offsets = this._getCursorBoundariesOffsets(position);&#13;
&#13;
      return {&#13;
        left: left,&#13;
        top: top,&#13;
        leftOffset: offsets.left,&#13;
        topOffset: offsets.top&#13;
      };&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _getCursorBoundariesOffsets: function(position) {&#13;
      if (this.cursorOffsetCache &amp;&amp; 'top' in this.cursorOffsetCache) {&#13;
        return this.cursorOffsetCache;&#13;
      }&#13;
      var lineLeftOffset,&#13;
          lineIndex = 0,&#13;
          charIndex = 0,&#13;
          topOffset = 0,&#13;
          leftOffset = 0,&#13;
          boundaries,&#13;
          cursorPosition = this.get2DCursorLocation(position);&#13;
      for (var i = 0; i &lt; cursorPosition.lineIndex; i++) {&#13;
        topOffset += this.getHeightOfLine(i);&#13;
      }&#13;
&#13;
      lineLeftOffset = this._getLineLeftOffset(cursorPosition.lineIndex);&#13;
      var bound = this.__charBounds[cursorPosition.lineIndex][cursorPosition.charIndex];&#13;
      bound &amp;&amp; (leftOffset = bound.left);&#13;
      if (this.charSpacing !== 0 &amp;&amp; charIndex === this._textLines[lineIndex].length) {&#13;
        leftOffset -= this._getWidthOfCharSpacing();&#13;
      }&#13;
      boundaries = {&#13;
        top: topOffset,&#13;
        left: lineLeftOffset + (leftOffset &gt; 0 ? leftOffset : 0),&#13;
      };&#13;
      this.cursorOffsetCache = boundaries;&#13;
      return this.cursorOffsetCache;&#13;
    },&#13;
&#13;
    /**&#13;
     * Renders cursor&#13;
     * @param {Object} boundaries&#13;
     * @param {CanvasRenderingContext2D} ctx transformed context to draw on&#13;
     */&#13;
    renderCursor: function(boundaries, ctx) {&#13;
      var cursorLocation = this.get2DCursorLocation(),&#13;
          lineIndex = cursorLocation.lineIndex,&#13;
          charIndex = cursorLocation.charIndex &gt; 0 ? cursorLocation.charIndex - 1 : 0,&#13;
          charHeight = this.getValueOfPropertyAt(lineIndex, charIndex, 'fontSize'),&#13;
          multiplier = this.scaleX * this.canvas.getZoom(),&#13;
          cursorWidth = this.cursorWidth / multiplier,&#13;
          topOffset = boundaries.topOffset;&#13;
&#13;
      topOffset += (1 - this._fontSizeFraction) * this.getHeightOfLine(lineIndex) / this.lineHeight&#13;
        - charHeight * (1 - this._fontSizeFraction);&#13;
&#13;
      if (this.inCompositionMode) {&#13;
        this.renderSelection(boundaries, ctx);&#13;
      }&#13;
&#13;
      ctx.fillStyle = this.getValueOfPropertyAt(lineIndex, charIndex, 'fill');&#13;
      ctx.globalAlpha = this.__isMousedown ? 1 : this._currentCursorOpacity;&#13;
      ctx.fillRect(&#13;
        boundaries.left + boundaries.leftOffset - cursorWidth / 2,&#13;
        topOffset + boundaries.top,&#13;
        cursorWidth,&#13;
        charHeight);&#13;
    },&#13;
&#13;
    /**&#13;
     * Renders text selection&#13;
     * @param {Object} boundaries Object with left/top/leftOffset/topOffset&#13;
     * @param {CanvasRenderingContext2D} ctx transformed context to draw on&#13;
     */&#13;
    renderSelection: function(boundaries, ctx) {&#13;
&#13;
      var selectionStart = this.inCompositionMode ? this.hiddenTextarea.selectionStart : this.selectionStart,&#13;
          selectionEnd = this.inCompositionMode ? this.hiddenTextarea.selectionEnd : this.selectionEnd,&#13;
          isJustify = this.textAlign.indexOf('justify') !== -1,&#13;
          start = this.get2DCursorLocation(selectionStart),&#13;
          end = this.get2DCursorLocation(selectionEnd),&#13;
          startLine = start.lineIndex,&#13;
          endLine = end.lineIndex,&#13;
          startChar = start.charIndex &lt; 0 ? 0 : start.charIndex,&#13;
          endChar = end.charIndex &lt; 0 ? 0 : end.charIndex;&#13;
&#13;
      for (var i = startLine; i &lt;= endLine; i++) {&#13;
        var lineOffset = this._getLineLeftOffset(i) || 0,&#13;
            lineHeight = this.getHeightOfLine(i),&#13;
            realLineHeight = 0, boxStart = 0, boxEnd = 0;&#13;
&#13;
        if (i === startLine) {&#13;
          boxStart = this.__charBounds[startLine][startChar].left;&#13;
        }&#13;
        if (i &gt;= startLine &amp;&amp; i &lt; endLine) {&#13;
          boxEnd = isJustify &amp;&amp; !this.isEndOfWrapping(i) ? this.width : this.getLineWidth(i) || 5; // WTF is this 5?&#13;
        }&#13;
        else if (i === endLine) {&#13;
          if (endChar === 0) {&#13;
            boxEnd = this.__charBounds[endLine][endChar].left;&#13;
          }&#13;
          else {&#13;
            boxEnd = this.__charBounds[endLine][endChar - 1].left + this.__charBounds[endLine][endChar - 1].width;&#13;
          }&#13;
        }&#13;
        realLineHeight = lineHeight;&#13;
        if (this.lineHeight &lt; 1 || (i === endLine &amp;&amp; this.lineHeight &gt; 1)) {&#13;
          lineHeight /= this.lineHeight;&#13;
        }&#13;
        if (this.inCompositionMode) {&#13;
          ctx.fillStyle = this.compositionColor || 'black';&#13;
          ctx.fillRect(&#13;
            boundaries.left + lineOffset + boxStart,&#13;
            boundaries.top + boundaries.topOffset + lineHeight,&#13;
            boxEnd - boxStart,&#13;
            1);&#13;
        }&#13;
        else {&#13;
          ctx.fillStyle = this.selectionColor;&#13;
          ctx.fillRect(&#13;
            boundaries.left + lineOffset + boxStart,&#13;
            boundaries.top + boundaries.topOffset,&#13;
            boxEnd - boxStart,&#13;
            lineHeight);&#13;
        }&#13;
&#13;
&#13;
        boundaries.topOffset += realLineHeight;&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * High level function to know the height of the cursor.&#13;
     * the currentChar is the one that precedes the cursor&#13;
     * Returns fontSize of char at the current cursor&#13;
     * @return {Number} Character font size&#13;
     */&#13;
    getCurrentCharFontSize: function() {&#13;
      var cp = this._getCurrentCharIndex();&#13;
      return this.getValueOfPropertyAt(cp.l, cp.c, 'fontSize');&#13;
    },&#13;
&#13;
    /**&#13;
     * High level function to know the color of the cursor.&#13;
     * the currentChar is the one that precedes the cursor&#13;
     * Returns color (fill) of char at the current cursor&#13;
     * @return {String} Character color (fill)&#13;
     */&#13;
    getCurrentCharColor: function() {&#13;
      var cp = this._getCurrentCharIndex();&#13;
      return this.getValueOfPropertyAt(cp.l, cp.c, 'fill');&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns the cursor position for the getCurrent.. functions&#13;
     * @private&#13;
     */&#13;
    _getCurrentCharIndex: function() {&#13;
      var cursorPosition = this.get2DCursorLocation(this.selectionStart, true),&#13;
          charIndex = cursorPosition.charIndex &gt; 0 ? cursorPosition.charIndex - 1 : 0;&#13;
      return { l: cursorPosition.lineIndex, c: charIndex };&#13;
    }&#13;
  });&#13;
&#13;
  /**&#13;
   * Returns fabric.IText instance from an object representation&#13;
   * @static&#13;
   * @memberOf fabric.IText&#13;
   * @param {Object} object Object to create an instance from&#13;
   * @param {function} [callback] invoked with new instance as argument&#13;
   */&#13;
  fabric.IText.fromObject = function(object, callback) {&#13;
    parseDecoration(object);&#13;
    if (object.styles) {&#13;
      for (var i in object.styles) {&#13;
        for (var j in object.styles[i]) {&#13;
          parseDecoration(object.styles[i][j]);&#13;
        }&#13;
      }&#13;
    }&#13;
    fabric.Object._fromObject('IText', object, callback, 'text');&#13;
  };&#13;
})();&#13;
&#13;
&#13;
(function() {&#13;
&#13;
  var clone = fabric.util.object.clone;&#13;
&#13;
  fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {&#13;
&#13;
    /**&#13;
     * Initializes all the interactive behavior of IText&#13;
     */&#13;
    initBehavior: function() {&#13;
      this.initAddedHandler();&#13;
      this.initRemovedHandler();&#13;
      this.initCursorSelectionHandlers();&#13;
      this.initDoubleClickSimulation();&#13;
      this.mouseMoveHandler = this.mouseMoveHandler.bind(this);&#13;
    },&#13;
&#13;
    onDeselect: function(options) {&#13;
      this.isEditing &amp;&amp; this.exitEditing();&#13;
      this.selected = false;&#13;
      fabric.Object.prototype.onDeselect.call(this, options);&#13;
    },&#13;
&#13;
    /**&#13;
     * Initializes "added" event handler&#13;
     */&#13;
    initAddedHandler: function() {&#13;
      var _this = this;&#13;
      this.on('added', function() {&#13;
        var canvas = _this.canvas;&#13;
        if (canvas) {&#13;
          if (!canvas._hasITextHandlers) {&#13;
            canvas._hasITextHandlers = true;&#13;
            _this._initCanvasHandlers(canvas);&#13;
          }&#13;
          canvas._iTextInstances = canvas._iTextInstances || [];&#13;
          canvas._iTextInstances.push(_this);&#13;
        }&#13;
      });&#13;
    },&#13;
&#13;
    initRemovedHandler: function() {&#13;
      var _this = this;&#13;
      this.on('removed', function() {&#13;
        var canvas = _this.canvas;&#13;
        if (canvas) {&#13;
          canvas._iTextInstances = canvas._iTextInstances || [];&#13;
          fabric.util.removeFromArray(canvas._iTextInstances, _this);&#13;
          if (canvas._iTextInstances.length === 0) {&#13;
            canvas._hasITextHandlers = false;&#13;
            _this._removeCanvasHandlers(canvas);&#13;
          }&#13;
        }&#13;
      });&#13;
    },&#13;
&#13;
    /**&#13;
     * register canvas event to manage exiting on other instances&#13;
     * @private&#13;
     */&#13;
    _initCanvasHandlers: function(canvas) {&#13;
      canvas._mouseUpITextHandler = (function() {&#13;
        if (canvas._iTextInstances) {&#13;
          canvas._iTextInstances.forEach(function(obj) {&#13;
            obj.__isMousedown = false;&#13;
          });&#13;
        }&#13;
      }).bind(this);&#13;
      canvas.on('mouse:up', canvas._mouseUpITextHandler);&#13;
    },&#13;
&#13;
    /**&#13;
     * remove canvas event to manage exiting on other instances&#13;
     * @private&#13;
     */&#13;
    _removeCanvasHandlers: function(canvas) {&#13;
      canvas.off('mouse:up', canvas._mouseUpITextHandler);&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _tick: function() {&#13;
      this._currentTickState = this._animateCursor(this, 1, this.cursorDuration, '_onTickComplete');&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _animateCursor: function(obj, targetOpacity, duration, completeMethod) {&#13;
&#13;
      var tickState;&#13;
&#13;
      tickState = {&#13;
        isAborted: false,&#13;
        abort: function() {&#13;
          this.isAborted = true;&#13;
        },&#13;
      };&#13;
&#13;
      obj.animate('_currentCursorOpacity', targetOpacity, {&#13;
        duration: duration,&#13;
        onComplete: function() {&#13;
          if (!tickState.isAborted) {&#13;
            obj[completeMethod]();&#13;
          }&#13;
        },&#13;
        onChange: function() {&#13;
          // we do not want to animate a selection, only cursor&#13;
          if (obj.canvas &amp;&amp; obj.selectionStart === obj.selectionEnd) {&#13;
            obj.renderCursorOrSelection();&#13;
          }&#13;
        },&#13;
        abort: function() {&#13;
          return tickState.isAborted;&#13;
        }&#13;
      });&#13;
      return tickState;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _onTickComplete: function() {&#13;
&#13;
      var _this = this;&#13;
&#13;
      if (this._cursorTimeout1) {&#13;
        clearTimeout(this._cursorTimeout1);&#13;
      }&#13;
      this._cursorTimeout1 = setTimeout(function() {&#13;
        _this._currentTickCompleteState = _this._animateCursor(_this, 0, this.cursorDuration / 2, '_tick');&#13;
      }, 100);&#13;
    },&#13;
&#13;
    /**&#13;
     * Initializes delayed cursor&#13;
     */&#13;
    initDelayedCursor: function(restart) {&#13;
      var _this = this,&#13;
          delay = restart ? 0 : this.cursorDelay;&#13;
&#13;
      this.abortCursorAnimation();&#13;
      this._currentCursorOpacity = 1;&#13;
      this._cursorTimeout2 = setTimeout(function() {&#13;
        _this._tick();&#13;
      }, delay);&#13;
    },&#13;
&#13;
    /**&#13;
     * Aborts cursor animation and clears all timeouts&#13;
     */&#13;
    abortCursorAnimation: function() {&#13;
      var shouldClear = this._currentTickState || this._currentTickCompleteState,&#13;
          canvas = this.canvas;&#13;
      this._currentTickState &amp;&amp; this._currentTickState.abort();&#13;
      this._currentTickCompleteState &amp;&amp; this._currentTickCompleteState.abort();&#13;
&#13;
      clearTimeout(this._cursorTimeout1);&#13;
      clearTimeout(this._cursorTimeout2);&#13;
&#13;
      this._currentCursorOpacity = 0;&#13;
      // to clear just itext area we need to transform the context&#13;
      // it may not be worth it&#13;
      if (shouldClear &amp;&amp; canvas) {&#13;
        canvas.clearContext(canvas.contextTop || canvas.contextContainer);&#13;
      }&#13;
&#13;
    },&#13;
&#13;
    /**&#13;
     * Selects entire text&#13;
     * @return {fabric.IText} thisArg&#13;
     * @chainable&#13;
     */&#13;
    selectAll: function() {&#13;
      this.selectionStart = 0;&#13;
      this.selectionEnd = this._text.length;&#13;
      this._fireSelectionChanged();&#13;
      this._updateTextarea();&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns selected text&#13;
     * @return {String}&#13;
     */&#13;
    getSelectedText: function() {&#13;
      return this._text.slice(this.selectionStart, this.selectionEnd).join('');&#13;
    },&#13;
&#13;
    /**&#13;
     * Find new selection index representing start of current word according to current selection index&#13;
     * @param {Number} startFrom Surrent selection index&#13;
     * @return {Number} New selection index&#13;
     */&#13;
    findWordBoundaryLeft: function(startFrom) {&#13;
      var offset = 0, index = startFrom - 1;&#13;
&#13;
      // remove space before cursor first&#13;
      if (this._reSpace.test(this._text[index])) {&#13;
        while (this._reSpace.test(this._text[index])) {&#13;
          offset++;&#13;
          index--;&#13;
        }&#13;
      }&#13;
      while (/\S/.test(this._text[index]) &amp;&amp; index &gt; -1) {&#13;
        offset++;&#13;
        index--;&#13;
      }&#13;
&#13;
      return startFrom - offset;&#13;
    },&#13;
&#13;
    /**&#13;
     * Find new selection index representing end of current word according to current selection index&#13;
     * @param {Number} startFrom Current selection index&#13;
     * @return {Number} New selection index&#13;
     */&#13;
    findWordBoundaryRight: function(startFrom) {&#13;
      var offset = 0, index = startFrom;&#13;
&#13;
      // remove space after cursor first&#13;
      if (this._reSpace.test(this._text[index])) {&#13;
        while (this._reSpace.test(this._text[index])) {&#13;
          offset++;&#13;
          index++;&#13;
        }&#13;
      }&#13;
      while (/\S/.test(this._text[index]) &amp;&amp; index &lt; this.text.length) {&#13;
        offset++;&#13;
        index++;&#13;
      }&#13;
&#13;
      return startFrom + offset;&#13;
    },&#13;
&#13;
    /**&#13;
     * Find new selection index representing start of current line according to current selection index&#13;
     * @param {Number} startFrom Current selection index&#13;
     * @return {Number} New selection index&#13;
     */&#13;
    findLineBoundaryLeft: function(startFrom) {&#13;
      var offset = 0, index = startFrom - 1;&#13;
&#13;
      while (!/\n/.test(this._text[index]) &amp;&amp; index &gt; -1) {&#13;
        offset++;&#13;
        index--;&#13;
      }&#13;
&#13;
      return startFrom - offset;&#13;
    },&#13;
&#13;
    /**&#13;
     * Find new selection index representing end of current line according to current selection index&#13;
     * @param {Number} startFrom Current selection index&#13;
     * @return {Number} New selection index&#13;
     */&#13;
    findLineBoundaryRight: function(startFrom) {&#13;
      var offset = 0, index = startFrom;&#13;
&#13;
      while (!/\n/.test(this._text[index]) &amp;&amp; index &lt; this.text.length) {&#13;
        offset++;&#13;
        index++;&#13;
      }&#13;
&#13;
      return startFrom + offset;&#13;
    },&#13;
&#13;
    /**&#13;
     * Finds index corresponding to beginning or end of a word&#13;
     * @param {Number} selectionStart Index of a character&#13;
     * @param {Number} direction 1 or -1&#13;
     * @return {Number} Index of the beginning or end of a word&#13;
     */&#13;
    searchWordBoundary: function(selectionStart, direction) {&#13;
      var index     = this._reSpace.test(this.text.charAt(selectionStart)) ? selectionStart - 1 : selectionStart,&#13;
          _char     = this.text.charAt(index),&#13;
          reNonWord = /[ \n\.,;!\?\-]/;&#13;
&#13;
      while (!reNonWord.test(_char) &amp;&amp; index &gt; 0 &amp;&amp; index &lt; this.text.length) {&#13;
        index += direction;&#13;
        _char = this.text.charAt(index);&#13;
      }&#13;
      if (reNonWord.test(_char) &amp;&amp; _char !== '\n') {&#13;
        index += direction === 1 ? 0 : 1;&#13;
      }&#13;
      return index;&#13;
    },&#13;
&#13;
    /**&#13;
     * Selects a word based on the index&#13;
     * @param {Number} selectionStart Index of a character&#13;
     */&#13;
    selectWord: function(selectionStart) {&#13;
      selectionStart = selectionStart || this.selectionStart;&#13;
      var newSelectionStart = this.searchWordBoundary(selectionStart, -1), /* search backwards */&#13;
          newSelectionEnd = this.searchWordBoundary(selectionStart, 1); /* search forward */&#13;
&#13;
      this.selectionStart = newSelectionStart;&#13;
      this.selectionEnd = newSelectionEnd;&#13;
      this._fireSelectionChanged();&#13;
      this._updateTextarea();&#13;
      this.renderCursorOrSelection();&#13;
    },&#13;
&#13;
    /**&#13;
     * Selects a line based on the index&#13;
     * @param {Number} selectionStart Index of a character&#13;
     * @return {fabric.IText} thisArg&#13;
     * @chainable&#13;
     */&#13;
    selectLine: function(selectionStart) {&#13;
      selectionStart = selectionStart || this.selectionStart;&#13;
      var newSelectionStart = this.findLineBoundaryLeft(selectionStart),&#13;
          newSelectionEnd = this.findLineBoundaryRight(selectionStart);&#13;
&#13;
      this.selectionStart = newSelectionStart;&#13;
      this.selectionEnd = newSelectionEnd;&#13;
      this._fireSelectionChanged();&#13;
      this._updateTextarea();&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * Enters editing state&#13;
     * @return {fabric.IText} thisArg&#13;
     * @chainable&#13;
     */&#13;
    enterEditing: function(e) {&#13;
      if (this.isEditing || !this.editable) {&#13;
        return;&#13;
      }&#13;
&#13;
      if (this.canvas) {&#13;
        this.exitEditingOnOthers(this.canvas);&#13;
      }&#13;
&#13;
      this.isEditing = true;&#13;
&#13;
      this.initHiddenTextarea(e);&#13;
      this.hiddenTextarea.focus();&#13;
      this.hiddenTextarea.value = this.text;&#13;
      this._updateTextarea();&#13;
      this._saveEditingProps();&#13;
      this._setEditingProps();&#13;
      this._textBeforeEdit = this.text;&#13;
&#13;
      this._tick();&#13;
      this.fire('editing:entered');&#13;
      this._fireSelectionChanged();&#13;
      if (!this.canvas) {&#13;
        return this;&#13;
      }&#13;
      this.canvas.fire('text:editing:entered', { target: this });&#13;
      this.initMouseMoveHandler();&#13;
      this.canvas.requestRenderAll();&#13;
      return this;&#13;
    },&#13;
&#13;
    exitEditingOnOthers: function(canvas) {&#13;
      if (canvas._iTextInstances) {&#13;
        canvas._iTextInstances.forEach(function(obj) {&#13;
          obj.selected = false;&#13;
          if (obj.isEditing) {&#13;
            obj.exitEditing();&#13;
          }&#13;
        });&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Initializes "mousemove" event handler&#13;
     */&#13;
    initMouseMoveHandler: function() {&#13;
      this.canvas.on('mouse:move', this.mouseMoveHandler);&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    mouseMoveHandler: function(options) {&#13;
      if (!this.__isMousedown || !this.isEditing) {&#13;
        return;&#13;
      }&#13;
&#13;
      var newSelectionStart = this.getSelectionStartFromPointer(options.e),&#13;
          currentStart = this.selectionStart,&#13;
          currentEnd = this.selectionEnd;&#13;
      if (&#13;
        (newSelectionStart !== this.__selectionStartOnMouseDown || currentStart === currentEnd)&#13;
        &amp;&amp;&#13;
        (currentStart === newSelectionStart || currentEnd === newSelectionStart)&#13;
      ) {&#13;
        return;&#13;
      }&#13;
      if (newSelectionStart &gt; this.__selectionStartOnMouseDown) {&#13;
        this.selectionStart = this.__selectionStartOnMouseDown;&#13;
        this.selectionEnd = newSelectionStart;&#13;
      }&#13;
      else {&#13;
        this.selectionStart = newSelectionStart;&#13;
        this.selectionEnd = this.__selectionStartOnMouseDown;&#13;
      }&#13;
      if (this.selectionStart !== currentStart || this.selectionEnd !== currentEnd) {&#13;
        this.restartCursorIfNeeded();&#13;
        this._fireSelectionChanged();&#13;
        this._updateTextarea();&#13;
        this.renderCursorOrSelection();&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _setEditingProps: function() {&#13;
      this.hoverCursor = 'text';&#13;
&#13;
      if (this.canvas) {&#13;
        this.canvas.defaultCursor = this.canvas.moveCursor = 'text';&#13;
      }&#13;
&#13;
      this.borderColor = this.editingBorderColor;&#13;
&#13;
      this.hasControls = this.selectable = false;&#13;
      this.lockMovementX = this.lockMovementY = true;&#13;
    },&#13;
&#13;
    /**&#13;
     * convert from textarea to grapheme indexes&#13;
     */&#13;
    fromStringToGraphemeSelection: function(start, end, text) {&#13;
      var smallerTextStart = text.slice(0, start),&#13;
          graphemeStart = fabric.util.string.graphemeSplit(smallerTextStart).length;&#13;
      if (start === end) {&#13;
        return { selectionStart: graphemeStart, selectionEnd: graphemeStart };&#13;
      }&#13;
      var smallerTextEnd = text.slice(start, end),&#13;
          graphemeEnd = fabric.util.string.graphemeSplit(smallerTextEnd).length;&#13;
      return { selectionStart: graphemeStart, selectionEnd: graphemeStart + graphemeEnd };&#13;
    },&#13;
&#13;
    /**&#13;
     * convert from fabric to textarea values&#13;
     */&#13;
    fromGraphemeToStringSelection: function(start, end, _text) {&#13;
      var smallerTextStart = _text.slice(0, start),&#13;
          graphemeStart = smallerTextStart.join('').length;&#13;
      if (start === end) {&#13;
        return { selectionStart: graphemeStart, selectionEnd: graphemeStart };&#13;
      }&#13;
      var smallerTextEnd = _text.slice(start, end),&#13;
          graphemeEnd = smallerTextEnd.join('').length;&#13;
      return { selectionStart: graphemeStart, selectionEnd: graphemeStart + graphemeEnd };&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _updateTextarea: function() {&#13;
      this.cursorOffsetCache = { };&#13;
      if (!this.hiddenTextarea) {&#13;
        return;&#13;
      }&#13;
      if (!this.inCompositionMode) {&#13;
        var newSelection = this.fromGraphemeToStringSelection(this.selectionStart, this.selectionEnd, this._text);&#13;
        this.hiddenTextarea.selectionStart = newSelection.selectionStart;&#13;
        this.hiddenTextarea.selectionEnd = newSelection.selectionEnd;&#13;
      }&#13;
      this.updateTextareaPosition();&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    updateFromTextArea: function() {&#13;
      if (!this.hiddenTextarea) {&#13;
        return;&#13;
      }&#13;
      this.cursorOffsetCache = { };&#13;
      this.text = this.hiddenTextarea.value;&#13;
      if (this._shouldClearDimensionCache()) {&#13;
        this.initDimensions();&#13;
        this.setCoords();&#13;
      }&#13;
      var newSelection = this.fromStringToGraphemeSelection(&#13;
        this.hiddenTextarea.selectionStart, this.hiddenTextarea.selectionEnd, this.hiddenTextarea.value);&#13;
      this.selectionEnd = this.selectionStart = newSelection.selectionEnd;&#13;
      if (!this.inCompositionMode) {&#13;
        this.selectionStart = newSelection.selectionStart;&#13;
      }&#13;
      this.updateTextareaPosition();&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    updateTextareaPosition: function() {&#13;
      if (this.selectionStart === this.selectionEnd) {&#13;
        var style = this._calcTextareaPosition();&#13;
        this.hiddenTextarea.style.left = style.left;&#13;
        this.hiddenTextarea.style.top = style.top;&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @return {Object} style contains style for hiddenTextarea&#13;
     */&#13;
    _calcTextareaPosition: function() {&#13;
      if (!this.canvas) {&#13;
        return { x: 1, y: 1 };&#13;
      }&#13;
      var desiredPostion = this.inCompositionMode ? this.compositionStart : this.selectionStart,&#13;
          boundaries = this._getCursorBoundaries(desiredPostion),&#13;
          cursorLocation = this.get2DCursorLocation(desiredPostion),&#13;
          lineIndex = cursorLocation.lineIndex,&#13;
          charIndex = cursorLocation.charIndex,&#13;
          charHeight = this.getValueOfPropertyAt(lineIndex, charIndex, 'fontSize') * this.lineHeight,&#13;
          leftOffset = boundaries.leftOffset,&#13;
          m = this.calcTransformMatrix(),&#13;
          p = {&#13;
            x: boundaries.left + leftOffset,&#13;
            y: boundaries.top + boundaries.topOffset + charHeight&#13;
          },&#13;
          upperCanvas = this.canvas.upperCanvasEl,&#13;
          maxWidth = upperCanvas.width - charHeight,&#13;
          maxHeight = upperCanvas.height - charHeight;&#13;
&#13;
      p = fabric.util.transformPoint(p, m);&#13;
      p = fabric.util.transformPoint(p, this.canvas.viewportTransform);&#13;
      if (p.x &lt; 0) {&#13;
        p.x = 0;&#13;
      }&#13;
      if (p.x &gt; maxWidth) {&#13;
        p.x = maxWidth;&#13;
      }&#13;
      if (p.y &lt; 0) {&#13;
        p.y = 0;&#13;
      }&#13;
      if (p.y &gt; maxHeight) {&#13;
        p.y = maxHeight;&#13;
      }&#13;
&#13;
      // add canvas offset on document&#13;
      p.x += this.canvas._offset.left;&#13;
      p.y += this.canvas._offset.top;&#13;
&#13;
      return { left: p.x + 'px', top: p.y + 'px', fontSize: charHeight + 'px', charHeight: charHeight };&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _saveEditingProps: function() {&#13;
      this._savedProps = {&#13;
        hasControls: this.hasControls,&#13;
        borderColor: this.borderColor,&#13;
        lockMovementX: this.lockMovementX,&#13;
        lockMovementY: this.lockMovementY,&#13;
        hoverCursor: this.hoverCursor,&#13;
        defaultCursor: this.canvas &amp;&amp; this.canvas.defaultCursor,&#13;
        moveCursor: this.canvas &amp;&amp; this.canvas.moveCursor&#13;
      };&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _restoreEditingProps: function() {&#13;
      if (!this._savedProps) {&#13;
        return;&#13;
      }&#13;
&#13;
      this.hoverCursor = this._savedProps.hoverCursor;&#13;
      this.hasControls = this._savedProps.hasControls;&#13;
      this.borderColor = this._savedProps.borderColor;&#13;
      this.lockMovementX = this._savedProps.lockMovementX;&#13;
      this.lockMovementY = this._savedProps.lockMovementY;&#13;
&#13;
      if (this.canvas) {&#13;
        this.canvas.defaultCursor = this._savedProps.defaultCursor;&#13;
        this.canvas.moveCursor = this._savedProps.moveCursor;&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Exits from editing state&#13;
     * @return {fabric.IText} thisArg&#13;
     * @chainable&#13;
     */&#13;
    exitEditing: function() {&#13;
      var isTextChanged = (this._textBeforeEdit !== this.text);&#13;
      this.selected = false;&#13;
      this.isEditing = false;&#13;
      this.selectable = true;&#13;
&#13;
      this.selectionEnd = this.selectionStart;&#13;
&#13;
      if (this.hiddenTextarea) {&#13;
        this.hiddenTextarea.blur &amp;&amp; this.hiddenTextarea.blur();&#13;
        this.canvas &amp;&amp; this.hiddenTextarea.parentNode.removeChild(this.hiddenTextarea);&#13;
        this.hiddenTextarea = null;&#13;
      }&#13;
&#13;
      this.abortCursorAnimation();&#13;
      this._restoreEditingProps();&#13;
      this._currentCursorOpacity = 0;&#13;
      if (this._shouldClearDimensionCache()) {&#13;
        this.initDimensions();&#13;
        this.setCoords();&#13;
      }&#13;
      this.fire('editing:exited');&#13;
      isTextChanged &amp;&amp; this.fire('modified');&#13;
      if (this.canvas) {&#13;
        this.canvas.off('mouse:move', this.mouseMoveHandler);&#13;
        this.canvas.fire('text:editing:exited', { target: this });&#13;
        isTextChanged &amp;&amp; this.canvas.fire('object:modified', { target: this });&#13;
      }&#13;
      return this;&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _removeExtraneousStyles: function() {&#13;
      for (var prop in this.styles) {&#13;
        if (!this._textLines[prop]) {&#13;
          delete this.styles[prop];&#13;
        }&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * remove and reflow a style block from start to end.&#13;
     * @param {Number} start linear start position for removal (included in removal)&#13;
     * @param {Number} end linear end position for removal ( excluded from removal )&#13;
     */&#13;
    removeStyleFromTo: function(start, end) {&#13;
      var cursorStart = this.get2DCursorLocation(start, true),&#13;
          cursorEnd = this.get2DCursorLocation(end, true),&#13;
          lineStart = cursorStart.lineIndex,&#13;
          charStart = cursorStart.charIndex,&#13;
          lineEnd = cursorEnd.lineIndex,&#13;
          charEnd = cursorEnd.charIndex,&#13;
          i, styleObj;&#13;
      if (lineStart !== lineEnd) {&#13;
        // step1 remove the trailing of lineStart&#13;
        if (this.styles[lineStart]) {&#13;
          for (i = charStart; i &lt; this._unwrappedTextLines[lineStart].length; i++) {&#13;
            delete this.styles[lineStart][i];&#13;
          }&#13;
        }&#13;
        // step2 move the trailing of lineEnd to lineStart if needed&#13;
        if (this.styles[lineEnd]) {&#13;
          for (i = charEnd; i &lt; this._unwrappedTextLines[lineEnd].length; i++) {&#13;
            styleObj = this.styles[lineEnd][i];&#13;
            if (styleObj) {&#13;
              this.styles[lineStart] || (this.styles[lineStart] = { });&#13;
              this.styles[lineStart][charStart + i - charEnd] = styleObj;&#13;
            }&#13;
          }&#13;
        }&#13;
        // step3 detects lines will be completely removed.&#13;
        for (i = lineStart + 1; i &lt;= lineEnd; i++) {&#13;
          delete this.styles[i];&#13;
        }&#13;
        // step4 shift remaining lines.&#13;
        this.shiftLineStyles(lineEnd, lineStart - lineEnd);&#13;
      }&#13;
      else {&#13;
        // remove and shift left on the same line&#13;
        if (this.styles[lineStart]) {&#13;
          styleObj = this.styles[lineStart];&#13;
          var diff = charEnd - charStart, numericChar, _char;&#13;
          for (i = charStart; i &lt; charEnd; i++) {&#13;
            delete styleObj[i];&#13;
          }&#13;
          for (_char in this.styles[lineStart]) {&#13;
            numericChar = parseInt(_char, 10);&#13;
            if (numericChar &gt;= charEnd) {&#13;
              styleObj[numericChar - diff] = styleObj[_char];&#13;
              delete styleObj[_char];&#13;
            }&#13;
          }&#13;
        }&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Shifts line styles up or down&#13;
     * @param {Number} lineIndex Index of a line&#13;
     * @param {Number} offset Can any number?&#13;
     */&#13;
    shiftLineStyles: function(lineIndex, offset) {&#13;
      // shift all line styles by offset upward or downward&#13;
      // do not clone deep. we need new array, not new style objects&#13;
      var clonedStyles = clone(this.styles);&#13;
      for (var line in this.styles) {&#13;
        var numericLine = parseInt(line, 10);&#13;
        if (numericLine &gt; lineIndex) {&#13;
          this.styles[numericLine + offset] = clonedStyles[numericLine];&#13;
          if (!clonedStyles[numericLine - offset]) {&#13;
            delete this.styles[numericLine];&#13;
          }&#13;
        }&#13;
      }&#13;
    },&#13;
&#13;
    restartCursorIfNeeded: function() {&#13;
      if (!this._currentTickState || this._currentTickState.isAborted&#13;
        || !this._currentTickCompleteState || this._currentTickCompleteState.isAborted&#13;
      ) {&#13;
        this.initDelayedCursor();&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Inserts new style object&#13;
     * @param {Number} lineIndex Index of a line&#13;
     * @param {Number} charIndex Index of a char&#13;
     * @param {Number} qty number of lines to add&#13;
     * @param {Array} copiedStyle Array of objects styles&#13;
     */&#13;
    insertNewlineStyleObject: function(lineIndex, charIndex, qty, copiedStyle) {&#13;
      var currentCharStyle,&#13;
          newLineStyles = {},&#13;
          somethingAdded = false;&#13;
&#13;
      qty || (qty = 1);&#13;
      this.shiftLineStyles(lineIndex, qty);&#13;
      if (this.styles[lineIndex]) {&#13;
        currentCharStyle = this.styles[lineIndex][charIndex === 0 ? charIndex : charIndex - 1];&#13;
      }&#13;
&#13;
      // we clone styles of all chars&#13;
      // after cursor onto the current line&#13;
      for (var index in this.styles[lineIndex]) {&#13;
        var numIndex = parseInt(index, 10);&#13;
        if (numIndex &gt;= charIndex) {&#13;
          somethingAdded = true;&#13;
          newLineStyles[numIndex - charIndex] = this.styles[lineIndex][index];&#13;
          // remove lines from the previous line since they're on a new line now&#13;
          delete this.styles[lineIndex][index];&#13;
        }&#13;
      }&#13;
      if (somethingAdded) {&#13;
        this.styles[lineIndex + qty] = newLineStyles;&#13;
      }&#13;
      else {&#13;
        delete this.styles[lineIndex + qty];&#13;
      }&#13;
      // for the other lines&#13;
      // we clone current char style onto the next (otherwise empty) line&#13;
      while (qty &gt; 1) {&#13;
        qty--;&#13;
        if (copiedStyle &amp;&amp; copiedStyle[qty]) {&#13;
          this.styles[lineIndex + qty] = { 0: clone(copiedStyle[qty]) };&#13;
        }&#13;
        else if (currentCharStyle) {&#13;
          this.styles[lineIndex + qty] = { 0: clone(currentCharStyle) };&#13;
        }&#13;
        else {&#13;
          delete this.styles[lineIndex + qty];&#13;
        }&#13;
      }&#13;
      this._forceClearCache = true;&#13;
    },&#13;
&#13;
    /**&#13;
     * Inserts style object for a given line/char index&#13;
     * @param {Number} lineIndex Index of a line&#13;
     * @param {Number} charIndex Index of a char&#13;
     * @param {Number} quantity number Style object to insert, if given&#13;
     * @param {Array} copiedStyle array of style objecs&#13;
     */&#13;
    insertCharStyleObject: function(lineIndex, charIndex, quantity, copiedStyle) {&#13;
      if (!this.styles) {&#13;
        this.styles = {};&#13;
      }&#13;
      var currentLineStyles       = this.styles[lineIndex],&#13;
          currentLineStylesCloned = currentLineStyles ? clone(currentLineStyles) : {};&#13;
&#13;
      quantity || (quantity = 1);&#13;
      // shift all char styles by quantity forward&#13;
      // 0,1,2,3 -&gt; (charIndex=2) -&gt; 0,1,3,4 -&gt; (insert 2) -&gt; 0,1,2,3,4&#13;
      for (var index in currentLineStylesCloned) {&#13;
        var numericIndex = parseInt(index, 10);&#13;
        if (numericIndex &gt;= charIndex) {&#13;
          currentLineStyles[numericIndex + quantity] = currentLineStylesCloned[numericIndex];&#13;
          // only delete the style if there was nothing moved there&#13;
          if (!currentLineStylesCloned[numericIndex - quantity]) {&#13;
            delete currentLineStyles[numericIndex];&#13;
          }&#13;
        }&#13;
      }&#13;
      this._forceClearCache = true;&#13;
      if (copiedStyle) {&#13;
        while (quantity--) {&#13;
          if (!Object.keys(copiedStyle[quantity]).length) {&#13;
            continue;&#13;
          }&#13;
          if (!this.styles[lineIndex]) {&#13;
            this.styles[lineIndex] = {};&#13;
          }&#13;
          this.styles[lineIndex][charIndex + quantity] = clone(copiedStyle[quantity]);&#13;
        }&#13;
        return;&#13;
      }&#13;
      if (!currentLineStyles) {&#13;
        return;&#13;
      }&#13;
      var newStyle = currentLineStyles[charIndex ? charIndex - 1 : 1];&#13;
      while (newStyle &amp;&amp; quantity--) {&#13;
        this.styles[lineIndex][charIndex + quantity] = clone(newStyle);&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Inserts style object(s)&#13;
     * @param {Array} insertedText Characters at the location where style is inserted&#13;
     * @param {Number} start cursor index for inserting style&#13;
     * @param {Array} [copiedStyle] array of style objects to insert.&#13;
     */&#13;
    insertNewStyleBlock: function(insertedText, start, copiedStyle) {&#13;
      var cursorLoc = this.get2DCursorLocation(start, true),&#13;
          addedLines = [0], linesLenght = 0;&#13;
      for (var i = 0; i &lt; insertedText.length; i++) {&#13;
        if (insertedText[i] === '\n') {&#13;
          linesLenght++;&#13;
          addedLines[linesLenght] = 0;&#13;
        }&#13;
        else {&#13;
          addedLines[linesLenght]++;&#13;
        }&#13;
      }&#13;
      if (addedLines[0] &gt; 0) {&#13;
        this.insertCharStyleObject(cursorLoc.lineIndex, cursorLoc.charIndex, addedLines[0], copiedStyle);&#13;
        copiedStyle = copiedStyle &amp;&amp; copiedStyle.slice(addedLines[0] + 1);&#13;
      }&#13;
      linesLenght &amp;&amp; this.insertNewlineStyleObject(&#13;
        cursorLoc.lineIndex, cursorLoc.charIndex + addedLines[0], linesLenght);&#13;
      for (var i = 1; i &lt; linesLenght; i++) {&#13;
        if (addedLines[i] &gt; 0) {&#13;
          this.insertCharStyleObject(cursorLoc.lineIndex + i, 0, addedLines[i], copiedStyle);&#13;
        }&#13;
        else if (copiedStyle) {&#13;
          this.styles[cursorLoc.lineIndex + i][0] = copiedStyle[0];&#13;
        }&#13;
        copiedStyle = copiedStyle &amp;&amp; copiedStyle.slice(addedLines[i] + 1);&#13;
      }&#13;
      // we use i outside the loop to get it like linesLength&#13;
      if (addedLines[i] &gt; 0) {&#13;
        this.insertCharStyleObject(cursorLoc.lineIndex + i, 0, addedLines[i], copiedStyle);&#13;
      }&#13;
    },&#13;
&#13;
    /**&#13;
     * Set the selectionStart and selectionEnd according to the ne postion of cursor&#13;
     * mimic the key - mouse navigation when shift is pressed.&#13;
     */&#13;
    setSelectionStartEndWithShift: function(start, end, newSelection) {&#13;
      if (newSelection &lt;= start) {&#13;
        if (end === start) {&#13;
          this._selectionDirection = 'left';&#13;
        }&#13;
        else if (this._selectionDirection === 'right') {&#13;
          this._selectionDirection = 'left';&#13;
          this.selectionEnd = start;&#13;
        }&#13;
        this.selectionStart = newSelection;&#13;
      }&#13;
      else if (newSelection &gt; start &amp;&amp; newSelection &lt; end) {&#13;
        if (this._selectionDirection === 'right') {&#13;
          this.selectionEnd = newSelection;&#13;
        }&#13;
        else {&#13;
          this.selectionStart = newSelection;&#13;
        }&#13;
      }&#13;
      else {&#13;
        // newSelection is &gt; selection start and end&#13;
        if (end === start) {&#13;
          this._selectionDirection = 'right';&#13;
        }&#13;
        else if (this._selectionDirection === 'left') {&#13;
          this._selectionDirection = 'right';&#13;
          this.selectionStart = end;&#13;
        }&#13;
        this.selectionEnd = newSelection;&#13;
      }&#13;
    },&#13;
&#13;
    setSelectionInBoundaries: function() {&#13;
      var length = this.text.length;&#13;
      if (this.selectionStart &gt; length) {&#13;
        this.selectionStart = length;&#13;
      }&#13;
      else if (this.selectionStart &lt; 0) {&#13;
        this.selectionStart = 0;&#13;
      }&#13;
      if (this.selectionEnd &gt; length) {&#13;
        this.selectionEnd = length;&#13;
      }&#13;
      else if (this.selectionEnd &lt; 0) {&#13;
        this.selectionEnd = 0;&#13;
      }&#13;
    }&#13;
  });&#13;
})();&#13;
&#13;
&#13;
fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {&#13;
  /**&#13;
   * Initializes "dbclick" event handler&#13;
   */&#13;
  initDoubleClickSimulation: function() {&#13;
&#13;
    // for double click&#13;
    this.__lastClickTime = +new Date();&#13;
&#13;
    // for triple click&#13;
    this.__lastLastClickTime = +new Date();&#13;
&#13;
    this.__lastPointer = { };&#13;
&#13;
    this.on('mousedown', this.onMouseDown.bind(this));&#13;
  },&#13;
&#13;
  onMouseDown: function(options) {&#13;
&#13;
    this.__newClickTime = +new Date();&#13;
    var newPointer = this.canvas.getPointer(options.e);&#13;
&#13;
    if (this.isTripleClick(newPointer, options.e)) {&#13;
      this.fire('tripleclick', options);&#13;
      this._stopEvent(options.e);&#13;
    }&#13;
    this.__lastLastClickTime = this.__lastClickTime;&#13;
    this.__lastClickTime = this.__newClickTime;&#13;
    this.__lastPointer = newPointer;&#13;
    this.__lastIsEditing = this.isEditing;&#13;
    this.__lastSelected = this.selected;&#13;
  },&#13;
&#13;
  isTripleClick: function(newPointer) {&#13;
    return this.__newClickTime - this.__lastClickTime &lt; 500 &amp;&amp;&#13;
        this.__lastClickTime - this.__lastLastClickTime &lt; 500 &amp;&amp;&#13;
        this.__lastPointer.x === newPointer.x &amp;&amp;&#13;
        this.__lastPointer.y === newPointer.y;&#13;
  },&#13;
&#13;
  /**&#13;
   * @private&#13;
   */&#13;
  _stopEvent: function(e) {&#13;
    e.preventDefault &amp;&amp; e.preventDefault();&#13;
    e.stopPropagation &amp;&amp; e.stopPropagation();&#13;
  },&#13;
&#13;
  /**&#13;
   * Initializes event handlers related to cursor or selection&#13;
   */&#13;
  initCursorSelectionHandlers: function() {&#13;
    this.initMousedownHandler();&#13;
    this.initMouseupHandler();&#13;
    this.initClicks();&#13;
  },&#13;
&#13;
  /**&#13;
   * Initializes double and triple click event handlers&#13;
   */&#13;
  initClicks: function() {&#13;
    this.on('mousedblclick', function(options) {&#13;
      this.selectWord(this.getSelectionStartFromPointer(options.e));&#13;
    });&#13;
    this.on('tripleclick', function(options) {&#13;
      this.selectLine(this.getSelectionStartFromPointer(options.e));&#13;
    });&#13;
  },&#13;
&#13;
  /**&#13;
   * Initializes "mousedown" event handler&#13;
   */&#13;
  initMousedownHandler: function() {&#13;
    this.on('mousedown', function(options) {&#13;
      if (!this.editable || (options.e.button &amp;&amp; options.e.button !== 1)) {&#13;
        return;&#13;
      }&#13;
      var pointer = this.canvas.getPointer(options.e);&#13;
&#13;
      this.__mousedownX = pointer.x;&#13;
      this.__mousedownY = pointer.y;&#13;
      this.__isMousedown = true;&#13;
&#13;
      if (this.selected) {&#13;
        this.setCursorByClick(options.e);&#13;
      }&#13;
&#13;
      if (this.isEditing) {&#13;
        this.__selectionStartOnMouseDown = this.selectionStart;&#13;
        if (this.selectionStart === this.selectionEnd) {&#13;
          this.abortCursorAnimation();&#13;
        }&#13;
        this.renderCursorOrSelection();&#13;
      }&#13;
    });&#13;
  },&#13;
&#13;
  /**&#13;
   * @private&#13;
   */&#13;
  _isObjectMoved: function(e) {&#13;
    var pointer = this.canvas.getPointer(e);&#13;
&#13;
    return this.__mousedownX !== pointer.x ||&#13;
           this.__mousedownY !== pointer.y;&#13;
  },&#13;
&#13;
  /**&#13;
   * Initializes "mouseup" event handler&#13;
   */&#13;
  initMouseupHandler: function() {&#13;
    this.on('mouseup', function(options) {&#13;
      this.__isMousedown = false;&#13;
      if (!this.editable || this._isObjectMoved(options.e) || (options.e.button &amp;&amp; options.e.button !== 1)) {&#13;
        return;&#13;
      }&#13;
&#13;
      if (this.__lastSelected &amp;&amp; !this.__corner) {&#13;
        this.enterEditing(options.e);&#13;
        if (this.selectionStart === this.selectionEnd) {&#13;
          this.initDelayedCursor(true);&#13;
        }&#13;
        else {&#13;
          this.renderCursorOrSelection();&#13;
        }&#13;
      }&#13;
      this.selected = true;&#13;
    });&#13;
  },&#13;
&#13;
  /**&#13;
   * Changes cursor location in a text depending on passed pointer (x/y) object&#13;
   * @param {Event} e Event object&#13;
   */&#13;
  setCursorByClick: function(e) {&#13;
    var newSelection = this.getSelectionStartFromPointer(e),&#13;
        start = this.selectionStart, end = this.selectionEnd;&#13;
    if (e.shiftKey) {&#13;
      this.setSelectionStartEndWithShift(start, end, newSelection);&#13;
    }&#13;
    else {&#13;
      this.selectionStart = newSelection;&#13;
      this.selectionEnd = newSelection;&#13;
    }&#13;
    if (this.isEditing) {&#13;
      this._fireSelectionChanged();&#13;
      this._updateTextarea();&#13;
    }&#13;
  },&#13;
&#13;
  /**&#13;
   * Returns index of a character corresponding to where an object was clicked&#13;
   * @param {Event} e Event object&#13;
   * @return {Number} Index of a character&#13;
   */&#13;
  getSelectionStartFromPointer: function(e) {&#13;
    var mouseOffset = this.getLocalPointer(e),&#13;
        prevWidth = 0,&#13;
        width = 0,&#13;
        height = 0,&#13;
        charIndex = 0,&#13;
        lineIndex = 0,&#13;
        lineLeftOffset,&#13;
        line;&#13;
&#13;
    for (var i = 0, len = this._textLines.length; i &lt; len; i++) {&#13;
      if (height &lt;= mouseOffset.y) {&#13;
        height += this.getHeightOfLine(i) * this.scaleY;&#13;
        lineIndex = i;&#13;
        if (i &gt; 0) {&#13;
          charIndex += this._textLines[i - 1].length + 1;&#13;
        }&#13;
      }&#13;
      else {&#13;
        break;&#13;
      }&#13;
    }&#13;
    lineLeftOffset = this._getLineLeftOffset(lineIndex);&#13;
    width = lineLeftOffset * this.scaleX;&#13;
    line = this._textLines[lineIndex];&#13;
    for (var j = 0, jlen = line.length; j &lt; jlen; j++) {&#13;
      prevWidth = width;&#13;
      // i removed something about flipX here, check.&#13;
      width += this.__charBounds[lineIndex][j].kernedWidth * this.scaleX;&#13;
      if (width &lt;= mouseOffset.x) {&#13;
        charIndex++;&#13;
      }&#13;
      else {&#13;
        break;&#13;
      }&#13;
    }&#13;
    return this._getNewSelectionStartFromOffset(mouseOffset, prevWidth, width, charIndex, jlen);&#13;
  },&#13;
&#13;
  /**&#13;
   * @private&#13;
   */&#13;
  _getNewSelectionStartFromOffset: function(mouseOffset, prevWidth, width, index, jlen) {&#13;
    // we need Math.abs because when width is after the last char, the offset is given as 1, while is 0&#13;
    var distanceBtwLastCharAndCursor = mouseOffset.x - prevWidth,&#13;
        distanceBtwNextCharAndCursor = width - mouseOffset.x,&#13;
        offset = distanceBtwNextCharAndCursor &gt; distanceBtwLastCharAndCursor ||&#13;
          distanceBtwNextCharAndCursor &lt; 0 ? 0 : 1,&#13;
        newSelectionStart = index + offset;&#13;
    // if object is horizontally flipped, mirror cursor location from the end&#13;
    if (this.flipX) {&#13;
      newSelectionStart = jlen - newSelectionStart;&#13;
    }&#13;
&#13;
    if (newSelectionStart &gt; this._text.length) {&#13;
      newSelectionStart = this._text.length;&#13;
    }&#13;
&#13;
    return newSelectionStart;&#13;
  }&#13;
});&#13;
&#13;
&#13;
fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {&#13;
&#13;
  /**&#13;
   * Initializes hidden textarea (needed to bring up keyboard in iOS)&#13;
   */&#13;
  initHiddenTextarea: function() {&#13;
    this.hiddenTextarea = fabric.document.createElement('textarea');&#13;
    this.hiddenTextarea.setAttribute('autocapitalize', 'off');&#13;
    this.hiddenTextarea.setAttribute('autocorrect', 'off');&#13;
    this.hiddenTextarea.setAttribute('autocomplete', 'off');&#13;
    this.hiddenTextarea.setAttribute('spellcheck', 'false');&#13;
    this.hiddenTextarea.setAttribute('data-fabric-hiddentextarea', '');&#13;
    this.hiddenTextarea.setAttribute('wrap', 'off');&#13;
    var style = this._calcTextareaPosition();&#13;
    this.hiddenTextarea.style.cssText = 'position: absolute; top: ' + style.top +&#13;
    '; left: ' + style.left + '; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px;' +&#13;
    ' line-height: 1px; paddingtop: ' + style.fontSize + ';';&#13;
    fabric.document.body.appendChild(this.hiddenTextarea);&#13;
&#13;
    fabric.util.addListener(this.hiddenTextarea, 'keydown', this.onKeyDown.bind(this));&#13;
    fabric.util.addListener(this.hiddenTextarea, 'keyup', this.onKeyUp.bind(this));&#13;
    fabric.util.addListener(this.hiddenTextarea, 'input', this.onInput.bind(this));&#13;
    fabric.util.addListener(this.hiddenTextarea, 'copy', this.copy.bind(this));&#13;
    fabric.util.addListener(this.hiddenTextarea, 'cut', this.copy.bind(this));&#13;
    fabric.util.addListener(this.hiddenTextarea, 'paste', this.paste.bind(this));&#13;
    fabric.util.addListener(this.hiddenTextarea, 'compositionstart', this.onCompositionStart.bind(this));&#13;
    fabric.util.addListener(this.hiddenTextarea, 'compositionupdate', this.onCompositionUpdate.bind(this));&#13;
    fabric.util.addListener(this.hiddenTextarea, 'compositionend', this.onCompositionEnd.bind(this));&#13;
&#13;
    if (!this._clickHandlerInitialized &amp;&amp; this.canvas) {&#13;
      fabric.util.addListener(this.canvas.upperCanvasEl, 'click', this.onClick.bind(this));&#13;
      this._clickHandlerInitialized = true;&#13;
    }&#13;
  },&#13;
&#13;
  /**&#13;
   * For functionalities on keyDown&#13;
   * Map a special key to a function of the instance/prototype&#13;
   * If you need different behaviour for ESC or TAB or arrows, you have to change&#13;
   * this map setting the name of a function that you build on the fabric.Itext or&#13;
   * your prototype.&#13;
   * the map change will affect all Instances unless you need for only some text Instances&#13;
   * in that case you have to clone this object and assign your Instance.&#13;
   * this.keysMap = fabric.util.object.clone(this.keysMap);&#13;
   * The function must be in fabric.Itext.prototype.myFunction And will receive event as args[0]&#13;
   */&#13;
  keysMap: {&#13;
    9:  'exitEditing',&#13;
    27: 'exitEditing',&#13;
    33: 'moveCursorUp',&#13;
    34: 'moveCursorDown',&#13;
    35: 'moveCursorRight',&#13;
    36: 'moveCursorLeft',&#13;
    37: 'moveCursorLeft',&#13;
    38: 'moveCursorUp',&#13;
    39: 'moveCursorRight',&#13;
    40: 'moveCursorDown',&#13;
  },&#13;
&#13;
  /**&#13;
   * For functionalities on keyUp + ctrl || cmd&#13;
   */&#13;
  ctrlKeysMapUp: {&#13;
    67: 'copy',&#13;
    88: 'cut'&#13;
  },&#13;
&#13;
  /**&#13;
   * For functionalities on keyDown + ctrl || cmd&#13;
   */&#13;
  ctrlKeysMapDown: {&#13;
    65: 'selectAll'&#13;
  },&#13;
&#13;
  onClick: function() {&#13;
    // No need to trigger click event here, focus is enough to have the keyboard appear on Android&#13;
    this.hiddenTextarea &amp;&amp; this.hiddenTextarea.focus();&#13;
  },&#13;
&#13;
  /**&#13;
   * Handles keyup event&#13;
   * @param {Event} e Event object&#13;
   */&#13;
  onKeyDown: function(e) {&#13;
    if (!this.isEditing || this.inCompositionMode) {&#13;
      return;&#13;
    }&#13;
    if (e.keyCode in this.keysMap) {&#13;
      this[this.keysMap[e.keyCode]](e);&#13;
    }&#13;
    else if ((e.keyCode in this.ctrlKeysMapDown) &amp;&amp; (e.ctrlKey || e.metaKey)) {&#13;
      this[this.ctrlKeysMapDown[e.keyCode]](e);&#13;
    }&#13;
    else {&#13;
      return;&#13;
    }&#13;
    e.stopImmediatePropagation();&#13;
    e.preventDefault();&#13;
    if (e.keyCode &gt;= 33 &amp;&amp; e.keyCode &lt;= 40) {&#13;
      // if i press an arrow key just update selection&#13;
      this.clearContextTop();&#13;
      this.renderCursorOrSelection();&#13;
    }&#13;
    else {&#13;
      this.canvas &amp;&amp; this.canvas.requestRenderAll();&#13;
    }&#13;
  },&#13;
&#13;
  /**&#13;
   * Handles keyup event&#13;
   * We handle KeyUp because ie11 and edge have difficulties copy/pasting&#13;
   * if a copy/cut event fired, keyup is dismissed&#13;
   * @param {Event} e Event object&#13;
   */&#13;
  onKeyUp: function(e) {&#13;
    if (!this.isEditing || this._copyDone || this.inCompositionMode) {&#13;
      this._copyDone = false;&#13;
      return;&#13;
    }&#13;
    if ((e.keyCode in this.ctrlKeysMapUp) &amp;&amp; (e.ctrlKey || e.metaKey)) {&#13;
      this[this.ctrlKeysMapUp[e.keyCode]](e);&#13;
    }&#13;
    else {&#13;
      return;&#13;
    }&#13;
    e.stopImmediatePropagation();&#13;
    e.preventDefault();&#13;
    this.canvas &amp;&amp; this.canvas.requestRenderAll();&#13;
  },&#13;
&#13;
  /**&#13;
   * Handles onInput event&#13;
   * @param {Event} e Event object&#13;
   */&#13;
  onInput: function(e) {&#13;
    var fromPaste = this.fromPaste;&#13;
    this.fromPaste = false;&#13;
    e &amp;&amp; e.stopPropagation();&#13;
    if (!this.isEditing) {&#13;
      return;&#13;
    }&#13;
    // decisions about style changes.&#13;
    var nextText = this._splitTextIntoLines(this.hiddenTextarea.value).graphemeText,&#13;
        charCount = this._text.length,&#13;
        nextCharCount = nextText.length,&#13;
        removedText, insertedText,&#13;
        charDiff = nextCharCount - charCount;&#13;
    if (this.hiddenTextarea.value === '') {&#13;
      this.styles = { };&#13;
      this.updateFromTextArea();&#13;
      this.fire('changed');&#13;
      if (this.canvas) {&#13;
        this.canvas.fire('text:changed', { target: this });&#13;
        this.canvas.requestRenderAll();&#13;
      }&#13;
      return;&#13;
    }&#13;
&#13;
    var textareaSelection = this.fromStringToGraphemeSelection(&#13;
      this.hiddenTextarea.selectionStart,&#13;
      this.hiddenTextarea.selectionEnd,&#13;
      this.hiddenTextarea.value&#13;
    );&#13;
    var backDelete = this.selectionStart &gt; textareaSelection.selectionStart;&#13;
&#13;
    if (this.selectionStart !== this.selectionEnd) {&#13;
      removedText = this._text.slice(this.selectionStart, this.selectionEnd);&#13;
      charDiff += this.selectionEnd - this.selectionStart;&#13;
    }&#13;
    else if (nextCharCount &lt; charCount) {&#13;
      if (backDelete) {&#13;
        removedText = this._text.slice(this.selectionEnd + charDiff, this.selectionEnd);&#13;
      }&#13;
      else {&#13;
        removedText = this._text.slice(this.selectionStart, this.selectionStart - charDiff);&#13;
      }&#13;
    }&#13;
    insertedText = nextText.slice(textareaSelection.selectionEnd - charDiff, textareaSelection.selectionEnd);&#13;
    if (removedText &amp;&amp; removedText.length) {&#13;
      if (this.selectionStart !== this.selectionEnd) {&#13;
        this.removeStyleFromTo(this.selectionStart, this.selectionEnd);&#13;
      }&#13;
      else if (backDelete) {&#13;
        // detect differencies between forwardDelete and backDelete&#13;
        this.removeStyleFromTo(this.selectionEnd - removedText.length, this.selectionEnd);&#13;
      }&#13;
      else {&#13;
        this.removeStyleFromTo(this.selectionEnd, this.selectionEnd + removedText.length);&#13;
      }&#13;
    }&#13;
    if (insertedText.length) {&#13;
      if (fromPaste &amp;&amp; insertedText.join('') === fabric.copiedText) {&#13;
        this.insertNewStyleBlock(insertedText, this.selectionStart, fabric.copiedTextStyle);&#13;
      }&#13;
      else {&#13;
        this.insertNewStyleBlock(insertedText, this.selectionStart);&#13;
      }&#13;
    }&#13;
    this.updateFromTextArea();&#13;
    this.fire('changed');&#13;
    if (this.canvas) {&#13;
      this.canvas.fire('text:changed', { target: this });&#13;
      this.canvas.requestRenderAll();&#13;
    }&#13;
  },&#13;
  /**&#13;
   * Composition start&#13;
   */&#13;
  onCompositionStart: function() {&#13;
    this.inCompositionMode = true;&#13;
  },&#13;
&#13;
  /**&#13;
   * Composition end&#13;
   */&#13;
  onCompositionEnd: function() {&#13;
    this.inCompositionMode = false;&#13;
  },&#13;
&#13;
  // /**&#13;
  //  * Composition update&#13;
  //  */&#13;
  onCompositionUpdate: function(e) {&#13;
    this.compositionStart = e.target.selectionStart;&#13;
    this.compositionEnd = e.target.selectionEnd;&#13;
    this.updateTextareaPosition();&#13;
  },&#13;
&#13;
  /**&#13;
   * Copies selected text&#13;
   * @param {Event} e Event object&#13;
   */&#13;
  copy: function() {&#13;
    if (this.selectionStart === this.selectionEnd) {&#13;
      //do not cut-copy if no selection&#13;
      return;&#13;
    }&#13;
&#13;
    fabric.copiedText = this.getSelectedText();&#13;
    fabric.copiedTextStyle = this.getSelectionStyles(this.selectionStart, this.selectionEnd, true);&#13;
    this._copyDone = true;&#13;
  },&#13;
&#13;
  /**&#13;
   * Pastes text&#13;
   * @param {Event} e Event object&#13;
   */&#13;
  paste: function() {&#13;
    this.fromPaste = true;&#13;
  },&#13;
&#13;
  /**&#13;
   * @private&#13;
   * @param {Event} e Event object&#13;
   * @return {Object} Clipboard data object&#13;
   */&#13;
  _getClipboardData: function(e) {&#13;
    return (e &amp;&amp; e.clipboardData) || fabric.window.clipboardData;&#13;
  },&#13;
&#13;
  /**&#13;
   * Finds the width in pixels before the cursor on the same line&#13;
   * @private&#13;
   * @param {Number} lineIndex&#13;
   * @param {Number} charIndex&#13;
   * @return {Number} widthBeforeCursor width before cursor&#13;
   */&#13;
  _getWidthBeforeCursor: function(lineIndex, charIndex) {&#13;
    var widthBeforeCursor = this._getLineLeftOffset(lineIndex), bound;&#13;
&#13;
    if (charIndex &gt; 0) {&#13;
      bound = this.__charBounds[lineIndex][charIndex - 1];&#13;
      widthBeforeCursor += bound.left + bound.width;&#13;
    }&#13;
    return widthBeforeCursor;&#13;
  },&#13;
&#13;
  /**&#13;
   * Gets start offset of a selection&#13;
   * @param {Event} e Event object&#13;
   * @param {Boolean} isRight&#13;
   * @return {Number}&#13;
   */&#13;
  getDownCursorOffset: function(e, isRight) {&#13;
    var selectionProp = this._getSelectionForOffset(e, isRight),&#13;
        cursorLocation = this.get2DCursorLocation(selectionProp),&#13;
        lineIndex = cursorLocation.lineIndex;&#13;
    // if on last line, down cursor goes to end of line&#13;
    if (lineIndex === this._textLines.length - 1 || e.metaKey || e.keyCode === 34) {&#13;
      // move to the end of a text&#13;
      return this._text.length - selectionProp;&#13;
    }&#13;
    var charIndex = cursorLocation.charIndex,&#13;
        widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex),&#13;
        indexOnOtherLine = this._getIndexOnLine(lineIndex + 1, widthBeforeCursor),&#13;
        textAfterCursor = this._textLines[lineIndex].slice(charIndex);&#13;
    return textAfterCursor.length + indexOnOtherLine + 2;&#13;
  },&#13;
&#13;
  /**&#13;
   * private&#13;
   * Helps finding if the offset should be counted from Start or End&#13;
   * @param {Event} e Event object&#13;
   * @param {Boolean} isRight&#13;
   * @return {Number}&#13;
   */&#13;
  _getSelectionForOffset: function(e, isRight) {&#13;
    if (e.shiftKey &amp;&amp; this.selectionStart !== this.selectionEnd &amp;&amp; isRight) {&#13;
      return this.selectionEnd;&#13;
    }&#13;
    else {&#13;
      return this.selectionStart;&#13;
    }&#13;
  },&#13;
&#13;
  /**&#13;
   * @param {Event} e Event object&#13;
   * @param {Boolean} isRight&#13;
   * @return {Number}&#13;
   */&#13;
  getUpCursorOffset: function(e, isRight) {&#13;
    var selectionProp = this._getSelectionForOffset(e, isRight),&#13;
        cursorLocation = this.get2DCursorLocation(selectionProp),&#13;
        lineIndex = cursorLocation.lineIndex;&#13;
    if (lineIndex === 0 || e.metaKey || e.keyCode === 33) {&#13;
      // if on first line, up cursor goes to start of line&#13;
      return -selectionProp;&#13;
    }&#13;
    var charIndex = cursorLocation.charIndex,&#13;
        widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex),&#13;
        indexOnOtherLine = this._getIndexOnLine(lineIndex - 1, widthBeforeCursor),&#13;
        textBeforeCursor = this._textLines[lineIndex].slice(0, charIndex);&#13;
    // return a negative offset&#13;
    return -this._textLines[lineIndex - 1].length + indexOnOtherLine - textBeforeCursor.length;&#13;
  },&#13;
&#13;
  /**&#13;
   * for a given width it founds the matching character.&#13;
   * @private&#13;
   */&#13;
  _getIndexOnLine: function(lineIndex, width) {&#13;
&#13;
    var line = this._textLines[lineIndex],&#13;
        lineLeftOffset = this._getLineLeftOffset(lineIndex),&#13;
        widthOfCharsOnLine = lineLeftOffset,&#13;
        indexOnLine = 0, charWidth, foundMatch;&#13;
&#13;
    for (var j = 0, jlen = line.length; j &lt; jlen; j++) {&#13;
      charWidth = this.__charBounds[lineIndex][j].width;&#13;
      widthOfCharsOnLine += charWidth;&#13;
      if (widthOfCharsOnLine &gt; width) {&#13;
        foundMatch = true;&#13;
        var leftEdge = widthOfCharsOnLine - charWidth,&#13;
            rightEdge = widthOfCharsOnLine,&#13;
            offsetFromLeftEdge = Math.abs(leftEdge - width),&#13;
            offsetFromRightEdge = Math.abs(rightEdge - width);&#13;
&#13;
        indexOnLine = offsetFromRightEdge &lt; offsetFromLeftEdge ? j : (j - 1);&#13;
        break;&#13;
      }&#13;
    }&#13;
&#13;
    // reached end&#13;
    if (!foundMatch) {&#13;
      indexOnLine = line.length - 1;&#13;
    }&#13;
&#13;
    return indexOnLine;&#13;
  },&#13;
&#13;
&#13;
  /**&#13;
   * Moves cursor down&#13;
   * @param {Event} e Event object&#13;
   */&#13;
  moveCursorDown: function(e) {&#13;
    if (this.selectionStart &gt;= this._text.length &amp;&amp; this.selectionEnd &gt;= this._text.length) {&#13;
      return;&#13;
    }&#13;
    this._moveCursorUpOrDown('Down', e);&#13;
  },&#13;
&#13;
  /**&#13;
   * Moves cursor up&#13;
   * @param {Event} e Event object&#13;
   */&#13;
  moveCursorUp: function(e) {&#13;
    if (this.selectionStart === 0 &amp;&amp; this.selectionEnd === 0) {&#13;
      return;&#13;
    }&#13;
    this._moveCursorUpOrDown('Up', e);&#13;
  },&#13;
&#13;
  /**&#13;
   * Moves cursor up or down, fires the events&#13;
   * @param {String} direction 'Up' or 'Down'&#13;
   * @param {Event} e Event object&#13;
   */&#13;
  _moveCursorUpOrDown: function(direction, e) {&#13;
    // getUpCursorOffset&#13;
    // getDownCursorOffset&#13;
    var action = 'get' + direction + 'CursorOffset',&#13;
        offset = this[action](e, this._selectionDirection === 'right');&#13;
    if (e.shiftKey) {&#13;
      this.moveCursorWithShift(offset);&#13;
    }&#13;
    else {&#13;
      this.moveCursorWithoutShift(offset);&#13;
    }&#13;
    if (offset !== 0) {&#13;
      this.setSelectionInBoundaries();&#13;
      this.abortCursorAnimation();&#13;
      this._currentCursorOpacity = 1;&#13;
      this.initDelayedCursor();&#13;
      this._fireSelectionChanged();&#13;
      this._updateTextarea();&#13;
    }&#13;
  },&#13;
&#13;
  /**&#13;
   * Moves cursor with shift&#13;
   * @param {Number} offset&#13;
   */&#13;
  moveCursorWithShift: function(offset) {&#13;
    var newSelection = this._selectionDirection === 'left'&#13;
      ? this.selectionStart + offset&#13;
      : this.selectionEnd + offset;&#13;
    this.setSelectionStartEndWithShift(this.selectionStart, this.selectionEnd, newSelection);&#13;
    return offset !== 0;&#13;
  },&#13;
&#13;
  /**&#13;
   * Moves cursor up without shift&#13;
   * @param {Number} offset&#13;
   */&#13;
  moveCursorWithoutShift: function(offset) {&#13;
    if (offset &lt; 0) {&#13;
      this.selectionStart += offset;&#13;
      this.selectionEnd = this.selectionStart;&#13;
    }&#13;
    else {&#13;
      this.selectionEnd += offset;&#13;
      this.selectionStart = this.selectionEnd;&#13;
    }&#13;
    return offset !== 0;&#13;
  },&#13;
&#13;
  /**&#13;
   * Moves cursor left&#13;
   * @param {Event} e Event object&#13;
   */&#13;
  moveCursorLeft: function(e) {&#13;
    if (this.selectionStart === 0 &amp;&amp; this.selectionEnd === 0) {&#13;
      return;&#13;
    }&#13;
    this._moveCursorLeftOrRight('Left', e);&#13;
  },&#13;
&#13;
  /**&#13;
   * @private&#13;
   * @return {Boolean} true if a change happened&#13;
   */&#13;
  _move: function(e, prop, direction) {&#13;
    var newValue;&#13;
    if (e.altKey) {&#13;
      newValue = this['findWordBoundary' + direction](this[prop]);&#13;
    }&#13;
    else if (e.metaKey || e.keyCode === 35 ||  e.keyCode === 36 ) {&#13;
      newValue = this['findLineBoundary' + direction](this[prop]);&#13;
    }&#13;
    else {&#13;
      this[prop] += direction === 'Left' ? -1 : 1;&#13;
      return true;&#13;
    }&#13;
    if (typeof newValue !== undefined &amp;&amp; this[prop] !== newValue) {&#13;
      this[prop] = newValue;&#13;
      return true;&#13;
    }&#13;
  },&#13;
&#13;
  /**&#13;
   * @private&#13;
   */&#13;
  _moveLeft: function(e, prop) {&#13;
    return this._move(e, prop, 'Left');&#13;
  },&#13;
&#13;
  /**&#13;
   * @private&#13;
   */&#13;
  _moveRight: function(e, prop) {&#13;
    return this._move(e, prop, 'Right');&#13;
  },&#13;
&#13;
  /**&#13;
   * Moves cursor left without keeping selection&#13;
   * @param {Event} e&#13;
   */&#13;
  moveCursorLeftWithoutShift: function(e) {&#13;
    var change = true;&#13;
    this._selectionDirection = 'left';&#13;
&#13;
    // only move cursor when there is no selection,&#13;
    // otherwise we discard it, and leave cursor on same place&#13;
    if (this.selectionEnd === this.selectionStart &amp;&amp; this.selectionStart !== 0) {&#13;
      change = this._moveLeft(e, 'selectionStart');&#13;
&#13;
    }&#13;
    this.selectionEnd = this.selectionStart;&#13;
    return change;&#13;
  },&#13;
&#13;
  /**&#13;
   * Moves cursor left while keeping selection&#13;
   * @param {Event} e&#13;
   */&#13;
  moveCursorLeftWithShift: function(e) {&#13;
    if (this._selectionDirection === 'right' &amp;&amp; this.selectionStart !== this.selectionEnd) {&#13;
      return this._moveLeft(e, 'selectionEnd');&#13;
    }&#13;
    else if (this.selectionStart !== 0){&#13;
      this._selectionDirection = 'left';&#13;
      return this._moveLeft(e, 'selectionStart');&#13;
    }&#13;
  },&#13;
&#13;
  /**&#13;
   * Moves cursor right&#13;
   * @param {Event} e Event object&#13;
   */&#13;
  moveCursorRight: function(e) {&#13;
    if (this.selectionStart &gt;= this._text.length &amp;&amp; this.selectionEnd &gt;= this._text.length) {&#13;
      return;&#13;
    }&#13;
    this._moveCursorLeftOrRight('Right', e);&#13;
  },&#13;
&#13;
  /**&#13;
   * Moves cursor right or Left, fires event&#13;
   * @param {String} direction 'Left', 'Right'&#13;
   * @param {Event} e Event object&#13;
   */&#13;
  _moveCursorLeftOrRight: function(direction, e) {&#13;
    var actionName = 'moveCursor' + direction + 'With';&#13;
    this._currentCursorOpacity = 1;&#13;
&#13;
    if (e.shiftKey) {&#13;
      actionName += 'Shift';&#13;
    }&#13;
    else {&#13;
      actionName += 'outShift';&#13;
    }&#13;
    if (this[actionName](e)) {&#13;
      this.abortCursorAnimation();&#13;
      this.initDelayedCursor();&#13;
      this._fireSelectionChanged();&#13;
      this._updateTextarea();&#13;
    }&#13;
  },&#13;
&#13;
  /**&#13;
   * Moves cursor right while keeping selection&#13;
   * @param {Event} e&#13;
   */&#13;
  moveCursorRightWithShift: function(e) {&#13;
    if (this._selectionDirection === 'left' &amp;&amp; this.selectionStart !== this.selectionEnd) {&#13;
      return this._moveRight(e, 'selectionStart');&#13;
    }&#13;
    else if (this.selectionEnd !== this._text.length) {&#13;
      this._selectionDirection = 'right';&#13;
      return this._moveRight(e, 'selectionEnd');&#13;
    }&#13;
  },&#13;
&#13;
  /**&#13;
   * Moves cursor right without keeping selection&#13;
   * @param {Event} e Event object&#13;
   */&#13;
  moveCursorRightWithoutShift: function(e) {&#13;
    var changed = true;&#13;
    this._selectionDirection = 'right';&#13;
&#13;
    if (this.selectionStart === this.selectionEnd) {&#13;
      changed = this._moveRight(e, 'selectionStart');&#13;
      this.selectionEnd = this.selectionStart;&#13;
    }&#13;
    else {&#13;
      this.selectionStart = this.selectionEnd;&#13;
    }&#13;
    return changed;&#13;
  },&#13;
&#13;
  /**&#13;
   * Removes characters from start/end&#13;
   * start/end ar per grapheme position in _text array.&#13;
   *&#13;
   * @param {Number} start&#13;
   * @param {Number} end default to start + 1&#13;
   */&#13;
  removeChars: function(start, end) {&#13;
    if (typeof end === 'undefined') {&#13;
      end = start + 1;&#13;
    }&#13;
    this.removeStyleFromTo(start, end);&#13;
    this._text.splice(start, end - start);&#13;
    this.text = this._text.join('');&#13;
    this.set('dirty', true);&#13;
    if (this._shouldClearDimensionCache()) {&#13;
      this.initDimensions();&#13;
      this.setCoords();&#13;
    }&#13;
    this._removeExtraneousStyles();&#13;
  },&#13;
&#13;
  /**&#13;
   * insert characters at start position, before start position.&#13;
   * start  equal 1 it means the text get inserted between actual grapheme 0 and 1&#13;
   * if style array is provided, it must be as the same length of text in graphemes&#13;
   * if end is provided and is bigger than start, old text is replaced.&#13;
   * start/end ar per grapheme position in _text array.&#13;
   *&#13;
   * @param {String} text text to insert&#13;
   * @param {Array} style array of style objects&#13;
   * @param {Number} start&#13;
   * @param {Number} end default to start + 1&#13;
   */&#13;
  insertChars: function(text, style, start, end) {&#13;
    if (typeof end === 'undefined') {&#13;
      end = start;&#13;
    }&#13;
    if (end &gt; start) {&#13;
      this.removeStyleFromTo(start, end);&#13;
    }&#13;
    var graphemes = fabric.util.string.graphemeSplit(text);&#13;
    this.insertNewStyleBlock(graphemes, start, style);&#13;
    this._text = [].concat(this._text.slice(0, start), graphemes, this._text.slice(end));&#13;
    this.text = this._text.join('');&#13;
    this.set('dirty', true);&#13;
    if (this._shouldClearDimensionCache()) {&#13;
      this.initDimensions();&#13;
      this.setCoords();&#13;
    }&#13;
    this._removeExtraneousStyles();&#13;
  },&#13;
&#13;
});&#13;
&#13;
&#13;
/* _TO_SVG_START_ */&#13;
(function() {&#13;
  var toFixed = fabric.util.toFixed,&#13;
      NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;&#13;
&#13;
  fabric.util.object.extend(fabric.Text.prototype, /** @lends fabric.Text.prototype */ {&#13;
&#13;
    /**&#13;
     * Returns SVG representation of an instance&#13;
     * @param {Function} [reviver] Method for further parsing of svg representation.&#13;
     * @return {String} svg representation of an instance&#13;
     */&#13;
    toSVG: function(reviver) {&#13;
      var markup = this._createBaseSVGMarkup(),&#13;
          offsets = this._getSVGLeftTopOffsets(),&#13;
          textAndBg = this._getSVGTextAndBg(offsets.textTop, offsets.textLeft);&#13;
      this._wrapSVGTextAndBg(markup, textAndBg);&#13;
&#13;
      return reviver ? reviver(markup.join('')) : markup.join('');&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _getSVGLeftTopOffsets: function() {&#13;
      return {&#13;
        textLeft: -this.width / 2,&#13;
        textTop: -this.height / 2,&#13;
        lineTop: this.getHeightOfLine(0)&#13;
      };&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _wrapSVGTextAndBg: function(markup, textAndBg) {&#13;
      var noShadow = true, filter = this.getSvgFilter(),&#13;
          style = filter === '' ? '' : ' style="' + filter + '"',&#13;
          textDecoration = this.getSvgTextDecoration(this);&#13;
      markup.push(&#13;
        '\t&lt;g ', this.getSvgId(), 'transform="', this.getSvgTransform(), this.getSvgTransformMatrix(), '"',&#13;
        style, '&gt;\n',&#13;
        textAndBg.textBgRects.join(''),&#13;
        '\t\t&lt;text xml:space="preserve" ',&#13;
        (this.fontFamily ? 'font-family="' + this.fontFamily.replace(/"/g, '\'') + '" ' : ''),&#13;
        (this.fontSize ? 'font-size="' + this.fontSize + '" ' : ''),&#13;
        (this.fontStyle ? 'font-style="' + this.fontStyle + '" ' : ''),&#13;
        (this.fontWeight ? 'font-weight="' + this.fontWeight + '" ' : ''),&#13;
        (textDecoration ? 'text-decoration="' + textDecoration + '" ' : ''),&#13;
        'style="', this.getSvgStyles(noShadow), '"', this.addPaintOrder(), ' &gt;',&#13;
        textAndBg.textSpans.join(''),&#13;
        '&lt;/text&gt;\n',&#13;
        '\t&lt;/g&gt;\n'&#13;
      );&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     * @param {Number} textTopOffset Text top offset&#13;
     * @param {Number} textLeftOffset Text left offset&#13;
     * @return {Object}&#13;
     */&#13;
    _getSVGTextAndBg: function(textTopOffset, textLeftOffset) {&#13;
      var textSpans = [],&#13;
          textBgRects = [],&#13;
          height = textTopOffset, lineOffset;&#13;
      // bounding-box background&#13;
      this._setSVGBg(textBgRects);&#13;
&#13;
      // text and text-background&#13;
      for (var i = 0, len = this._textLines.length; i &lt; len; i++) {&#13;
        lineOffset = this._getLineLeftOffset(i);&#13;
        if (this.textBackgroundColor || this.styleHas('textBackgroundColor', i)) {&#13;
          this._setSVGTextLineBg(textBgRects, i, textLeftOffset + lineOffset, height);&#13;
        }&#13;
        this._setSVGTextLineText(textSpans, i, textLeftOffset + lineOffset, height);&#13;
        height += this.getHeightOfLine(i);&#13;
      }&#13;
&#13;
      return {&#13;
        textSpans: textSpans,&#13;
        textBgRects: textBgRects&#13;
      };&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _createTextCharSpan: function(_char, styleDecl, left, top) {&#13;
      var styleProps = this.getSvgSpanStyles(styleDecl, _char !== _char.trim()),&#13;
          fillStyles = styleProps ? 'style="' + styleProps + '"' : '';&#13;
&#13;
      return [&#13;
        '&lt;tspan x="', toFixed(left, NUM_FRACTION_DIGITS), '" y="',&#13;
        toFixed(top, NUM_FRACTION_DIGITS), '" ',&#13;
        fillStyles, '&gt;',&#13;
        fabric.util.string.escapeXml(_char),&#13;
        '&lt;/tspan&gt;'&#13;
      ].join('');&#13;
    },&#13;
&#13;
    _setSVGTextLineText: function(textSpans, lineIndex, textLeftOffset, textTopOffset) {&#13;
      // set proper line offset&#13;
      var lineHeight = this.getHeightOfLine(lineIndex),&#13;
          isJustify = this.textAlign.indexOf('justify') !== -1,&#13;
          actualStyle,&#13;
          nextStyle,&#13;
          charsToRender = '',&#13;
          charBox, style,&#13;
          boxWidth = 0,&#13;
          line = this._textLines[lineIndex],&#13;
          timeToRender;&#13;
&#13;
      textTopOffset += lineHeight * (1 - this._fontSizeFraction) / this.lineHeight;&#13;
      for (var i = 0, len = line.length - 1; i &lt;= len; i++) {&#13;
        timeToRender = i === len || this.charSpacing;&#13;
        charsToRender += line[i];&#13;
        charBox = this.__charBounds[lineIndex][i];&#13;
        if (boxWidth === 0) {&#13;
          textLeftOffset += charBox.kernedWidth - charBox.width;&#13;
          boxWidth += charBox.width;&#13;
        }&#13;
        else {&#13;
          boxWidth += charBox.kernedWidth;&#13;
        }&#13;
        if (isJustify &amp;&amp; !timeToRender) {&#13;
          if (this._reSpaceAndTab.test(line[i])) {&#13;
            timeToRender = true;&#13;
          }&#13;
        }&#13;
        if (!timeToRender) {&#13;
          // if we have charSpacing, we render char by char&#13;
          actualStyle = actualStyle || this.getCompleteStyleDeclaration(lineIndex, i);&#13;
          nextStyle = this.getCompleteStyleDeclaration(lineIndex, i + 1);&#13;
          timeToRender = this._hasStyleChangedForSvg(actualStyle, nextStyle);&#13;
        }&#13;
        if (timeToRender) {&#13;
          style = this._getStyleDeclaration(lineIndex, i) || { };&#13;
          textSpans.push(this._createTextCharSpan(charsToRender, style, textLeftOffset, textTopOffset));&#13;
          charsToRender = '';&#13;
          actualStyle = nextStyle;&#13;
          textLeftOffset += boxWidth;&#13;
          boxWidth = 0;&#13;
        }&#13;
      }&#13;
    },&#13;
&#13;
    _pushTextBgRect: function(textBgRects, color, left, top, width, height) {&#13;
      textBgRects.push(&#13;
        '\t\t&lt;rect ',&#13;
        this._getFillAttributes(color),&#13;
        ' x="',&#13;
        toFixed(left, NUM_FRACTION_DIGITS),&#13;
        '" y="',&#13;
        toFixed(top, NUM_FRACTION_DIGITS),&#13;
        '" width="',&#13;
        toFixed(width, NUM_FRACTION_DIGITS),&#13;
        '" height="',&#13;
        toFixed(height, NUM_FRACTION_DIGITS),&#13;
        '"&gt;&lt;/rect&gt;\n');&#13;
    },&#13;
&#13;
    _setSVGTextLineBg: function(textBgRects, i, leftOffset, textTopOffset) {&#13;
      var line = this._textLines[i],&#13;
          heightOfLine = this.getHeightOfLine(i) / this.lineHeight,&#13;
          boxWidth = 0,&#13;
          boxStart = 0,&#13;
          charBox, currentColor,&#13;
          lastColor = this.getValueOfPropertyAt(i, 0, 'textBackgroundColor');&#13;
      for (var j = 0, jlen = line.length; j &lt; jlen; j++) {&#13;
        charBox = this.__charBounds[i][j];&#13;
        currentColor = this.getValueOfPropertyAt(i, j, 'textBackgroundColor');&#13;
        if (currentColor !== lastColor) {&#13;
          lastColor &amp;&amp; this._pushTextBgRect(textBgRects, lastColor, leftOffset + boxStart,&#13;
            textTopOffset, boxWidth, heightOfLine);&#13;
          boxStart = charBox.left;&#13;
          boxWidth = charBox.width;&#13;
          lastColor = currentColor;&#13;
        }&#13;
        else {&#13;
          boxWidth += charBox.kernedWidth;&#13;
        }&#13;
      }&#13;
      currentColor &amp;&amp; this._pushTextBgRect(textBgRects, currentColor, leftOffset + boxStart,&#13;
        textTopOffset, boxWidth, heightOfLine);&#13;
    },&#13;
&#13;
    /**&#13;
     * Adobe Illustrator (at least CS5) is unable to render rgba()-based fill values&#13;
     * we work around it by "moving" alpha channel into opacity attribute and setting fill's alpha to 1&#13;
     *&#13;
     * @private&#13;
     * @param {*} value&#13;
     * @return {String}&#13;
     */&#13;
    _getFillAttributes: function(value) {&#13;
      var fillColor = (value &amp;&amp; typeof value === 'string') ? new fabric.Color(value) : '';&#13;
      if (!fillColor || !fillColor.getSource() || fillColor.getAlpha() === 1) {&#13;
        return 'fill="' + value + '"';&#13;
      }&#13;
      return 'opacity="' + fillColor.getAlpha() + '" fill="' + fillColor.setAlpha(1).toRgb() + '"';&#13;
    },&#13;
&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _getSVGLineTopOffset: function(lineIndex) {&#13;
      var lineTopOffset = 0, lastHeight = 0;&#13;
      for (var j = 0; j &lt; lineIndex; j++) {&#13;
        lineTopOffset += this.getHeightOfLine(j);&#13;
      }&#13;
      lastHeight = this.getHeightOfLine(j);&#13;
      return {&#13;
        lineTop: lineTopOffset,&#13;
        offset: (this._fontSizeMult - this._fontSizeFraction) * lastHeight / (this.lineHeight * this._fontSizeMult)&#13;
      };&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns styles-string for svg-export&#13;
     * @param {Boolean} skipShadow a boolean to skip shadow filter output&#13;
     * @return {String}&#13;
     */&#13;
    getSvgStyles: function(skipShadow) {&#13;
      var svgStyle = fabric.Object.prototype.getSvgStyles.call(this, skipShadow);&#13;
      return svgStyle + ' white-space: pre;';&#13;
    },&#13;
  });&#13;
})();&#13;
/* _TO_SVG_END_ */&#13;
&#13;
&#13;
(function(global) {&#13;
&#13;
  'use strict';&#13;
&#13;
  var fabric = global.fabric || (global.fabric = {});&#13;
&#13;
  /**&#13;
   * Textbox class, based on IText, allows the user to resize the text rectangle&#13;
   * and wraps lines automatically. Textboxes have their Y scaling locked, the&#13;
   * user can only change width. Height is adjusted automatically based on the&#13;
   * wrapping of lines.&#13;
   * @class fabric.Textbox&#13;
   * @extends fabric.IText&#13;
   * @mixes fabric.Observable&#13;
   * @return {fabric.Textbox} thisArg&#13;
   * @see {@link fabric.Textbox#initialize} for constructor definition&#13;
   */&#13;
  fabric.Textbox = fabric.util.createClass(fabric.IText, fabric.Observable, {&#13;
&#13;
    /**&#13;
     * Type of an object&#13;
     * @type String&#13;
     * @default&#13;
     */&#13;
    type: 'textbox',&#13;
&#13;
    /**&#13;
     * Minimum width of textbox, in pixels.&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    minWidth: 20,&#13;
&#13;
    /**&#13;
     * Minimum calculated width of a textbox, in pixels.&#13;
     * fixed to 2 so that an empty textbox cannot go to 0&#13;
     * and is still selectable without text.&#13;
     * @type Number&#13;
     * @default&#13;
     */&#13;
    dynamicMinWidth: 2,&#13;
&#13;
    /**&#13;
     * Cached array of text wrapping.&#13;
     * @type Array&#13;
     */&#13;
    __cachedLines: null,&#13;
&#13;
    /**&#13;
     * Override standard Object class values&#13;
     */&#13;
    lockScalingFlip: true,&#13;
&#13;
    /**&#13;
     * Override standard Object class values&#13;
     * Textbox needs this on false&#13;
     */&#13;
    noScaleCache: false,&#13;
&#13;
    /**&#13;
     * Properties which when set cause object to change dimensions&#13;
     * @type Object&#13;
     * @private&#13;
     */&#13;
    _dimensionAffectingProps: fabric.Text.prototype._dimensionAffectingProps.concat('width'),&#13;
&#13;
    /**&#13;
     * Constructor. Some scaling related property values are forced. Visibility&#13;
     * of controls is also fixed; only the rotation and width controls are&#13;
     * made available.&#13;
     * @param {String} text Text string&#13;
     * @param {Object} [options] Options object&#13;
     * @return {fabric.Textbox} thisArg&#13;
     */&#13;
    initialize: function(text, options) {&#13;
      this.callSuper('initialize', text, options);&#13;
    },&#13;
&#13;
    /**&#13;
     * Unlike superclass's version of this function, Textbox does not update&#13;
     * its width.&#13;
     * @private&#13;
     * @override&#13;
     */&#13;
    initDimensions: function() {&#13;
      if (this.__skipDimension) {&#13;
        return;&#13;
      }&#13;
      this.isEditing &amp;&amp; this.initDelayedCursor();&#13;
      this.clearContextTop();&#13;
      this._clearCache();&#13;
      // clear dynamicMinWidth as it will be different after we re-wrap line&#13;
      this.dynamicMinWidth = 0;&#13;
      // wrap lines&#13;
      this._styleMap = this._generateStyleMap(this._splitText());&#13;
      // if after wrapping, the width is smaller than dynamicMinWidth, change the width and re-wrap&#13;
      if (this.dynamicMinWidth &gt; this.width) {&#13;
        this._set('width', this.dynamicMinWidth);&#13;
      }&#13;
      if (this.textAlign.indexOf('justify') !== -1) {&#13;
        // once text is measured we need to make space fatter to make justified text.&#13;
        this.enlargeSpaces();&#13;
      }&#13;
      // clear cache and re-calculate height&#13;
      this.height = this.calcTextHeight();&#13;
      this.saveState({ propertySet: '_dimensionAffectingProps' });&#13;
    },&#13;
&#13;
    /**&#13;
     * Generate an object that translates the style object so that it is&#13;
     * broken up by visual lines (new lines and automatic wrapping).&#13;
     * The original text styles object is broken up by actual lines (new lines only),&#13;
     * which is only sufficient for Text / IText&#13;
     * @private&#13;
     */&#13;
    _generateStyleMap: function(textInfo) {&#13;
      var realLineCount     = 0,&#13;
          realLineCharCount = 0,&#13;
          charCount         = 0,&#13;
          map               = {};&#13;
&#13;
      for (var i = 0; i &lt; textInfo.graphemeLines.length; i++) {&#13;
        if (textInfo.graphemeText[charCount] === '\n' &amp;&amp; i &gt; 0) {&#13;
          realLineCharCount = 0;&#13;
          charCount++;&#13;
          realLineCount++;&#13;
        }&#13;
        else if (this._reSpaceAndTab.test(textInfo.graphemeText[charCount]) &amp;&amp; i &gt; 0) {&#13;
          // this case deals with space's that are removed from end of lines when wrapping&#13;
          realLineCharCount++;&#13;
          charCount++;&#13;
        }&#13;
&#13;
        map[i] = { line: realLineCount, offset: realLineCharCount };&#13;
&#13;
        charCount += textInfo.graphemeLines[i].length;&#13;
        realLineCharCount += textInfo.graphemeLines[i].length;&#13;
      }&#13;
&#13;
      return map;&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns true if object has a style property or has it ina specified line&#13;
     * @param {Number} lineIndex&#13;
     * @return {Boolean}&#13;
     */&#13;
    styleHas: function(property, lineIndex) {&#13;
      if (this._styleMap &amp;&amp; !this.isWrapping) {&#13;
        var map = this._styleMap[lineIndex];&#13;
        if (map) {&#13;
          lineIndex = map.line;&#13;
        }&#13;
      }&#13;
      return fabric.Text.prototype.styleHas.call(this, property, lineIndex);&#13;
    },&#13;
&#13;
    /**&#13;
     * @param {Number} lineIndex&#13;
     * @param {Number} charIndex&#13;
     * @private&#13;
     */&#13;
    _getStyleDeclaration: function(lineIndex, charIndex) {&#13;
      if (this._styleMap &amp;&amp; !this.isWrapping) {&#13;
        var map = this._styleMap[lineIndex];&#13;
        if (!map) {&#13;
          return null;&#13;
        }&#13;
        lineIndex = map.line;&#13;
        charIndex = map.offset + charIndex;&#13;
      }&#13;
      return this.callSuper('_getStyleDeclaration', lineIndex, charIndex);&#13;
    },&#13;
&#13;
    /**&#13;
     * @param {Number} lineIndex&#13;
     * @param {Number} charIndex&#13;
     * @param {Object} style&#13;
     * @private&#13;
     */&#13;
    _setStyleDeclaration: function(lineIndex, charIndex, style) {&#13;
      var map = this._styleMap[lineIndex];&#13;
      lineIndex = map.line;&#13;
      charIndex = map.offset + charIndex;&#13;
&#13;
      this.styles[lineIndex][charIndex] = style;&#13;
    },&#13;
&#13;
    /**&#13;
     * @param {Number} lineIndex&#13;
     * @param {Number} charIndex&#13;
     * @private&#13;
     */&#13;
    _deleteStyleDeclaration: function(lineIndex, charIndex) {&#13;
      var map = this._styleMap[lineIndex];&#13;
      lineIndex = map.line;&#13;
      charIndex = map.offset + charIndex;&#13;
&#13;
      delete this.styles[lineIndex][charIndex];&#13;
    },&#13;
&#13;
    /**&#13;
     * @param {Number} lineIndex&#13;
     * @private&#13;
     */&#13;
    _getLineStyle: function(lineIndex) {&#13;
      var map = this._styleMap[lineIndex];&#13;
      return this.styles[map.line];&#13;
    },&#13;
&#13;
    /**&#13;
     * @param {Number} lineIndex&#13;
     * @param {Object} style&#13;
     * @private&#13;
     */&#13;
    _setLineStyle: function(lineIndex, style) {&#13;
      var map = this._styleMap[lineIndex];&#13;
      this.styles[map.line] = style;&#13;
    },&#13;
&#13;
    /**&#13;
     * @param {Number} lineIndex&#13;
     * @private&#13;
     */&#13;
    _deleteLineStyle: function(lineIndex) {&#13;
      var map = this._styleMap[lineIndex];&#13;
      delete this.styles[map.line];&#13;
    },&#13;
&#13;
    /**&#13;
     * Wraps text using the 'width' property of Textbox. First this function&#13;
     * splits text on newlines, so we preserve newlines entered by the user.&#13;
     * Then it wraps each line using the width of the Textbox by calling&#13;
     * _wrapLine().&#13;
     * @param {Array} lines The string array of text that is split into lines&#13;
     * @param {Number} desiredWidth width you want to wrap to&#13;
     * @returns {Array} Array of lines&#13;
     */&#13;
    _wrapText: function(lines, desiredWidth) {&#13;
      var wrapped = [], i;&#13;
      this.isWrapping = true;&#13;
      for (i = 0; i &lt; lines.length; i++) {&#13;
        wrapped = wrapped.concat(this._wrapLine(lines[i], i, desiredWidth));&#13;
      }&#13;
      this.isWrapping = false;&#13;
      return wrapped;&#13;
    },&#13;
&#13;
    /**&#13;
     * Helper function to measure a string of text, given its lineIndex and charIndex offset&#13;
     * it gets called when charBounds are not available yet.&#13;
     * @param {CanvasRenderingContext2D} ctx&#13;
     * @param {String} text&#13;
     * @param {number} lineIndex&#13;
     * @param {number} charOffset&#13;
     * @returns {number}&#13;
     * @private&#13;
     */&#13;
    _measureWord: function(word, lineIndex, charOffset) {&#13;
      var width = 0, prevGrapheme, skipLeft = true;&#13;
      charOffset = charOffset || 0;&#13;
      for (var i = 0, len = word.length; i &lt; len; i++) {&#13;
        var box = this._getGraphemeBox(word[i], lineIndex, i + charOffset, prevGrapheme, skipLeft);&#13;
        width += box.kernedWidth;&#13;
        prevGrapheme = word[i];&#13;
      }&#13;
      return width;&#13;
    },&#13;
&#13;
    /**&#13;
     * Wraps a line of text using the width of the Textbox and a context.&#13;
     * @param {Array} line The grapheme array that represent the line&#13;
     * @param {Number} lineIndex&#13;
     * @param {Number} desiredWidth width you want to wrap the line to&#13;
     * @returns {Array} Array of line(s) into which the given text is wrapped&#13;
     * to.&#13;
     */&#13;
    _wrapLine: function(_line, lineIndex, desiredWidth) {&#13;
      var lineWidth        = 0,&#13;
          graphemeLines    = [],&#13;
          line             = [],&#13;
          // spaces in different languges?&#13;
          words            = _line.split(this._reSpaceAndTab),&#13;
          word             = '',&#13;
          offset           = 0,&#13;
          infix            = ' ',&#13;
          wordWidth        = 0,&#13;
          infixWidth       = 0,&#13;
          largestWordWidth = 0,&#13;
          lineJustStarted = true,&#13;
          additionalSpace = this._getWidthOfCharSpacing();&#13;
      for (var i = 0; i &lt; words.length; i++) {&#13;
        // i would avoid resplitting the graphemes&#13;
        word = fabric.util.string.graphemeSplit(words[i]);&#13;
        wordWidth = this._measureWord(word, lineIndex, offset);&#13;
        offset += word.length;&#13;
&#13;
        lineWidth += infixWidth + wordWidth - additionalSpace;&#13;
&#13;
        if (lineWidth &gt;= desiredWidth &amp;&amp; !lineJustStarted) {&#13;
          graphemeLines.push(line);&#13;
          line = [];&#13;
          lineWidth = wordWidth;&#13;
          lineJustStarted = true;&#13;
        }&#13;
&#13;
        if (!lineJustStarted) {&#13;
          line.push(infix);&#13;
        }&#13;
        line = line.concat(word);&#13;
&#13;
        infixWidth = this._measureWord([infix], lineIndex, offset);&#13;
        offset++;&#13;
        lineJustStarted = false;&#13;
        // keep track of largest word&#13;
        if (wordWidth &gt; largestWordWidth) {&#13;
          largestWordWidth = wordWidth;&#13;
        }&#13;
      }&#13;
&#13;
      i &amp;&amp; graphemeLines.push(line);&#13;
&#13;
      if (largestWordWidth &gt; this.dynamicMinWidth) {&#13;
        this.dynamicMinWidth = largestWordWidth - additionalSpace;&#13;
      }&#13;
&#13;
      return graphemeLines;&#13;
    },&#13;
&#13;
    /**&#13;
     * Detect if the text line is ended with an hard break&#13;
     * text and itext do not have wrapping, return false&#13;
     * @param {Number} lineIndex text to split&#13;
     * @return {Boolean}&#13;
     */&#13;
    isEndOfWrapping: function(lineIndex) {&#13;
      if (!this._styleMap[lineIndex + 1]) {&#13;
        // is last line, return true;&#13;
        return true;&#13;
      }&#13;
      if (this._styleMap[lineIndex + 1].line !== this._styleMap[lineIndex].line) {&#13;
        // this is last line before a line break, return true;&#13;
        return true;&#13;
      }&#13;
      return false;&#13;
    },&#13;
&#13;
    /**&#13;
    * Gets lines of text to render in the Textbox. This function calculates&#13;
    * text wrapping on the fly every time it is called.&#13;
    * @param {String} text text to split&#13;
    * @returns {Array} Array of lines in the Textbox.&#13;
    * @override&#13;
    */&#13;
    _splitTextIntoLines: function(text) {&#13;
      var newText = fabric.Text.prototype._splitTextIntoLines.call(this, text),&#13;
          graphemeLines = this._wrapText(newText.lines, this.width),&#13;
          lines = new Array(graphemeLines.length);&#13;
&#13;
      for (var i = 0; i &lt; graphemeLines.length; i++) {&#13;
        lines[i] = graphemeLines[i].join('');&#13;
      }&#13;
      newText.lines = lines;&#13;
      newText.graphemeLines = graphemeLines;&#13;
      return newText;&#13;
    },&#13;
&#13;
    getMinWidth: function() {&#13;
      return Math.max(this.minWidth, this.dynamicMinWidth);&#13;
    },&#13;
&#13;
    /**&#13;
     * Returns object representation of an instance&#13;
     * @method toObject&#13;
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output&#13;
     * @return {Object} object representation of an instance&#13;
     */&#13;
    toObject: function(propertiesToInclude) {&#13;
      return this.callSuper('toObject', ['minWidth'].concat(propertiesToInclude));&#13;
    }&#13;
  });&#13;
&#13;
  /**&#13;
   * Returns fabric.Textbox instance from an object representation&#13;
   * @static&#13;
   * @memberOf fabric.Textbox&#13;
   * @param {Object} object Object to create an instance from&#13;
   * @param {Function} [callback] Callback to invoke when an fabric.Textbox instance is created&#13;
   */&#13;
  fabric.Textbox.fromObject = function(object, callback) {&#13;
    return fabric.Object._fromObject('Textbox', object, callback, 'text');&#13;
  };&#13;
})(typeof exports !== 'undefined' ? exports : this);&#13;
&#13;
&#13;
(function() {&#13;
&#13;
  /**&#13;
   * Override _setObjectScale and add Textbox specific resizing behavior. Resizing&#13;
   * a Textbox doesn't scale text, it only changes width and makes text wrap automatically.&#13;
   */&#13;
  var setObjectScaleOverridden = fabric.Canvas.prototype._setObjectScale;&#13;
&#13;
  fabric.Canvas.prototype._setObjectScale = function(localMouse, transform,&#13;
    lockScalingX, lockScalingY, by, lockScalingFlip, _dim) {&#13;
&#13;
    var t = transform.target;&#13;
    if (by === 'x' &amp;&amp; t instanceof fabric.Textbox) {&#13;
      var tw = t._getTransformedDimensions().x;&#13;
      var w = t.width * (localMouse.x / tw);&#13;
      if (w &gt;= t.getMinWidth()) {&#13;
        t.set('width', w);&#13;
        return true;&#13;
      }&#13;
    }&#13;
    else {&#13;
      return setObjectScaleOverridden.call(fabric.Canvas.prototype, localMouse, transform,&#13;
        lockScalingX, lockScalingY, by, lockScalingFlip, _dim);&#13;
    }&#13;
  };&#13;
&#13;
  fabric.util.object.extend(fabric.Textbox.prototype, /** @lends fabric.IText.prototype */ {&#13;
    /**&#13;
     * @private&#13;
     */&#13;
    _removeExtraneousStyles: function() {&#13;
      for (var prop in this._styleMap) {&#13;
        if (!this._textLines[prop]) {&#13;
          delete this.styles[this._styleMap[prop].line];&#13;
        }&#13;
      }&#13;
    },&#13;
&#13;
  });&#13;
})();</script>
        <script_name>Fabricjs</script_name>
        <sys_class_name>sys_ui_script</sys_class_name>
        <sys_created_by>dylan.lindgren</sys_created_by>
        <sys_created_on>2018-01-23 02:30:55</sys_created_on>
        <sys_customer_update>false</sys_customer_update>
        <sys_id>6faef90edb3303008cfb70f08c96195b</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_name>x_pisn_imagemap.Fabricjs</sys_name>
        <sys_package display_value="Image Map for Catalog Items" source="x_pisn_imagemap">fe4bf50adb3303008cfb70f08c9619df</sys_package>
        <sys_policy/>
        <sys_replace_on_upgrade>false</sys_replace_on_upgrade>
        <sys_scope display_value="Image Map for Catalog Items">fe4bf50adb3303008cfb70f08c9619df</sys_scope>
        <sys_update_name>sys_ui_script_6faef90edb3303008cfb70f08c96195b</sys_update_name>
        <sys_updated_by>dylan.lindgren</sys_updated_by>
        <sys_updated_on>2018-01-23 02:30:55</sys_updated_on>
        <use_scoped_format>false</use_scoped_format>
    </sys_ui_script>
</record_update>
